<!DOCTYPE html><html lang="en &amp;&amp; zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>§5 Advanced-SQL课件详解 | Yuejin's Blog</title><meta name="keywords" content="Database,SQL"><meta name="author" content="Yuejin Wu"><meta name="copyright" content="Yuejin Wu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="§5 Advanced-SQL课件详解"><meta name="application-name" content="§5 Advanced-SQL课件详解"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="§5 Advanced-SQL课件详解"><meta property="og:url" content="http://example.com/2025/12/24/DB_AdvancedSQL/index.html"><meta property="og:site_name" content="Yuejin's Blog"><meta property="og:description" content="章节标题与大纲 第五章：高级SQL 授课时间：2025年10月 授课单位：计算机学院 本章大纲 本章旨在深入探讨超越基础SQL操作的高级特性，重点涵盖以下三个核心领域：  从编程语言访问SQL：探讨如何在Java、C等通用编程语言中执行SQL语句，实现应用程序与数据库系统的交互。 函数和存储过程：学"><meta property="og:locale" content="en &amp;&amp; zh-Hans"><meta property="og:image" content="http://example.com/img/SQL_cover.png"><meta property="article:author" content="Yuejin Wu"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/SQL_cover.png"><meta name="description" content="章节标题与大纲 第五章：高级SQL 授课时间：2025年10月 授课单位：计算机学院 本章大纲 本章旨在深入探讨超越基础SQL操作的高级特性，重点涵盖以下三个核心领域：  从编程语言访问SQL：探讨如何在Java、C等通用编程语言中执行SQL语句，实现应用程序与数据库系统的交互。 函数和存储过程：学"><link rel="shortcut icon" href="/img/mylogo.jpg"><link rel="canonical" href="http://example.com/2025/12/24/DB_AdvancedSQL/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":null,"LingQueMonitorID":null},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Yuejin Wu","link":"链接: ","source":"来源: Yuejin's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Yuejin's Blog',
  title: '§5 Advanced-SQL课件详解',
  postAI: '',
  pageFillDescription: '章节标题与大纲, 第五章：高级SQL, 本章大纲, 从编程语言访问SQL（概述与架构）, 5.1 从编程语言访问SQL, 5.1.0 数据库应用系统（DBAS）架构回顾, 5.1.1 两种主要的访问范式, JDBC详解（基础与核心流程）, 5.1.2 JDBC（Java Database Connectivity）, 特性与用途, JDBC核心代码示例与逐步解析, 关键点解析, 处理空值（Null Values）, JDBC高级特性（预编译语句、元数据、事务控制）, 5.1.2.1 预编译语句（PreparedStatement）, 5.1.2.2 元数据特性（Metadata）, 5.1.2.3 事务控制（Transaction Control）, 5.1.2.4 调用函数和存储过程, ODBC详解, 5.1.3 ODBC（Open Database Connectivity）, 架构, ODBC C语言编程示例与逐步解析, 关于连接时长的重要说明, 嵌入式SQL详解, 5.1.4 嵌入式SQL, SQL的使用方式分类, 基本概念, 语法要素与示例, 游标（Cursor）：处理多行结果集的关键机制, 通过游标进行定位更新或删除, SQL函数与存储过程, 5.2 函数与存储过程, 5.2.1 SQL标量函数示例, 5.2.2 SQL存储过程示例, 5.2.3 优势与存储, 触发器, 5.3 触发器, 5.3.1 概述, 5.3.2 触发事件与动作, 5.3.3 行级触发器示例详解, 5.3.4 语句级触发器, 5.3.5 何时应避免使用触发器, 本章总结与展望, 本章总结, 后续章节展望（简要提及）章节标题与大纲第五章高级授课时间年月授课单位计算机学院本章大纲本章旨在深入探讨超越基础操作的高级特性重点涵盖以下三个核心领域从编程语言访问探讨如何在等通用编程语言中执行语句实现应用程序与数据库系统的交互函数和存储过程学习在数据库服务器端创建可重用的程序化逻辑单元包括标量函数和存储过程触发器掌握基于事件条件动作模型的数据库自动化响应机制用于维护数据完整性和执行业务规则从编程语言访问概述与架构从编程语言访问数据库应用系统架构回顾数据库应用系统是由用户应用程序数据库管理系统和数据库共同构成的完整体系应用程序作为用户与数据库之间的桥梁需要通过特定的应用程序编程接口与数据库服务器进行交互这一交互过程通常遵循以下步骤建立与数据库服务器的连接通过连接向服务器发送命令查询或更新对于查询操作以一次一个元组的方式将结果集提取到应用程序的变量中进行后续处理两种主要的访问范式从编程语言访问主要有两种实现途径它们在集成方式和执行时机上存在根本区别动态定义在通用编程语言中程序在运行时动态地构建查询字符串并通过函数调用如将该字符串提交给数据库服务器执行然后处理返回的结果核心特征灵活性高语句可以根据程序逻辑和用户输入动态生成显式控制程序员需手动管理连接语句执行结果获取和资源释放的全生命周期主流技术标准专为语言设计的数据库连接标准一种开放的与语言和数据库无关的调用级接口标准广泛用于等语言嵌入式定义将语句直接编写在宿主语言如的源代码中在编译程序之前先由一个预处理器扫描源代码将这些嵌入式语句转换为对数据库运行时库的特定函数调用随后再由宿主语言的编译器进行编译核心特征编译时确定语句在编译期是可见的可进行早期语法检查和优化编程模型更贴近使用游标机制处理多行结果集语法上更接近直接的交互底层依赖动态最终生成的函数调用实质上利用了动态的如来完成数据库通信详解基础与核心流程特性与用途是平台中用于执行语句的一套标准它不仅支持数据的查询与更新还提供了检索数据库元数据的能力例如查询数据库中有哪些表表中各列的名称和数据类型等建立了一套标准的通信模型打开一个数据库连接创建一个语句对象使用该对象发送查询并获取结果利用的异常处理机制来管理操作中可能出现的错误核心代码示例与逐步解析以下是一个完整的方法示例演示了连接数据库执行插入和查询操作的全过程步骤加载数据库驱动程序可省略此步骤告知运行时环境所要使用的驱动实现类注意自起驱动可自动加载此语句常可省略步骤建立数据库连接使用的方法传入数据库用户名和密码格式因数据库厂商而异本例连接一个数据库数据库用户名密码步骤创建语句对象通过对象创建一个对象用于执行静态语句步骤执行数据更新操作使用方法它返回受影响的行数捕获并处理可能发生的异常如主键冲突违反约束等步骤执行数据查询操作使用方法执行语句返回一个结果集对象步骤遍历并处理结果集的方法将游标移动到下一行首次调用移至第一行当没有更多行时返回使用列名和列索引等方法获取当前行的列值列索引从开始步骤清理资源至关重要必须按顺序关闭和以释放数据库和系统资源实际开发中应使用语句确保资源被关闭捕获连接语句创建等过程中更广泛的异常捕获其他非异常关键点解析此语句显式加载特定的驱动类这是及之前版本的规范做法在及以上版本只要驱动包在类路径中驱动管理器可以自动发现并加载驱动因此这行代码常可省略这是建立连接的工厂方法数据库的格式是驱动特定的表示使用的驱动连接主机上端口的服务用于执行会修改数据库内容的语句等返回一个整数表示受影响的行数专门用于执行语句返回一个对象处理结果集初始时游标位于第一行之前方法将游标向前移动一行并返回一个布尔值指示新行是否有效可以使用列名字符串或列索引从开始来获取列值和是等价的假设是子句中的第一个元素异常处理几乎所有操作都可能抛出必须妥善处理通常使用块来捕获并至少记录错误信息资源管理和都是持有昂贵底层资源如数据库连接服务器游标的对象必须在使用完毕后显式调用方法将其关闭以防止资源泄漏推荐使用引入的语法实现自动关闭处理空值从中读取数据时如果某列的值为则方法会返回对应类型的默认值如为了准确区分数据库中的和默认值可以使用方法高级特性预编译语句元数据事务控制预编译语句预编译语句是接口的一个更强大更安全通常也更高效的子接口工作原理语句在创建对象时即被发送到数据库进行预编译语句中的变量部分用占位符表示之后每次执行只需为这些传入具体的参数值即可优势性能对于需要重复执行多次仅参数不同的语句数据库只需编译一次后续执行直接使用编译好的执行计划效率显著提升安全有效防止注入攻击因为参数值是通过方法传递的而不是拼接到字符串中数据库会将其视为纯粹的数据而非可执行代码的一部分可读性与维护性将逻辑与参数值分离代码更清晰创建与使用示例创建使用作为参数占位符设置参数值索引从开始设置第一个为设置第二个为设置第三个为设置第四个为执行更新注意这里没有字符串参数重用同一个插入另一条记录只需重新设置变化的参数仅修改再次执行关键说明前四个语句仅仅是为语句的参数赋值并没有触发数据库的插入操作真正的插入是在调用时执行的这允许在批量操作中高效地复用同一个对象元数据特性元数据是关于数据的数据提供了访问两类元数据的接口结果集元数据获取关于特定查询结果的结构信息还有其他方法如等用途动态处理未知结构的查询结果常用于通用查询工具或报表生成器数据库元数据获取关于整个数据库的目录信息如所有表列主键外键等获取表的所有列参数目录模式表名模式列名模式表示所有目录表示所有类似于的获取表的主键信息参数目录模式表名表示该列在主键中的顺序针对复合主键事务控制默认情况下连接处于自动提交模式每条语句都被视为一个独立的事务并在执行后立即自动提交问题对于包含多个更新操作的逻辑单元如银行转账自动提交会导致原子性无法保证如果中间某条语句失败之前已提交的更改无法自动撤销解决方案手动管理事务关闭自动提交执行一系列更新操作如果全部成功手动提交事务如果发生任何异常回滚事务撤销所有未提交的更改处理回滚异常处理原异常恢复自动提交模式可选但建议处理异常调用函数和存储过程使用接口调用数据库中的存储函数和存储过程调用函数有返回值语法注册第一个为输出参数返回值设置第二个为输入参数获取返回值调用过程无返回值或通过参数返回语法详解是一个由微软主导制定的开放数据库互连标准它提供了一个与编程语言和数据库管理系统均无关的调用级架构采用分层驱动架构应用程序调用标准的函数驱动程序管理器作为应用程序的入口点负责加载卸载驱动程序并将应用程序的调用分派给正确的驱动程序驱动程序由各个数据库厂商提供负责将标准的函数调用转换为特定数据库的网络协议或本地调用如调用的库的协议等数据源通过管理器配置的指向特定数据库服务器的连接定义语言编程示例与逐步解析以下程序片段展示了使用连接数据库执行查询并获取结果的完整流程包含详细的步骤注释步骤声明变量用于接收每个调用的返回码等环境句柄代表的上下文环境连接句柄代表一个数据库连接语句句柄代表一个语句步骤分配环境句柄步骤分配连接句柄步骤建立连接参数连接句柄服务器名用户名密码表示前一个参数是以空字符结尾的字符串服务器用户名密码步骤分配语句句柄步骤准备并执行语句直接执行一个字符串步骤将结果列绑定到程序变量用于接收的缓冲区用于接收的变量用于接收字符串实际长度可为指示符将结果集的列与程序变量关联参数语句句柄列号从开始变量类型变量地址缓冲区长度长度指示符缓冲区地址长度用于非字符串类型步骤循环获取每一行结果将游标移动到下一行并将已绑定的列数据提取到对应的变量中检查指示符判断数据是否为如果则无效处理错误可以使用函数获取详细的错误信息步骤清理资源逆序释放释放语句句柄断开连接释放连接句柄释放环境句柄关于连接时长的重要说明在实际生产环境中数据库服务器或网络设备通常会对客户端连接设置超时限制例如非活动连接秒后自动断开如果应用程序执行一个非常耗时的查询其执行时间超过了连接的超时设置那么该查询可能会被服务器强行终止导致操作失败注意事项使用默认连接设置时必须确保任何单个数据库操作都不会超过系统的默认连接超时时长解决方案如或连接字符串参数通常允许应用程序调整连接超时或查询超时设置在开发需要执行长时间操作的应用程序时必须合理配置这些超时参数以保证操作的顺利完成嵌入式详解嵌入式的使用方式分类交互式用户通过数据库系统提供的命令行界面或图形工具直接输入并执行语句主要用于数据定义和即席查询动态如前所述的在程序运行时动态构建和执行字符串嵌入式将语句直接嵌入到等宿主语言的源代码中在程序编译前通过预处理器进行转换基本概念宿主语言嵌入语句的通用编程语言如预处理器一个专门的工具它扫描包含嵌入式的源代码文件识别出所有语句将它们转换为对数据库运行时库通常基于或类似接口的函数调用并生成一个纯宿主语言的中间文件供编译器编译优点结合了强大的数据操作能力和宿主语言的计算流程控制及输入输出能力适用于编写复杂的数据处理应用程序语法要素与示例语句标识所有嵌入式语句都以开头以宿主语言特定的结束符结尾语言中常用分号中用语句连接数据库共享变量宿主变量宿主语言的变量可以在嵌入式语句中使用以冒号作为前缀以便与自身的列名区分这些共享变量必须在专门的中声明宿主变量用于接收用于接收从用户输入或其他地方为赋值在子句中使用宿主变量游标处理多行结果集的关键机制当嵌入式查询可能返回多行结果时无法直接用子句将多行赋值给有限的宿主变量此时必须使用游标声明游标将游标与一个查询关联打开游标执行游标关联的查询此时会准备结果集可能物化到一个临时区域游标定位在结果集第一行之前重要打开游标时查询中引用的宿主变量如的值被定格使用后续修改该宿主变量不会影响已打开的游标结果提取数据将游标向前推进一行并将该行数据提取到指定的宿主变量中每次后需要检查通信区中的返回码判断是否成功提取到数据或已到达结果集末尾关闭游标释放与游标相关的数据库资源如临时存储空间锁等完整游标使用循环示例获取的值使用中的一个变量检查状态表示成功表示无更多数据通过游标进行定位更新或删除游标不仅可以读取数据还可以用于更新或删除当前行声明一个用于更新的游标必须使用子句指定可更新的列将整行数据提取到对应的宿主变量更新当前游标指向的行关键定位更新函数与存储过程函数与存储过程允许在数据库服务器端创建命名的可重用的程序化模块函数和存储过程它们可以用语言自身编写也可以用外部编程语言如编写外部语言函数过程适用于处理复杂计算或特定数据类型如图像几何对象例如用编写一个函数来判断两个多边形是否重叠表值函数一种特殊函数可以返回一个关系表作为结果的编程扩展标准引入了丰富的程序化构造如变量声明条件语句循环和赋值使得用纯编写复杂逻辑成为可能标量函数示例创建一个返回指定部门教师人数的函数声明局部变量将查询结果赋值给局部变量返回结果使用函数在查询中像内置函数一样调用存储过程示例将上述功能改写为存储过程存储过程通常通过参数返回结果并且不包含语句除非是返回状态码输入参数输出参数调用存储过程从另一个过程或脚本中调用从嵌入式中调用优势与存储函数和存储过程在创建时被编译和优化生成执行计划并存储在数据库的系统目录中如图所示在中位于可编程性下的函数和存储过程节点应用程序只需调用其名称无需再次进行语法分析和优化因此具有以下优点性能提升减少重复编译开销减少网络流量将复杂运算放在服务器端只传递参数和结果代码重用与封装业务逻辑集中存储在数据库多个应用可共享确保一致性便于维护增强安全性可以通过授权控制用户对过程和函数的执行权限而不直接暴露底层表触发器触发器概述定义触发器是存储在数据库中的一种特殊类型的存储过程它自动执行以作为对数据库中特定表进行数据修改的副作用本质一种基于事件条件动作模型的完整性维护和业务规则执行机制事件什么操作增删改会触发它条件可选触发后在什么条件下才执行动作动作当事件发生且条件满足时要执行的语句补救措施或额外操作历史触发器概念在标准中正式引入但很多数据库厂商在此前就已通过非标准语法提供了支持注意不同的触发器语法细节尤其是引用新旧行语句级触发可能存在差异触发事件与动作触发事件可以是或更新触发器的粒度对于触发器可以限定只在特定列被更新时才触发只在列被更新时触发引用新旧行值用于在和触发器中引用修改前的旧行数据用于在和触发器中引用修改后的新行数据对于旧行不存在对于新行不存在触发时机或触发器在约束检查之前操作实际修改数据之前执行常用于数据清洗转换或执行额外约束触发器在操作已成功执行约束检查通过之后执行常用于审计维护衍生数据或执行级联操作行级触发器示例详解触发器示例数据清洗触发条件新成绩为空字符串动作在插入前将其设为逻辑当更新表的列时如果新值是空字符串则在数据真正写入表之前将其更改为关键因为是或操作所以可以引用触发器有能力修改即将被写入的的值触发器示例维护复杂的参照完整性假设我们有不使用外键约束或用触发器实现比外键更复杂规则的需求示例插入时检查是否存在动作回滚整个插入事务场景试图插入一条记录其为节但表中并无此时间段定义动作会撤销导致触发器激活的整个事务阻止非法数据进入示例删除时确保不被引用条件被删除的是表中该的最后一条记录条件并且该仍在表中被引用场景删除表中关于节的最后一条记录但表中仍有课程安排使用节逻辑子句中的条件确保只在删除某个的最后一个实例且该仍被参照时才触发回滚这比简单的外键更精细触发器示例自动维护派生属性冗余数据场景学生一门课的成绩从不及格或空更新为及格非且非空条件子句精确捕捉了这种状态转变动作根据找到课程学分累加到对应学生的总学分中这是一个典型的用触发器维护数据一致性的例子语句级触发器行级触发器对受影响的每一行都执行一次动作如果一条语句更新了行则触发器动作会执行次语句级触发器使用默认整个触发事件一条语句只触发一次动作无论该语句影响了多少行引用过渡表使用或来引用包含所有被影响行的旧值或新值的临时表称为过渡表优点当触发动作不依赖于单行数据或需要对所有受影响行进行聚合操作时语句级触发器效率高得多将本次批量更新的摘要记录到审计表何时应避免使用触发器尽管触发器功能强大但在现代数据库系统中许多传统的触发器应用场景已有更好替代方案维护汇总数据如部门总薪资旧方式在表上设置触发器实时更新表的一个字段现代方式使用物化视图数据库系统自动维护物化视图的更新通常比手动编写的触发器更高效可靠数据库复制旧方式用触发器将变更记录到增量表再由独立进程读取并应用到副本现代方式使用数据库内置的复制技术如基于日志的复制逻辑复制这些功能更健壮对性能影响更小简单的数据验证首选应尽量使用声明式的完整性约束约束更易于声明理解和维护并由优化执行过度复杂的业务逻辑问题将大量核心业务逻辑放入触发器会造成逻辑黑洞使得数据变更行为难以理解和调试也增加了应用与数据库的耦合度建议核心业务逻辑应放在应用层或中间件数据库主要负责数据存储和基础完整性触发器仅用于处理与数据本身紧密相关原子性的规则本章总结与展望本章总结第五章高级系统性地讲解了将与程序设计及数据库内部自动化逻辑相结合的高级技术从编程语言访问掌握了动态和嵌入式两种集成范式理解了连接管理预编译语句事务控制元数据访问等核心编程接口能够构建健壮的数据库应用程序函数与存储过程学会了在数据库服务器端创建可重用的程序单元封装业务逻辑提升性能安全性和代码可维护性触发器深入理解了基于事件条件动作模型的自动化机制能够设计行级和语句级触发器用于实现复杂的完整性约束审计跟踪和衍生数据维护同时也认识到应优先使用声明式约束和现代数据库内置功能谨慎而有选择地使用触发器后续章节展望简要提及本章末尾指出高级的主题还包含其他重要内容将在后续可能展开递归查询用于处理具有层次结构或图结构的数据如组织结构物料清单高级聚合函数超越如用于多维分析以及窗口函数子句用于行间计算流程化函数可能指更复杂的流程控制语句在程序中的应用结束',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-27 15:59:58',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style>
  /* === 只添加半透明磨砂效果，不改变任何布局 === */
  
  /* 1. 导航栏内所有可点击元素添加磨砂背景 */
  #nav a,
  #nav button {
    /* 保持原有布局，只添加背景效果 */
    backdrop-filter: blur(6px) !important;
    -webkit-backdrop-filter: blur(6px) !important;
    transition: backdrop-filter 0.3s ease !important;
  }
  
  /* 2. 浅色模式：白色半透明 */
  body:not([data-theme="dark"]) #nav a,
  body:not([data-theme="dark"]) #nav button {
    background-color: rgba(255, 255, 255, 0.1) !important;
  }
  
  /* 3. 深色模式：黑色半透明 */
  [data-theme="dark"] #nav a,
  [data-theme="dark"] #nav button {
    background-color: rgba(0, 0, 0, 0.1) !important;
  }
  
  /* 4. 悬停效果：稍微增加透明度 */
  #nav a:hover,
  #nav button:hover {
    backdrop-filter: blur(8px) !important;
    -webkit-backdrop-filter: blur(8px) !important;
  }
  
  body:not([data-theme="dark"]) #nav a:hover,
  body:not([data-theme="dark"]) #nav button:hover {
    background-color: rgba(255, 255, 255, 0.15) !important;
  }
  
  [data-theme="dark"] #nav a:hover,
  [data-theme="dark"] #nav button:hover {
    background-color: rgba(0, 0, 0, 0.15) !important;
  }
</style>
<link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 8.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Yuejin's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Platform/" style="font-size: 1.05rem;">AI Platform<sup>1</sup></a><a href="/tags/Database/" style="font-size: 1.05rem;">Database<sup>12</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>1</sup></a><a href="/tags/RNN/" style="font-size: 1.05rem;">RNN<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>6</sup></a><a href="/tags/Self-Attention/" style="font-size: 1.05rem;">Self Attention<sup>1</sup></a><a href="/tags/plan/" style="font-size: 1.05rem;">plan<sup>2</sup></a><a href="/tags/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">关系模型<sup>1</sup></a><a href="/tags/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B/" style="font-size: 1.05rem;">自注意力<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">December 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">20</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url">数据库</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Database/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Database</span></a><a class="article-meta__tags" href="/tags/SQL/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>SQL</span></a></span></div></div><h1 class="post-title" itemprop="name headline">§5 Advanced-SQL课件详解</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-23T17:31:49.070Z" title="发表于 2025-12-24 01:31:49">2025-12-24</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-27T07:59:58.439Z" title="更新于 2025-12-27 15:59:58">2025-12-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/SQL_cover.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/12/24/DB_AdvancedSQL/"><header><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url">数据库</a><a href="/tags/Database/" tabindex="-1" itemprop="url">Database</a><a href="/tags/SQL/" tabindex="-1" itemprop="url">SQL</a><h1 id="CrawlerTitle" itemprop="name headline">§5 Advanced-SQL课件详解</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Yuejin Wu</span><time itemprop="dateCreated datePublished" datetime="2025-12-23T17:31:49.070Z" title="发表于 2025-12-24 01:31:49">2025-12-24</time><time itemprop="dateCreated datePublished" datetime="2025-12-27T07:59:58.439Z" title="更新于 2025-12-27 15:59:58">2025-12-27</time></header><h2 id="章节标题与大纲">章节标题与大纲</h2>
<h3 id="第五章：高级SQL">第五章：高级SQL</h3>
<p><strong>授课时间</strong>：2025年10月<br>
<strong>授课单位</strong>：计算机学院</p>
<h3 id="本章大纲">本章大纲</h3>
<p>本章旨在深入探讨超越基础SQL操作的高级特性，重点涵盖以下三个核心领域：</p>
<ol>
<li><strong>从编程语言访问SQL</strong>：探讨如何在Java、C等通用编程语言中执行SQL语句，实现应用程序与数据库系统的交互。</li>
<li><strong>函数和存储过程</strong>：学习在数据库服务器端创建可重用的程序化逻辑单元，包括标量函数和存储过程。</li>
<li><strong>触发器</strong>：掌握基于事件-条件-动作模型的数据库自动化响应机制，用于维护数据完整性和执行业务规则。</li>
</ol>
<h2 id="从编程语言访问SQL（概述与架构）">从编程语言访问SQL（概述与架构）</h2>
<h3 id="5-1-从编程语言访问SQL">5.1 从编程语言访问SQL</h3>
<h4 id="5-1-0-数据库应用系统（DBAS）架构回顾">5.1.0 数据库应用系统（DBAS）架构回顾</h4>
<p>数据库应用系统是由<strong>用户</strong>、<strong>应用程序</strong>、**数据库管理系统（DBMS）<strong>和</strong>数据库（DB）<strong>共同构成的完整体系。应用程序作为用户与数据库之间的桥梁，需要通过特定的</strong>应用程序编程接口（API）**与数据库服务器进行交互。这一交互过程通常遵循以下步骤：</p>
<ol>
<li>建立与数据库服务器的连接。</li>
<li>通过连接向服务器发送SQL命令（查询或更新）。</li>
<li>对于查询操作，以一次一个元组的方式，将结果集提取到应用程序的变量中进行后续处理。</li>
</ol>
<h4 id="5-1-1-两种主要的访问范式">5.1.1 两种主要的访问范式</h4>
<p>从编程语言访问SQL主要有两种实现途径，它们在集成方式和执行时机上存在根本区别：</p>
<ol>
<li>
<p><strong>动态SQL</strong></p>
<ul>
<li><strong>定义</strong>：在通用编程语言中，程序在<strong>运行时</strong>动态地构建SQL查询字符串，并通过API函数调用（如JDBC、ODBC）将该字符串提交给数据库服务器执行，然后处理返回的结果。</li>
<li><strong>核心特征</strong>：
<ul>
<li><strong>灵活性高</strong>：SQL语句可以根据程序逻辑和用户输入动态生成。</li>
<li><strong>显式控制</strong>：程序员需手动管理连接、语句执行、结果获取和资源释放的全生命周期。</li>
</ul>
</li>
<li><strong>主流技术标准</strong>：
<ul>
<li><strong>JDBC</strong>：专为Java语言设计的数据库连接API标准。</li>
<li><strong>ODBC</strong>：一种开放的、与语言和数据库无关的调用级接口标准，广泛用于C、C++等语言。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>嵌入式SQL</strong></p>
<ul>
<li><strong>定义</strong>：将SQL语句直接<strong>编写</strong>在宿主语言（如C、COBOL）的源代码中。在编译程序之前，先由一个<strong>预处理器</strong>扫描源代码，将这些嵌入式SQL语句转换为对数据库运行时库的特定函数调用。随后，再由宿主语言的编译器进行编译。</li>
<li><strong>核心特征</strong>：
<ul>
<li><strong>编译时确定</strong>：SQL语句在编译期是可见的，可进行早期语法检查和优化。</li>
<li><strong>编程模型更贴近SQL</strong>：使用游标（Cursor）机制处理多行结果集，语法上更接近直接的SQL交互。</li>
<li><strong>底层依赖动态SQL</strong>：最终生成的函数调用实质上利用了动态SQL的API（如ODBC）来完成数据库通信。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="JDBC详解（基础与核心流程）">JDBC详解（基础与核心流程）</h2>
<h3 id="5-1-2-JDBC（Java-Database-Connectivity）">5.1.2 JDBC（Java Database Connectivity）</h3>
<h4 id="特性与用途">特性与用途</h4>
<p>JDBC是Java平台中用于执行SQL语句的一套标准API。它不仅支持数据的查询与更新，还提供了检索数据库<strong>元数据</strong>的能力，例如查询数据库中有哪些表、表中各列的名称和数据类型等。</p>
<p>JDBC建立了一套标准的通信模型：</p>
<ol>
<li>打开一个数据库连接。</li>
<li>创建一个<code>Statement</code>（语句）对象。</li>
<li>使用该<code>Statement</code>对象发送SQL查询并获取结果。</li>
<li>利用Java的异常处理机制来管理操作中可能出现的错误。</li>
</ol>
<h4 id="JDBC核心代码示例与逐步解析">JDBC核心代码示例与逐步解析</h4>
<p>以下是一个完整的JDBC方法示例，演示了连接数据库、执行插入和查询操作的全过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String userId, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// === 步骤 1：加载数据库驱动程序（JDBC 4.0+ 可省略）===</span></span><br><span class="line">        <span class="comment">// 此步骤告知Java运行时环境所要使用的JDBC驱动实现类。</span></span><br><span class="line">        <span class="comment">// 注意：自JDBC 4.0（Java 6）起，驱动可自动加载，此语句常可省略。</span></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 2：建立数据库连接 ===</span></span><br><span class="line">        <span class="comment">// 使用DriverManager的getConnection方法，传入数据库URL、用户名和密码。</span></span><br><span class="line">        <span class="comment">// URL格式因数据库厂商而异。本例连接一个Oracle数据库。</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, <span class="comment">// 数据库URL</span></span><br><span class="line">            userId, <span class="comment">// 用户名</span></span><br><span class="line">            passwd  <span class="comment">// 密码</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 3：创建语句对象 ===</span></span><br><span class="line">        <span class="comment">// 通过Connection对象创建一个Statement对象，用于执行静态SQL语句。</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4a：执行数据更新操作（INSERT, UPDATE, DELETE）===</span></span><br><span class="line">        <span class="comment">// 使用executeUpdate方法，它返回受影响的行数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.executeUpdate(</span><br><span class="line">                <span class="string">&quot;insert into instructor values(&#x27;77987&#x27;, &#x27;Kim&#x27;, &#x27;Physics&#x27;, 98000)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            <span class="comment">// 捕获并处理可能发生的SQL异常（如主键冲突、违反约束等）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4b：执行数据查询操作 ===</span></span><br><span class="line">        <span class="comment">// 使用executeQuery方法执行SELECT语句，返回一个ResultSet（结果集）对象。</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;select dept_name, avg(salary) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from instructor &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by dept_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 5：遍历并处理结果集 ===</span></span><br><span class="line">        <span class="comment">// ResultSet的next()方法将游标移动到下一行。首次调用移至第一行。</span></span><br><span class="line">        <span class="comment">// 当没有更多行时返回false。</span></span><br><span class="line">        <span class="keyword">while</span> (rset.next()) &#123;</span><br><span class="line">            <span class="comment">// 使用getString(列名)和getFloat(列索引)等方法获取当前行的列值。</span></span><br><span class="line">            <span class="comment">// 列索引从1开始。</span></span><br><span class="line">            System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>) + <span class="string">&quot; &quot;</span> + rset.getFloat(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 6：清理资源（至关重要！）===</span></span><br><span class="line">        <span class="comment">// 必须按顺序关闭ResultSet、Statement和Connection，以释放数据库和系统资源。</span></span><br><span class="line">        <span class="comment">// 实际开发中应使用try-with-resources语句确保资源被关闭。</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDBC Driver not found: &quot;</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        <span class="comment">// 捕获连接、语句创建等过程中更广泛的SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 捕获其他非SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Exception : &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关键点解析">关键点解析</h4>
<ol>
<li><strong><code>Class.forName()</code></strong>：此语句显式加载特定的JDBC驱动类。这是JDBC 3.0及之前版本的规范做法。在JDBC 4.0及以上版本（Java 6+），只要驱动JAR包在类路径中，驱动管理器可以自动发现并加载驱动，因此这行代码常可省略。</li>
<li><strong><code>DriverManager.getConnection()</code></strong>：这是建立连接的工厂方法。数据库URL的格式是驱动特定的。<code>jdbc:oracle:thin:@db.yale.edu:1521:univdb</code> 表示使用Oracle的“thin”驱动，连接主机<code>db.yale.edu</code>上端口1521的服务<code>univdb</code>。</li>
<li><strong><code>Statement.executeUpdate()</code> vs <code>executeQuery()</code></strong>：
<ul>
<li><code>executeUpdate()</code>：用于执行会修改数据库内容的SQL语句（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code>等），返回一个整数，表示受影响的行数。</li>
<li><code>executeQuery()</code>：专门用于执行<code>SELECT</code>语句，返回一个<code>ResultSet</code>对象。</li>
</ul>
</li>
<li><strong><code>ResultSet</code>处理</strong>：
<ul>
<li>结果集初始时游标位于第一行<strong>之前</strong>。</li>
<li><code>next()</code>方法将游标向前移动一行，并返回一个布尔值，指示新行是否有效。</li>
<li>可以使用列名（字符串）或列索引（从1开始）来获取列值。<code>getString(1)</code>和<code>getString(“dept_name”)</code>是等价的（假设<code>dept_name</code>是<code>SELECT</code>子句中的第一个元素）。</li>
</ul>
</li>
<li><strong>异常处理</strong>：几乎所有JDBC操作都可能抛出<code>SQLException</code>，必须妥善处理。通常使用<code>try-catch</code>块来捕获，并至少记录错误信息。</li>
<li><strong>资源管理</strong>：<code>Connection</code>、<code>Statement</code>和<code>ResultSet</code>都是持有昂贵底层资源（如数据库连接、服务器游标）的对象。<strong>必须</strong>在使用完毕后显式调用<code>close()</code>方法将其关闭，以防止资源泄漏。推荐使用Java 7引入的<code>try-with-resources</code>语法实现自动关闭。</li>
</ol>
<h4 id="处理空值（Null-Values）">处理空值（Null Values）</h4>
<p>从<code>ResultSet</code>中读取数据时，如果某列的值为SQL <code>NULL</code>，则<code>getXXX()</code>方法会返回对应Java类型的默认值（如0、<code>false</code>、<code>null</code>）。为了准确区分数据库中的<code>NULL</code>和默认值，可以使用<code>ResultSet.wasNull()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Got null value for column &#x27;a&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JDBC高级特性（预编译语句、元数据、事务控制）">JDBC高级特性（预编译语句、元数据、事务控制）</h2>
<h3 id="5-1-2-1-预编译语句（PreparedStatement）">5.1.2.1 预编译语句（PreparedStatement）</h3>
<p>预编译语句是<code>Statement</code>接口的一个更强大、更安全、通常也更高效的子接口。</p>
<ul>
<li>
<p><strong>工作原理</strong>：SQL语句在创建<code>PreparedStatement</code>对象时即被发送到数据库进行<strong>预编译</strong>。语句中的变量部分用占位符<code>?</code>表示。之后，每次执行只需为这些<code>?</code>传入具体的参数值即可。</p>
</li>
<li>
<p><strong>优势</strong>：</p>
<ol>
<li><strong>性能</strong>：对于需要重复执行多次（仅参数不同）的SQL语句，数据库只需编译一次，后续执行直接使用编译好的执行计划，效率显著提升。</li>
<li><strong>安全</strong>：有效防止<strong>SQL注入攻击</strong>。因为参数值是通过<code>setXXX()</code>方法传递的，而不是拼接到SQL字符串中，数据库会将其视为纯粹的数据，而非可执行代码的一部分。</li>
<li><strong>可读性与维护性</strong>：将SQL逻辑与参数值分离，代码更清晰。</li>
</ol>
</li>
<li>
<p><strong>创建与使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建PreparedStatement，使用?作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into instructor values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置参数值。索引从1开始。</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);      <span class="comment">// 设置第一个?为ID</span></span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);      <span class="comment">// 设置第二个?为name</span></span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);    <span class="comment">// 设置第三个?为dept_name</span></span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);          <span class="comment">// 设置第四个?为salary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行更新。注意：这里没有SQL字符串参数。</span></span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 重用同一个PreparedStatement插入另一条记录，只需重新设置变化的参数</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>); <span class="comment">// 仅修改ID</span></span><br><span class="line">pStmt.executeUpdate();       <span class="comment">// 再次执行</span></span><br></pre></td></tr></table></figure>
<p><strong>关键说明</strong>：前四个<code>setXXX</code>语句仅仅是为<code>INSERT</code>语句的参数赋值，并没有触发数据库的插入操作。真正的插入是在调用<code>executeUpdate()</code>时执行的。这允许在批量操作中高效地复用同一个<code>PreparedStatement</code>对象。</p>
</li>
</ul>
<h3 id="5-1-2-2-元数据特性（Metadata）">5.1.2.2 元数据特性（Metadata）</h3>
<p>元数据是“关于数据的数据”。JDBC提供了访问两类元数据的接口：</p>
<ol>
<li>
<p><strong>结果集元数据（<code>ResultSetMetaData</code>）</strong>：获取关于特定查询结果的结构信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM department&quot;</span>);</span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Column &quot;</span> + i + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;  Name: &quot;</span> + rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Type: &quot;</span> + rsmd.getColumnTypeName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Display Size: &quot;</span> + rsmd.getColumnDisplaySize(i));</span><br><span class="line">    <span class="comment">// 还有其他方法，如isNullable, isAutoIncrement等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用途</strong>：动态处理未知结构的查询结果，常用于通用查询工具或报表生成器。</p>
</li>
<li>
<p><strong>数据库元数据（<code>DatabaseMetaData</code>）</strong>：获取关于整个数据库的目录信息，如所有表、列、主键、外键等。</p>
<ul>
<li><strong>获取表的所有列</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getColumns参数: 目录, 模式, 表名模式, 列名模式</span></span><br><span class="line"><span class="comment">// null 表示“所有目录”， &quot;%&quot; 表示“所有”（类似于SQL的LIKE）</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">columns</span> <span class="operator">=</span> dbmd.getColumns(<span class="literal">null</span>, <span class="string">&quot;univdb&quot;</span>, <span class="string">&quot;department&quot;</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (columns.next()) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">        columns.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">        columns.getString(<span class="string">&quot;TYPE_NAME&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>获取表的主键信息</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getPrimaryKeys参数: 目录, 模式, 表名</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">pks</span> <span class="operator">=</span> dmd.getPrimaryKeys(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;department&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pks.next()) &#123;</span><br><span class="line">    <span class="comment">// KEY_SEQ表示该列在主键中的顺序（针对复合主键）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;PK Sequence: &quot;</span> + pks.getString(<span class="string">&quot;KEY_SEQ&quot;</span>) +</span><br><span class="line">                       <span class="string">&quot;, Column: &quot;</span> + pks.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="5-1-2-3-事务控制（Transaction-Control）">5.1.2.3 事务控制（Transaction Control）</h3>
<p>默认情况下，JDBC连接处于<strong>自动提交模式</strong>：每条SQL语句都被视为一个独立的事务，并在执行后立即自动提交。</p>
<ul>
<li><strong>问题</strong>：对于包含多个更新操作的逻辑单元（如银行转账），自动提交会导致原子性无法保证。如果中间某条语句失败，之前已提交的更改无法自动撤销。</li>
<li><strong>解决方案</strong>：手动管理事务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关闭自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行一系列更新操作</span></span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE id = &#x27;A&#x27;&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance + 100 WHERE id = &#x27;B&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果全部成功，手动提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 4. 如果发生任何异常，回滚事务，撤销所有未提交的更改</span></span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            <span class="comment">// 处理回滚异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理原异常e</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 5. 恢复自动提交模式（可选，但建议）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-1-2-4-调用函数和存储过程">5.1.2.4 调用函数和存储过程</h3>
<p>使用<code>CallableStatement</code>接口调用数据库中的存储函数和存储过程。</p>
<ul>
<li><strong>调用函数</strong>（有返回值）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;? = call function_name(?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt1</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;? = call get_dept_count(?)&#125;&quot;</span>);</span><br><span class="line">cStmt1.registerOutParameter(<span class="number">1</span>, Types.INTEGER); <span class="comment">// 注册第一个?为输出参数（返回值）</span></span><br><span class="line">cStmt1.setString(<span class="number">2</span>, <span class="string">&quot;Comp. Sci.&quot;</span>); <span class="comment">// 设置第二个?为输入参数</span></span><br><span class="line">cStmt1.execute();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cStmt1.getInt(<span class="number">1</span>); <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure>
</li>
<li><strong>调用过程</strong>（无返回值或通过OUT参数返回）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;call procedure_name(?, ?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt2</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;call adjust_salary(?, ?)&#125;&quot;</span>);</span><br><span class="line">cStmt2.setString(<span class="number">1</span>, <span class="string">&quot;10101&quot;</span>);</span><br><span class="line">cStmt2.setInt(<span class="number">2</span>, <span class="number">5000</span>);</span><br><span class="line">cStmt2.execute();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="ODBC详解">ODBC详解</h2>
<h3 id="5-1-3-ODBC（Open-Database-Connectivity）">5.1.3 ODBC（Open Database Connectivity）</h3>
<p>ODBC是一个由微软主导制定的开放数据库互连标准，它提供了一个与编程语言和数据库管理系统均无关的调用级API。</p>
<h4 id="架构">架构</h4>
<p>ODBC采用分层驱动架构：</p>
<ol>
<li><strong>应用程序</strong>：调用标准的ODBC API函数。</li>
<li><strong>ODBC驱动程序管理器</strong>：作为应用程序的入口点，负责加载、卸载驱动程序，并将应用程序的ODBC调用分派给正确的驱动程序。</li>
<li><strong>ODBC驱动程序</strong>：由各个数据库厂商提供，负责将标准的ODBC函数调用转换为特定数据库的网络协议或本地API调用（如调用Oracle的OCI库、SQL Server的TDS协议等）。</li>
<li><strong>数据源</strong>：通过ODBC管理器配置的、指向特定数据库服务器的连接定义（DSN，Data Source Name）。</li>
</ol>
<h4 id="ODBC-C语言编程示例与逐步解析">ODBC C语言编程示例与逐步解析</h4>
<p>以下C程序片段展示了使用ODBC API连接数据库、执行查询并获取结果的完整流程，包含详细的步骤注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// === 步骤 0：声明变量 ===</span></span><br><span class="line">    RETCODE error;           <span class="comment">// 用于接收每个ODBC API调用的返回码（SQL_SUCCESS, SQL_ERROR等）</span></span><br><span class="line">    HENV env;                <span class="comment">// 环境句柄，代表ODBC的上下文环境</span></span><br><span class="line">    HDBC conn;               <span class="comment">// 连接句柄，代表一个数据库连接</span></span><br><span class="line">    HSTMT stmt;              <span class="comment">// 语句句柄，代表一个SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 1：分配环境句柄 ===</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 2：分配连接句柄 ===</span></span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 3：建立连接 ===</span></span><br><span class="line">    <span class="comment">// SQLConnect参数：连接句柄，服务器名，用户名，密码。</span></span><br><span class="line">    <span class="comment">// SQL_NTS 表示前一个参数是以空字符结尾的字符串。</span></span><br><span class="line">    SQLConnect(conn,</span><br><span class="line">               <span class="string">&quot;db.yale.edu&quot;</span>, SQL_NTS,  <span class="comment">// 服务器</span></span><br><span class="line">               <span class="string">&quot;avi&quot;</span>, SQL_NTS,          <span class="comment">// 用户名</span></span><br><span class="line">               <span class="string">&quot;avipasswd&quot;</span>, SQL_NTS);   <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 4：分配语句句柄 ===</span></span><br><span class="line">    SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 5：准备并执行SQL语句 ===</span></span><br><span class="line">    <span class="type">char</span> *sqlquery = <span class="string">&quot;select dept_name, sum(salary) from instructor group by dept_name&quot;</span>;</span><br><span class="line">    <span class="comment">// SQLExecDirect直接执行一个SQL字符串。</span></span><br><span class="line">    error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// === 步骤 6：将结果列绑定到C程序变量 ===</span></span><br><span class="line">        <span class="type">char</span> deptname[<span class="number">80</span>];     <span class="comment">// 用于接收dept_name的缓冲区</span></span><br><span class="line">        <span class="type">float</span> salary;          <span class="comment">// 用于接收sum(salary)的变量</span></span><br><span class="line">        SQLINTEGER lenOut1, lenOut2; <span class="comment">// 用于接收字符串实际长度（可为NULL指示符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQLBindCol将结果集的列与程序变量关联。</span></span><br><span class="line">        <span class="comment">// 参数：语句句柄，列号（从1开始），C变量类型，变量地址，缓冲区长度，长度/指示符缓冲区地址。</span></span><br><span class="line">        SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="keyword">sizeof</span>(deptname), &amp;lenOut1);</span><br><span class="line">        SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2); <span class="comment">// 长度0用于非字符串类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 7：循环获取每一行结果 ===</span></span><br><span class="line">        <span class="comment">// SQLFetch将游标移动到下一行，并将已绑定的列数据提取到对应的C变量中。</span></span><br><span class="line">        <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 检查指示符，判断数据是否为NULL。如果lenOut1 == SQL_NULL_DATA，则deptname无效。</span></span><br><span class="line">            <span class="keyword">if</span> (lenOut1 != SQL_NULL_DATA) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Department: %s, Total Salary: %g\n&quot;</span>, deptname, salary);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误：可以使用SQLError函数获取详细的错误信息。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query execution failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 8：清理资源（逆序释放）===</span></span><br><span class="line">    SQLFreeStmt(stmt, SQL_DROP);   <span class="comment">// 释放语句句柄</span></span><br><span class="line">    SQLDisconnect(conn);          <span class="comment">// 断开连接</span></span><br><span class="line">    SQLFreeConnect(conn);         <span class="comment">// 释放连接句柄</span></span><br><span class="line">    SQLFreeEnv(env);              <span class="comment">// 释放环境句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="关于连接时长的重要说明">关于连接时长的重要说明</h4>
<p>在实际生产环境中，数据库服务器或网络设备通常会对客户端连接设置<strong>超时限制</strong>（例如，非活动连接60秒后自动断开）。如果应用程序执行一个非常耗时的SQL查询，其执行时间超过了连接的超时设置，那么该查询可能会被服务器强行终止，导致操作失败。</p>
<ul>
<li><strong>注意事项</strong>：使用默认连接设置时，必须确保任何单个数据库操作都不会超过系统的默认连接超时时长。</li>
<li><strong>解决方案</strong>：ODBC API（如<code>SQLSetConnectAttr</code>）或连接字符串参数通常允许应用程序<strong>调整连接超时或查询超时设置</strong>。在开发需要执行长时间操作的应用程序时，必须合理配置这些超时参数，以保证操作的顺利完成。</li>
</ul>
<h2 id="嵌入式SQL详解">嵌入式SQL详解</h2>
<h3 id="5-1-4-嵌入式SQL">5.1.4 嵌入式SQL</h3>
<h4 id="SQL的使用方式分类">SQL的使用方式分类</h4>
<ol>
<li><strong>交互式SQL</strong>：用户通过数据库系统提供的命令行界面或图形工具直接输入并执行SQL语句，主要用于数据定义（DDL）和即席查询（DML）。</li>
<li><strong>动态SQL</strong>：如前所述的JDBC/ODBC，在程序运行时动态构建和执行SQL字符串。</li>
<li><strong>嵌入式SQL</strong>：将SQL语句<strong>直接嵌入</strong>到C、COBOL、Fortran等宿主语言的源代码中，在程序<strong>编译前</strong>通过预处理器进行转换。</li>
</ol>
<h4 id="基本概念">基本概念</h4>
<ul>
<li><strong>宿主语言</strong>：嵌入SQL语句的通用编程语言（如C）。</li>
<li><strong>预处理器</strong>：一个专门的工具，它扫描包含嵌入式SQL的源代码文件，识别出所有SQL语句，将它们转换为对数据库运行时库（通常基于ODBC或类似接口）的函数调用，并生成一个纯宿主语言的中间文件供编译器编译。</li>
<li><strong>优点</strong>：结合了SQL强大的数据操作能力和宿主语言的计算、流程控制及输入/输出能力，适用于编写复杂的数据处理应用程序。</li>
</ul>
<h4 id="语法要素与示例">语法要素与示例</h4>
<ul>
<li><strong>语句标识</strong>：所有嵌入式SQL语句都以<code>EXEC SQL</code>开头，以宿主语言特定的结束符结尾（C语言中常用分号<code>;</code>，COBOL中用<code>END-EXEC</code>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>连接数据库</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO server USER user_name USING password;</span><br></pre></td></tr></table></figure>
</li>
<li><strong>共享变量（宿主变量）</strong>：
<ul>
<li>宿主语言的变量可以在嵌入式SQL语句中使用，以<strong>冒号（<code>:</code>）</strong> 作为前缀，以便与SQL自身的列名区分。</li>
<li>这些共享变量必须在专门的<code>DECLARE SECTION</code>中声明。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;  <span class="comment">// 宿主变量</span></span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>];         <span class="comment">// 用于接收ID</span></span><br><span class="line">    <span class="type">char</span> sn[<span class="number">20</span>];        <span class="comment">// 用于接收name</span></span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 从用户输入或其他地方为credit_amount赋值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL SELECT ID, name INTO :si, :sn</span><br><span class="line">         FROM student</span><br><span class="line">         WHERE tot_cred &gt; :credit_amount; <span class="comment">// 在WHERE子句中使用宿主变量</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="游标（Cursor）：处理多行结果集的关键机制">游标（Cursor）：处理多行结果集的关键机制</h4>
<p>当嵌入式SQL查询可能返回多行结果时，无法直接用<code>INTO</code>子句将多行赋值给有限的宿主变量。此时必须使用<strong>游标</strong>。</p>
<ol>
<li>
<p><strong>声明游标</strong>：将游标与一个查询关联。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE tot_cred &gt; :credit_amount;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>打开游标</strong>：执行游标关联的查询。此时，DBMS会准备结果集（可能物化到一个临时区域），游标定位在结果集第一行<strong>之前</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN c;</span><br></pre></td></tr></table></figure>
<p><strong>重要</strong>：打开游标时，查询中引用的宿主变量（如<code>:credit_amount</code>）的值被“定格”使用。后续修改该宿主变量不会影响已打开的游标结果。</p>
</li>
<li>
<p><strong>提取数据</strong>：将游标向前推进一行，并将该行数据提取到指定的宿主变量中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line"><span class="comment">// 每次FETCH后，需要检查SQL通信区（SQLCA）中的返回码，判断是否成功提取到数据或已到达结果集末尾。</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>关闭游标</strong>：释放与游标相关的数据库资源（如临时存储空间、锁等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>完整游标使用循环示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;</span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>], sn[<span class="number">20</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 获取credit_amount的值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name FROM student WHERE tot_cred &gt; :credit_amount;</span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c;</span><br><span class="line"><span class="comment">// 使用SQLCODE（SQLCA中的一个变量）检查状态。0表示成功，100表示无更多数据。</span></span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Student: %s, Name: %s\n&quot;</span>, si, sn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure>
<h4 id="通过游标进行定位更新或删除">通过游标进行定位更新或删除</h4>
<p>游标不仅可以读取数据，还可以用于更新或删除“当前”行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个用于更新的游标，必须使用FOR UPDATE子句</span></span><br><span class="line">EXEC SQL DECLARE c_upd CURSOR FOR</span><br><span class="line">    SELECT * FROM instructor WHERE dept_name = <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">    FOR UPDATE OF salary; <span class="comment">// 指定可更新的列</span></span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c_upd;</span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c_upd INTO ...; <span class="comment">// 将整行数据提取到对应的宿主变量</span></span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新当前游标指向的行</span></span><br><span class="line">        EXEC SQL UPDATE instructor</span><br><span class="line">                 SET salary = salary + <span class="number">1000</span></span><br><span class="line">                 WHERE CURRENT OF c_upd; <span class="comment">// 关键：定位更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c_upd;</span><br></pre></td></tr></table></figure>
<h2 id="SQL函数与存储过程">SQL函数与存储过程</h2>
<h3 id="5-2-函数与存储过程">5.2 函数与存储过程</h3>
<p>SQL允许在数据库服务器端创建命名的、可重用的程序化模块：<strong>函数</strong>和<strong>存储过程</strong>。它们可以用SQL语言自身编写，也可以用外部编程语言（如C、Java）编写。</p>
<ul>
<li><strong>外部语言函数/过程</strong>：适用于处理复杂计算或特定数据类型（如图像、几何对象）。例如，用C编写一个函数来判断两个多边形是否重叠。</li>
<li><strong>表值函数</strong>：一种特殊函数，可以返回一个关系（表）作为结果。</li>
<li><strong>SQL的编程扩展</strong>：SQL-99标准引入了丰富的程序化构造，如变量声明、条件语句（IF-THEN-ELSE）、循环（LOOP, WHILE）和赋值，使得用纯SQL编写复杂逻辑成为可能。</li>
</ul>
<h4 id="5-2-1-SQL标量函数示例">5.2.1 SQL标量函数示例</h4>
<p>创建一个返回指定部门教师人数的函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_count(dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>; <span class="comment">-- 声明局部变量</span></span><br><span class="line">    <span class="comment">-- 将查询结果赋值给局部变量</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count.dept_name;</span><br><span class="line">    <span class="keyword">RETURN</span> d_count; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用函数</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在查询中像内置函数一样调用</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, budget</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-SQL存储过程示例">5.2.2 SQL存储过程示例</h4>
<p>将上述功能改写为存储过程。存储过程通常通过<code>OUT</code>参数返回结果，并且不包含<code>RETURN</code>语句（除非是返回状态码）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">IN</span> dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>), <span class="comment">-- 输入参数</span></span><br><span class="line">    <span class="keyword">OUT</span> d_count <span class="type">INTEGER</span>       <span class="comment">-- 输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<p><strong>调用存储过程</strong>：</p>
<ul>
<li>从另一个SQL过程或脚本中调用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">CALL</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>, d_count);</span><br></pre></td></tr></table></figure>
</li>
<li>从嵌入式SQL中调用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    integer d_count;</span><br><span class="line">    <span class="type">char</span> dept_name[] = <span class="string">&quot;Physics&quot;</span>;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line">EXEC SQL CALL <span class="title function_">dept_count_proc</span><span class="params">(:dept_name, :d_count)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-2-3-优势与存储">5.2.3 优势与存储</h4>
<p>函数和存储过程在创建时被<strong>编译和优化</strong>，生成执行计划并存储在数据库的系统目录中（如图所示，在SQL Server中位于“可编程性”下的“函数”和“存储过程”节点）。应用程序只需调用其名称，无需再次进行语法分析和优化，因此具有以下优点：</p>
<ul>
<li><strong>性能提升</strong>：减少重复编译开销。</li>
<li><strong>减少网络流量</strong>：将复杂运算放在服务器端，只传递参数和结果。</li>
<li><strong>代码重用与封装</strong>：业务逻辑集中存储在数据库，多个应用可共享，确保一致性，便于维护。</li>
<li><strong>增强安全性</strong>：可以通过授权控制用户对过程和函数的执行权限，而不直接暴露底层表。</li>
</ul>
<h2 id="触发器">触发器</h2>
<h3 id="5-3-触发器">5.3 触发器</h3>
<h4 id="5-3-1-概述">5.3.1 概述</h4>
<ul>
<li><strong>定义</strong>：触发器是存储在数据库中的一种特殊类型的存储过程，它<strong>自动执行</strong>，以作为对数据库中特定表进行数据修改（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的“副作用”。</li>
<li><strong>本质</strong>：一种基于<strong>事件-条件-动作</strong>模型的完整性维护和业务规则执行机制。
<ul>
<li><strong>事件</strong>：什么操作（增、删、改）会触发它。</li>
<li><strong>条件</strong>：（可选）触发后，在什么条件下才执行动作。</li>
<li><strong>动作</strong>：当事件发生且条件满足时要执行的SQL语句（补救措施或额外操作）。</li>
</ul>
</li>
<li><strong>历史</strong>：触发器概念在SQL-99标准中正式引入，但很多数据库厂商在此前就已通过非标准语法提供了支持。<strong>注意</strong>：不同DBMS的触发器语法细节（尤其是引用新旧行、语句级触发）可能存在差异。</li>
</ul>
<h4 id="5-3-2-触发事件与动作">5.3.2 触发事件与动作</h4>
<ul>
<li><strong>触发事件</strong>：可以是<code>INSERT</code>、<code>DELETE</code>或<code>UPDATE</code>。</li>
<li><strong>更新触发器的粒度</strong>：对于<code>UPDATE</code>触发器，可以限定只在特定列被更新时才触发。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes <span class="comment">-- 只在grade列被更新时触发</span></span><br></pre></td></tr></table></figure>
</li>
<li><strong>引用新旧行值</strong>：
<ul>
<li><code>REFERENCING OLD ROW AS</code>：用于在<code>DELETE</code>和<code>UPDATE</code>触发器中引用<strong>修改前</strong>的旧行数据。</li>
<li><code>REFERENCING NEW ROW AS</code>：用于在<code>INSERT</code>和<code>UPDATE</code>触发器中引用<strong>修改后</strong>的新行数据（对于<code>INSERT</code>，旧行不存在；对于<code>DELETE</code>，新行不存在）。</li>
</ul>
</li>
<li><strong>触发时机</strong>：<code>BEFORE</code>或<code>AFTER</code>。
<ul>
<li><code>BEFORE</code>触发器：在约束检查<strong>之前</strong>、操作实际修改数据<strong>之前</strong>执行。常用于数据清洗、转换或执行额外约束。</li>
<li><code>AFTER</code>触发器：在操作已成功执行、约束检查通过<strong>之后</strong>执行。常用于审计、维护衍生数据或执行级联操作。</li>
</ul>
</li>
</ul>
<h4 id="5-3-3-行级触发器示例详解">5.3.3 行级触发器示例详解</h4>
<ol>
<li>
<p><strong><code>BEFORE</code>触发器示例：数据清洗</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> setnull_trigger BEFORE <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>) <span class="comment">-- 触发条件：新成绩为空字符串</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">SET</span> nrow.grade <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 动作：在插入前将其设为NULL</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>逻辑</strong>：当更新<code>takes</code>表的<code>grade</code>列时，如果新值是空字符串，则在数据真正写入表之前，将其更改为<code>NULL</code>。</li>
<li><strong>关键</strong>：因为是<code>INSERT</code>或<code>UPDATE</code>操作，所以可以引用<code>NEW ROW</code>。<code>BEFORE</code>触发器有能力修改即将被写入的<code>NEW ROW</code>的值。</li>
</ul>
</li>
<li>
<p><strong><code>AFTER</code>触发器示例：维护复杂的参照完整性</strong><br>
假设我们有不使用外键约束，或用触发器实现比外键更复杂规则的需求。</p>
<ul>
<li>
<p><strong>示例1：插入<code>section</code>时检查<code>time_slot_id</code>是否存在</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>; <span class="comment">-- 动作：回滚整个插入事务</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>场景</strong>：试图插入一条<code>section</code>记录，其<code>time_slot_id</code>为‘3-5节’，但<code>timeslot</code>表中并无此时间段定义。</li>
<li><strong>动作</strong>：<code>ROLLBACK</code>会撤销导致触发器激活的整个<code>INSERT</code>事务，阻止非法数据进入。</li>
</ul>
</li>
<li>
<p><strong>示例2：删除<code>timeslot</code>时，确保不被<code>section</code>引用</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> timeslot</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (</span><br><span class="line">    <span class="comment">-- 条件1：被删除的time_slot_id是表中该ID的最后一条记录</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot)</span><br><span class="line">    <span class="keyword">AND</span></span><br><span class="line">    <span class="comment">-- 条件2：并且该ID仍在section表中被引用</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> section)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>场景</strong>：删除<code>timeslot</code>表中关于‘1-2节’的最后一条记录，但<code>section</code>表中仍有课程安排使用‘1-2节’。</li>
<li><strong>逻辑</strong>：<code>WHEN</code>子句中的条件确保只在删除某个<code>time_slot_id</code>的<strong>最后一个</strong>实例，且该ID仍被参照时，才触发回滚。这比简单的外键<code>ON DELETE RESTRICT</code>更精细。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong><code>AFTER</code>触发器示例：自动维护派生属性（冗余数据）</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">      <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> credits</span><br><span class="line">        <span class="keyword">FROM</span> course</span><br><span class="line">        <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> student.ID <span class="operator">=</span> nrow.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>场景</strong>：学生一门课的成绩从不及格(‘F’)或空，更新为及格（非‘F’且非空）。</li>
<li><strong>条件</strong>：<code>WHEN</code>子句精确捕捉了这种“状态转变”。</li>
<li><strong>动作</strong>：根据<code>nrow.course_id</code>找到课程学分，累加到对应学生(<code>nrow.ID</code>)的总学分<code>tot_cred</code>中。这是一个典型的用触发器维护数据一致性的例子。</li>
</ul>
</li>
</ol>
<h4 id="5-3-4-语句级触发器">5.3.4 语句级触发器</h4>
<p>行级触发器（<code>FOR EACH ROW</code>）对受影响的每一行都执行一次动作。如果一条语句更新了1000行，则触发器动作会执行1000次。</p>
<ul>
<li><strong>语句级触发器</strong>：使用<code>FOR EACH STATEMENT</code>（默认），整个触发事件（一条SQL语句）只触发一次动作，无论该语句影响了多少行。</li>
<li><strong>引用过渡表</strong>：使用<code>REFERENCING OLD TABLE AS</code> 或 <code>REFERENCING NEW TABLE AS</code> 来引用包含所有被影响行的旧值或新值的<strong>临时表</strong>（称为过渡表）。</li>
<li><strong>优点</strong>：当触发动作不依赖于单行数据，或需要对所有受影响行进行聚合操作时，语句级触发器<strong>效率高得多</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> log_salary_update AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> instructor</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> old_vals</span><br><span class="line">            <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> new_vals</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="comment">-- 将本次批量更新的摘要记录到审计表</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> salary_audit(update_time, avg_increase)</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="built_in">AVG</span>(new_vals.salary <span class="operator">-</span> old_vals.salary)</span><br><span class="line">    <span class="keyword">FROM</span> old_vals, new_vals</span><br><span class="line">    <span class="keyword">WHERE</span> old_vals.ID <span class="operator">=</span> new_vals.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-3-5-何时应避免使用触发器">5.3.5 何时应避免使用触发器</h4>
<p>尽管触发器功能强大，但在现代数据库系统中，许多传统的触发器应用场景已有更好替代方案：</p>
<ol>
<li>
<p><strong>维护汇总数据（如部门总薪资）</strong>：</p>
<ul>
<li><strong>旧方式</strong>：在<code>instructor</code>表上设置<code>AFTER INSERT/UPDATE/DELETE</code>触发器，实时更新<code>department</code>表的一个<code>total_salary</code>字段。</li>
<li><strong>现代方式</strong>：使用<strong>物化视图</strong>。数据库系统自动维护物化视图的更新，通常比手动编写的触发器更高效、可靠。</li>
</ul>
</li>
<li>
<p><strong>数据库复制</strong>：</p>
<ul>
<li><strong>旧方式</strong>：用触发器将变更记录到“增量表”（change/delta relations），再由独立进程读取并应用到副本。</li>
<li><strong>现代方式</strong>：使用数据库内置的<strong>复制技术</strong>（如基于日志的复制、逻辑复制）。这些功能更健壮，对性能影响更小。</li>
</ul>
</li>
<li>
<p><strong>简单的数据验证</strong>：</p>
<ul>
<li><strong>首选</strong>：应尽量使用声明式的<strong>完整性约束</strong>（<code>NOT NULL</code>, <code>UNIQUE</code>, <code>CHECK</code>, <code>FOREIGN KEY</code>）。约束更易于声明、理解和维护，并由DBMS优化执行。</li>
</ul>
</li>
<li>
<p><strong>过度复杂的业务逻辑</strong>：</p>
<ul>
<li><strong>问题</strong>：将大量核心业务逻辑放入触发器，会造成“逻辑黑洞”，使得数据变更行为难以理解和调试，也增加了应用与数据库的耦合度。</li>
<li><strong>建议</strong>：核心业务逻辑应放在应用层或中间件，数据库主要负责数据存储和基础完整性。触发器仅用于处理与数据本身紧密相关、原子性的规则。</li>
</ul>
</li>
</ol>
<h2 id="本章总结与展望">本章总结与展望</h2>
<h3 id="本章总结">本章总结</h3>
<p>第五章“高级SQL”系统性地讲解了将SQL与程序设计及数据库内部自动化逻辑相结合的高级技术。</p>
<ol>
<li><strong>从编程语言访问SQL</strong>：掌握了<strong>动态SQL</strong>（JDBC, ODBC）和<strong>嵌入式SQL</strong>两种集成范式。理解了连接管理、预编译语句、事务控制、元数据访问等核心编程接口，能够构建健壮的数据库应用程序。</li>
<li><strong>函数与存储过程</strong>：学会了在数据库服务器端创建可重用的程序单元，封装业务逻辑，提升性能、安全性和代码可维护性。</li>
<li><strong>触发器</strong>：深入理解了基于<strong>事件-条件-动作</strong>模型的自动化机制。能够设计行级和语句级触发器，用于实现复杂的完整性约束、审计跟踪和衍生数据维护。同时，也认识到应优先使用声明式约束和现代数据库内置功能，谨慎而有选择地使用触发器。</li>
</ol>
<h3 id="后续章节展望（简要提及）">后续章节展望（简要提及）</h3>
<p>本章末尾指出，高级SQL的主题还包含其他重要内容，将在后续可能展开：</p>
<ul>
<li><strong>5.4 递归查询</strong>：用于处理具有层次结构或图结构的数据（如组织结构、物料清单BOM）。</li>
<li><strong>5.5 高级聚合函数</strong>：超越<code>SUM</code>、<code>AVG</code>，如<code>ROLLUP</code>、<code>CUBE</code>、<code>GROUPING SETS</code>用于多维分析，以及窗口函数（<code>OVER</code>子句）用于行间计算。</li>
<li><strong>5.6 流程化函数</strong>：可能指更复杂的流程控制语句在SQL程序中的应用。</li>
</ul>
<hr>
<p><strong>结束</strong></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="/img/my_avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="/img/my_avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Yuejin Wu</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/12/24/DB_AdvancedSQL/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/12/24/DB_AdvancedSQL/')">§5 Advanced-SQL课件详解</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/12/24/DB_AdvancedSQL/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=§5 Advanced-SQL课件详解&amp;url=http://example.com/2025/12/24/DB_AdvancedSQL/&amp;pic=/img/SQL_cover.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Yuejin's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>数据库<span class="categoryesPageCount">12</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Database/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Database<span class="tagsPageCount">12</span></a><a class="post-meta__box__tags" href="/tags/SQL/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>SQL<span class="tagsPageCount">6</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/C7_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/"><img class="prev-cover" src="/img/SQL_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高级SQL 简读</div></div></a></div><div class="next-post pull-right"><a href="/2025/12/24/DB_Intermediate%20SQL/"><img class="next-cover" src="/img/SQL_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">§4 Intermediate-SQL 解读</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/12/24/DB_Intermediate%20SQL/" title="§4 Intermediate-SQL 解读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-24</div><div class="title">§4 Intermediate-SQL 解读</div></div></a></div><div><a href="/2025/12/26/DB_E-R%20Model/" title="§6 E-R Model 解读"><img class="cover" src="/img/ER_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-26</div><div class="title">§6 E-R Model 解读</div></div></a></div><div><a href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/" title="§3 Intro-to-SQL 简读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-22</div><div class="title">§3 Intro-to-SQL 简读</div></div></a></div><div><a href="/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/" title="§7 Schema Normalization-Relational Database Design 解读"><img class="cover" src="/img/SN_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-26</div><div class="title">§7 Schema Normalization-Relational Database Design 解读</div></div></a></div><div><a href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/" title="高级SQL 简读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-24</div><div class="title">高级SQL 简读</div></div></a></div><div><a href="/2025/12/27/DB_Indexing/" title="§14 Indexing 解读"><img class="cover" src="/img/C7_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-27</div><div class="title">§14 Indexing 解读</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src="/img/my_avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div class="author-intro" style="line-height: 1.7; text-align: center; font-family: inherit; margin-top: -0.5rem; margin-bottom: 0.5rem;">
  <p style="font-size: 1.15rem; margin-bottom: 0.8rem; font-weight: 500; color: var(--anzhiyu-fontcolor);">你好，我是 <span style="color: #00ffcc; font-weight: 600; text-shadow: 0 0 5px #00ffccaa;">Yuejin Wu</span>！👋</p>
  <p style="font-size: 1.05rem; margin-bottom: 0.6rem; opacity: 0.9; color: var(--anzhiyu-fontcolor);">BUPT 本科生 · 人工智能专业</p>
  <p style="font-size: 1.05rem; margin-bottom: 1rem; opacity: 0.9; color: var(--anzhiyu-fontcolor);">记录学习、思考与生活</p>
  <p style="font-size: 1.1rem; margin-top: 1rem; padding-top: 0.8rem; border-top: 1px solid var(--anzhiyu-theme-op); font-weight: 600; color: #FF0066; text-shadow: 0 0 5px #FF0066, 0 0 5px #FF0066aa;">
   保持好奇，持续探索
  </p>
</div>
</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Yuejin Wu</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YuejinWu/YuejinWu.github.io" target="_blank" title="Github"></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%A0%E8%8A%82%E6%A0%87%E9%A2%98%E4%B8%8E%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.</span> <span class="toc-text">章节标题与大纲</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7SQL"><span class="toc-number">1.1.</span> <span class="toc-text">第五章：高级SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%A4%A7%E7%BA%B2"><span class="toc-number">1.2.</span> <span class="toc-text">本章大纲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AE%BF%E9%97%AESQL%EF%BC%88%E6%A6%82%E8%BF%B0%E4%B8%8E%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">从编程语言访问SQL（概述与架构）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%8E%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E8%AE%BF%E9%97%AESQL"><span class="toc-number">2.1.</span> <span class="toc-text">5.1 从编程语言访问SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%EF%BC%88DBAS%EF%BC%89%E6%9E%B6%E6%9E%84%E5%9B%9E%E9%A1%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">5.1.0 数据库应用系统（DBAS）架构回顾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-%E4%B8%A4%E7%A7%8D%E4%B8%BB%E8%A6%81%E7%9A%84%E8%AE%BF%E9%97%AE%E8%8C%83%E5%BC%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">5.1.1 两种主要的访问范式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">JDBC详解（基础与核心流程）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-JDBC%EF%BC%88Java-Database-Connectivity%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">5.1.2 JDBC（Java Database Connectivity）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7%E4%B8%8E%E7%94%A8%E9%80%94"><span class="toc-number">3.1.1.</span> <span class="toc-text">特性与用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E4%B8%8E%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.2.</span> <span class="toc-text">JDBC核心代码示例与逐步解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E8%A7%A3%E6%9E%90"><span class="toc-number">3.1.3.</span> <span class="toc-text">关键点解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A9%BA%E5%80%BC%EF%BC%88Null-Values%EF%BC%89"><span class="toc-number">3.1.4.</span> <span class="toc-text">处理空值（Null Values）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDBC%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%88%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%E3%80%81%E5%85%83%E6%95%B0%E6%8D%AE%E3%80%81%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">JDBC高级特性（预编译语句、元数据、事务控制）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-1-%E9%A2%84%E7%BC%96%E8%AF%91%E8%AF%AD%E5%8F%A5%EF%BC%88PreparedStatement%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">5.1.2.1 预编译语句（PreparedStatement）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-2-%E5%85%83%E6%95%B0%E6%8D%AE%E7%89%B9%E6%80%A7%EF%BC%88Metadata%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">5.1.2.2 元数据特性（Metadata）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-3-%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6%EF%BC%88Transaction-Control%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">5.1.2.3 事务控制（Transaction Control）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-4-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%92%8C%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">4.4.</span> <span class="toc-text">5.1.2.4 调用函数和存储过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ODBC%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">ODBC详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-ODBC%EF%BC%88Open-Database-Connectivity%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1.3 ODBC（Open Database Connectivity）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">5.1.1.</span> <span class="toc-text">架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ODBC-C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%E4%B8%8E%E9%80%90%E6%AD%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">5.1.2.</span> <span class="toc-text">ODBC C语言编程示例与逐步解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%95%BF%E7%9A%84%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">5.1.3.</span> <span class="toc-text">关于连接时长的重要说明</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">嵌入式SQL详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E5%B5%8C%E5%85%A5%E5%BC%8FSQL"><span class="toc-number">6.1.</span> <span class="toc-text">5.1.4 嵌入式SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">SQL的使用方式分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E8%A6%81%E7%B4%A0%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.3.</span> <span class="toc-text">语法要素与示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%B8%E6%A0%87%EF%BC%88Cursor%EF%BC%89%EF%BC%9A%E5%A4%84%E7%90%86%E5%A4%9A%E8%A1%8C%E7%BB%93%E6%9E%9C%E9%9B%86%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.1.4.</span> <span class="toc-text">游标（Cursor）：处理多行结果集的关键机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%B8%B8%E6%A0%87%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%E6%9B%B4%E6%96%B0%E6%88%96%E5%88%A0%E9%99%A4"><span class="toc-number">6.1.5.</span> <span class="toc-text">通过游标进行定位更新或删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">SQL函数与存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">5.2 函数与存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-SQL%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.1.1.</span> <span class="toc-text">5.2.1 SQL标量函数示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.1.2.</span> <span class="toc-text">5.2.2 SQL存储过程示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%AD%98%E5%82%A8"><span class="toc-number">7.1.3.</span> <span class="toc-text">5.2.3 优势与存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">5.3 触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.1.</span> <span class="toc-text">5.3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E4%B8%8E%E5%8A%A8%E4%BD%9C"><span class="toc-number">8.1.2.</span> <span class="toc-text">5.3.2 触发事件与动作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E8%A1%8C%E7%BA%A7%E8%A7%A6%E5%8F%91%E5%99%A8%E7%A4%BA%E4%BE%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.1.3.</span> <span class="toc-text">5.3.3 行级触发器示例详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E8%AF%AD%E5%8F%A5%E7%BA%A7%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.1.4.</span> <span class="toc-text">5.3.4 语句级触发器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-5-%E4%BD%95%E6%97%B6%E5%BA%94%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.1.5.</span> <span class="toc-text">5.3.5 何时应避免使用触发器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%B1%95%E6%9C%9B"><span class="toc-number">9.</span> <span class="toc-text">本章总结与展望</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93"><span class="toc-number">9.1.</span> <span class="toc-text">本章总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E7%AB%A0%E8%8A%82%E5%B1%95%E6%9C%9B%EF%BC%88%E7%AE%80%E8%A6%81%E6%8F%90%E5%8F%8A%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">后续章节展望（简要提及）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/DB_Transaction/" title="§17 Transaction 解读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="§17 Transaction 解读"/></a><div class="content"><a class="title" href="/2025/12/28/DB_Transaction/" title="§17 Transaction 解读">§17 Transaction 解读</a><time datetime="2025-12-27T17:32:13.329Z" title="发表于 2025-12-28 01:32:13">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/DB_QueryOptim/" title="§16 Query Optimization 解读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="§16 Query Optimization 解读"/></a><div class="content"><a class="title" href="/2025/12/28/DB_QueryOptim/" title="§16 Query Optimization 解读">§16 Query Optimization 解读</a><time datetime="2025-12-27T17:13:55.730Z" title="发表于 2025-12-28 01:13:55">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/28/DB_QueryProcessing/" title="§15 Query Processing 简读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="§15 Query Processing 简读"/></a><div class="content"><a class="title" href="/2025/12/28/DB_QueryProcessing/" title="§15 Query Processing 简读">§15 Query Processing 简读</a><time datetime="2025-12-27T16:13:06.413Z" title="发表于 2025-12-28 00:13:06">2025-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/DB_Indexing/" title="§14 Indexing 解读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="§14 Indexing 解读"/></a><div class="content"><a class="title" href="/2025/12/27/DB_Indexing/" title="§14 Indexing 解读">§14 Indexing 解读</a><time datetime="2025-12-27T13:25:49.244Z" title="发表于 2025-12-27 21:25:49">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/27/DB_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" title="§13 Data Storage Structures 简读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="§13 Data Storage Structures 简读"/></a><div class="content"><a class="title" href="/2025/12/27/DB_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/" title="§13 Data Storage Structures 简读">§13 Data Storage Structures 简读</a><time datetime="2025-12-27T08:01:17.698Z" title="发表于 2025-12-27 16:01:17">2025-12-27</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Yuejin Wu" target="_blank">Yuejin Wu</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/" title="首页">首页</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Platform/" style="font-size: 0.88rem;">AI Platform<sup>1</sup></a><a href="/tags/Database/" style="font-size: 0.88rem;">Database<sup>12</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>1</sup></a><a href="/tags/RNN/" style="font-size: 0.88rem;">RNN<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem;">SQL<sup>6</sup></a><a href="/tags/Self-Attention/" style="font-size: 0.88rem;">Self Attention<sup>1</sup></a><a href="/tags/plan/" style="font-size: 0.88rem;">plan<sup>2</sup></a><a href="/tags/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">关系模型<sup>1</sup></a><a href="/tags/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B/" style="font-size: 0.88rem;">自注意力<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.7.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Yuejin Wu 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>