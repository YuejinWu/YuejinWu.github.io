<!DOCTYPE html><html lang="en &amp;&amp; zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Schema Normalization-Relational Database Design 解读 | Yuejin's Blog</title><meta name="keywords" content="Database,SQL"><meta name="author" content="Yuejin Wu"><meta name="copyright" content="Yuejin Wu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Schema Normalization-Relational Database Design 解读"><meta name="application-name" content="Schema Normalization-Relational Database Design 解读"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Schema Normalization-Relational Database Design 解读"><meta property="og:url" content="http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/index.html"><meta property="og:site_name" content="Yuejin's Blog"><meta property="og:description" content="关系数据库设计 模式规范化数据库设计流程概述独立于DBMS的步骤 应用领域&amp;#x2F;现实世界问题：需求分析。 功能需求规格说明：概念数据库设计。 概念数据库模式：即E-R模式。  依赖于DBMS的步骤 逻辑数据库设计： 初始关系模式生成。 关系模式。 逻辑数据库模式：即关系数据模拟。   物理数据"><meta property="og:locale" content="en &amp;&amp; zh-Hans"><meta property="og:image" content="http://example.com/img/C7_cover.png"><meta property="article:author" content="Yuejin Wu"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/C7_cover.png"><meta name="description" content="关系数据库设计 模式规范化数据库设计流程概述独立于DBMS的步骤 应用领域&amp;#x2F;现实世界问题：需求分析。 功能需求规格说明：概念数据库设计。 概念数据库模式：即E-R模式。  依赖于DBMS的步骤 逻辑数据库设计： 初始关系模式生成。 关系模式。 逻辑数据库模式：即关系数据模拟。   物理数据"><link rel="shortcut icon" href="/img/mylogo.jpg"><link rel="canonical" href="http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2024/07/27/125766904/ba62475f396df9de3316a08ed9e65d86_5680958632268053399..png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: {"enable":true,"ck":null,"LingQueMonitorID":null},
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Yuejin Wu","link":"链接: ","source":"来源: Yuejin's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.2.0/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Yuejin's Blog',
  title: 'Schema Normalization-Relational Database Design 解读',
  postAI: '',
  pageFillDescription: '关系数据库设计 模式规范化, 数据库设计流程概述, 独立于DBMS的步骤, 依赖于DBMS的步骤, 本章大纲, 7.1 良好的关系数据库设计, 困难与挑战, 逻辑设计步骤, 示例：合并模式带来的问题, 问题解决：规范化原则, 7.2 使用函数依赖进行分解, 内容概览, 示例对比, 无损分解定义, 规范化理论, 函数依赖作为约束, 函数依赖概述, 函数依赖定义, 关系实例满足函数依赖, SQL语句判断函数依赖, 示例：判断FD是否被满足, 函数依赖在模式R上成立 vs 函数依赖被r(R)满足, 函数依赖示例建模, 键和函数依赖, 函数依赖在数据库中的完整性约束, 函数依赖的用途, 特殊类型的函数依赖, 1. 平凡函数依赖, 2. 传递依赖, 3. 部分依赖, 4. 函数依赖集F的闭包 F*, 5. 无损分解, 7.3 范式, 范式种类, 规范化原则, 原子域和第一范式, 第二范式, 2NF示例, Boyce-Codd范式, BCNF示例, 将模式分解为BCNF, BCNF与依赖保持, 第三范式, 3NF示例, 3NF中的冗余, BCNF与3NF的比较, 规范化的目标, 范式总结, 7.4 函数依赖理论, 目标, 函数依赖间的逻辑蕴含, 示例, 函数依赖集的闭包, 示例, 属性集的闭包, 属性集闭包算法, 属性集闭包示例, 属性闭包算法的用途, FD集合的等价, 正则覆盖, 无关属性和无关FD, 测试一个属性是否无关, 无关属性示例, 正则覆盖定义与计算, 正则覆盖计算示例, 无损连接分解, 依赖保持, 依赖保持测试算法, 依赖保持示例, 7.5 使用函数依赖的分解算法, 内容概览, 测试关系是否属于BCNF, 测试分解中的关系是否属于BCNF, BCNF分解算法, BCNF分解示例, BCNF分解可能无法保持依赖, 第三范式分解, 测试关系是否属于3NF, 3NF分解算法, 3NF分解示例, BCNF与3NF对比, 附录7-1 计算候选键算法, 定理, 方法, 计算候选键示例, 附录7-2 习题类型, 本章结构总结关系数据库设计模式规范化数据库设计流程概述独立于的步骤应用领域现实世界问题需求分析功能需求规格说明概念数据库设计概念数据库模式即模式依赖于的步骤逻辑数据库设计初始关系模式生成关系模式逻辑数据库模式即关系数据模拟物理数据库设计物理数据库模式关于物理存储结构和访问方法本章大纲良好关系设计的特征函数依赖理论范式使用函数依赖进行分解分解算法良好的关系数据库设计困难与挑战概念设计图转换逻辑设计后得到初始关系模式初始关系模式存在关系模式属性间的数据依赖关系主要是函数依赖直接根据初始关系模式及属性间数据依赖关系构造数据库系统可能导致数据库完整性约束被违反并引起性能下降具体表现为以下问题冗余问题插入问题更新问题删除问题逻辑设计步骤生成初始关系模式规范化关系模式不良设计会导致问题信息重复无法表示某些信息示例合并模式带来的问题假设将两个具有多对一映射的表合并合并为问题的信息可能重复从到是多对一的映射基数对于的教师其所属系的和属性值将重复具体问题插入问题信息冗余添加一个新教师时其所在系的和信息会重复存储删除问题如果取消系需要删除所有属于该系的教师元组每次删除系信息都会级联删除教师信息更新问题信息冗余信息冗余使更新复杂化可能导致预算值不一致例如将系的预算从改为时所有属于该系的教师元组都必须更新信息表示问题要表示一个新开设的尚无教师的系必须插入包含值的元组例如数据库中的值使数据处理复杂化问题解决规范化原则等价变换对初始关系模式集进行模式分解保证关系模式满足函数无损连接性函数依赖保持性动机关系模式集需要规范化使用函数依赖进行分解内容概览键和函数依赖三类特殊函数依赖平凡部分传递无损分解示例对比合并模式无重复一对一映射将和合并为由于从到的映射基数是一对一的因此无信息重复分解为较小模式正确的分解从开始将其分解为和假设有一个模式那么将是一个候选键记为一个函数依赖注意在中因为不是候选键所以系的和信息不得不重复并非所有分解都是好的有损分解示例将分解为和问题信息丢失我们无法重构原始的关系因为不同的人可能同名自然连接会产生额外元组无损连接分解示例关系模式分解为和因为且是的键所以是无损分解通过投影和自然连接可以恢复原关系无损分解定义定义设是一个关系模式和构成的一个分解即如果通过用和替换模式没有丢失信息则该分解是无损分解形式化定义如果则该分解是有损分解规范化理论动机假设初始关系形式不佳将分解为关系使得每个关系形式良好分解是无损连接分解分解基于函数依赖讨论关系规范化理论是否有用数据库设计是否需要设计要求存在的问题解决手段权衡取舍函数依赖作为约束函数依赖概述作为约束通常存在关于数据的完整性约束规则示例期望成立的约束学生和教师由其唯一标识每个学生和教师只有一个姓名每个教师和学生只关联于一个系函数依赖定义定义关系的一个合法实例是满足所有此类现实世界约束的关系实例函数对于如果则函数依赖关于合法关系的现实世界约束即某个属性集的值唯一确定另一个属性集的值注意是键的推广关系实例满足函数依赖定义对于模式如果对于中的任意元组对和满足则关系实例满足或者说被满足定义如果被满足则在下是合法的注意某个属性集的值唯一确定了另一个属性集的值语句判断函数依赖给定关系模式和关系利用语句判断关系是否满足函数依赖要求如果不满足该函数依赖找出导致不满足的中的元组方法使用元组变量自连接如果查询结果非空则函数依赖不成立结果中的元组即为反例使用如果查询结果为即不存在这样的则函数依赖成立用断言维护设计一个断言以保证在上成立示例判断是否被满足给定关系如下判断哪些被满足元组分析但因此不满足假设连接表示但因此不满足满足检查所有值相同的元组其值也必须相同元组中组合唯一自然满足但因此不满足函数依赖在模式上成立函数依赖被满足定义设为一个关系模式如果每个合法实例都满足则在上成立注意只要的两个元组在属性上一致它们也必须在属性上一致示例考虑的以下实例在这个实例上成立因为每个值只对应一个值不成立因为对应了两个不同的值和区别与联系在上成立定义在的属性间的语义约束或的属性间体现出的语义约束从设计角度是应满足的约束被满足根据构造的实际数据是否满足语义约束如果在上成立那么的每个合法实例都满足这个但是对于模式和如果只有某些满足可能不在上成立对于定义在模式上的关系如果满足那么在模式上成立吗可能不成立因为其他合法实例可能违反该函数依赖示例建模考虑假设每个员工每天只有一条日营业额记录每个员工工作于只有一个部门每个部门只有一名经理上的键和函数依赖定义如果且仅如果则是关系模式的超键定义如果且仅如果且对于任何不成立则是的候选键示例考虑模式我们期望成立的此处似乎有误应能确定更典型的是不期望成立的函数依赖在数据库中的完整性约束图描述对象及它们之间的关联而则说明对象即图中的实体或联系属性间的关系如何在中保证使用的完整性机制例如键检查约束触发器函数依赖的用途注意的用途测试关系是否合法如果关系在集合下是合法的则满足指定合法关系集合上的约束如果所有在上的合法关系都满足集合则在上成立注意关系模式的一个特定实例可能满足中的一个即使该并非在所有合法实例上都成立特殊类型的函数依赖平凡函数依赖定义如果一个被关系的所有实例满足则它是平凡的是平凡的如果示例定义主属性出现在至少一个候选键中的属性传递依赖定义一个函数依赖是传递的如果成立但不成立成立不在中则称传递依赖于示例对于两个和存在传递依赖部分依赖定义一个是部分的如果存在的一个子集即使得成立部分函数依赖表明非最小化存在冗余部分依赖于示例对于部分依赖存在属性子集使得或成立函数依赖集的闭包定义用符号表示集合的闭包它是给定集合可以推导出的所有的集合包含中的所有示例无损分解定义无损分解对于要求对于模式上所有可能的关系都有定义将分解为和是无损的如果以下中至少有一个在中结论如果只有成立那么是的主键并且是的外键这是一个充分条件示例考虑模式分解为和模式包含外键考虑两个模式的交集即由于满足无损分解规则示例无损分解且无损分解且注意是的简写范式范式种类第一范式第二范式范式第三范式规范化原则关系模式规范化处理的基本要求为静态关系具有第一范式形式动态关系最好具有或形式范式可以看作由符合范式要求的各种关系模式组成的关系模式的集合例如满足第一范式的定义范式间的关系更准确地说满足则一定满足满足则一定满足满足则一定满足原子域和第一范式定义一个关系模式属于第一范式如果的所有属性的域都是原子的域是原子的如果它的元素是不可分割的单位非原子域示例集合例如一个属性值包含多个学生姓名复合属性例如定义原子性是域元素如何使用的一个属性示例字符串通常被认为是不可分割的但是如果给学生分配像或这样的学号并且提取前两个字符来查找系别那么学号的域就不是原子的这样做是一个坏主意示例这里的似乎是一个复合值可能包含入学年份班级序号违反了原子性第二范式定义一个关系模式关于一个集合属于如果属于且每个属性满足以下条件之一它出现在一个候选键中是主属性它不是主属性并且完全依赖于某个候选键即不存在部分依赖特点不存在非主属性对候选键的部分依赖非主属性完全依赖于候选键示例示例不属于因为对于非主属性存在所以部分依赖于键对于非主属性存在所以部分依赖于键示例不属于因为对于非主属性和它们部分依赖于键注意可以被分解为两个模式范式定义一个关系模式关于一个集合属于如果对于中所有形式为其中且的至少满足以下条件之一是平凡的即是的一个超键示例示例不属于的模式两个因为在上成立但不是一个超键注意将分解为和属于属于将模式分解为设是一个不属于的模式设是导致违反的将分解为组成单独模式从中去掉只出现在的右部而没有出现在左部的属性和之间存在外键关联示例被替换为对应对应与依赖保持并非总是可能同时实现和依赖保持示例考虑模式具有两个候选键和不属于因为不是一个超键我们需要将分解为两个模式任何这样的分解都不会包含中的所有属性因此该分解不是依赖保持的函数依赖只能通过分解后的关系的连接来检查示例无损连接分解且依赖保持无损连接分解且不是依赖保持的不计算和的连接就无法检查注意对的约束在实践中检查成本很高除非它们只涉及一个关系如果只需测试分解中每个单独关系上的就能确保所有都成立那么该分解就是依赖保持的注意因为并非总是可能同时实现和依赖保持我们考虑一个较弱的范式称为第三范式第三范式定义一个关系模式属于第三范式如果对于中所有的至少满足以下条件之一是平凡的即是的一个超键中的每个属性都包含在的某个候选键中即出现在右端但不出现在左端的属性示例和可能分别出现在不同的候选键中注意每个属性可能在不同的候选键中注意如果一个关系属于那么它也属于如果属于那么它也属于消除了非主属性对键的传递函数依赖性质也属于不存在非主属性对候选键的部分和传递依赖每一个非主属性都不传递依赖于的任何候选键示例考虑模式具有两个候选键不属于但是属于是一个超键成立而不是一个超键但是并且包含在一个候选键中中的冗余考虑以下属于的模式问题信息重复当某个值例如指导多名学生对应多个值时其关联的值会重复需要使用空值例如为了表示关系其中没有对应的值即某个教师没有指导学生则列必须为映射到示例对应对应对应与的比较相对于的优点总是可以在不牺牲无损连接性或依赖保持性的情况下获得一个设计分解可以保证无损连接函数依赖保持分解保证无损连接但不保证函数依赖保持的缺点我们可能不得不使用空值来表示数据项之间一些可能的有意义的关系存在信息重复的问题规范化的目标设是一个具有集合的关系模式决定一个关系模式是否形式良好当一个关系模式形式不佳时将其分解为使得每个关系模式形式良好例如属于该分解是无损分解该分解应该是依赖保持的范式总结属性原子消除非主属性对键的部分函数依赖消除非主属性对键的传递函数依赖消除所有属性包括主属性和非主属性对键的部分和传递依赖更严格所有非平凡的其左部必须是超键函数依赖理论目标由给定集合逻辑蕴含的公理开发算法生成到和的无损分解开发算法测试分解是否是依赖保持的函数依赖间的逻辑蕴含给定一个集合存在其他被逻辑蕴含的示例如果且则可推断定义给定模式一个被集合逻辑蕴含如果每个满足的实例也都满足定义被逻辑蕴含的所有的集合称为的闭包用表示的闭包被逻辑蕴含示例被逻辑蕴含函数依赖集的闭包通过重复应用公理计算的闭包自反律如果则增广律如果则传递律如果且则这些规则是健全的只生成实际成立的完备的生成所有成立的附加规则可从上述公理推导合并律如果成立且成立则成立分解律如果成立则成立且成立伪传递律如果成立且成立则成立示例中的一些成员根据和的传递性用增广得到然后与传递得到增广推导出增广推导出然后传递属性集的闭包定义在下如果在下成立则属性被函数确定记作定义给定一个属性集在下的闭包记作是被在下函数确定的属性集合被在下函数确定属性集闭包算法输入输出发生改变属性集闭包示例计算和且且所以是的一个超键问题是候选键吗是超键吗是的任何子集是超键吗计算所以不是超键计算所以不是超键因此是一个候选键属性闭包算法的用途测试超键要测试是否是超键计算并检查是否包含的所有属性测试要检查是否成立即是否在中只需检查注意通过属性闭包计算然后检查它是否包含集合的等价定义对于两个集合和如果则和是等价的示例等价于正则覆盖动机当用户对执行更新时必须确保该更新不会违反任何所有在中的都必须被满足通常通过执行检查约束断言触发器或更复杂的语句来实现成本很高例如更新要求在到之间如果更新前的值为更新后最后一条记录违反了约束检查上所有是否成立是耗时的中可能有冗余的依赖可以从其他依赖推导出来例如在中是冗余的正则覆盖简化后的集合称为正则覆盖我们希望测试一个与等价的最小集合定义的一个正则覆盖是一个与等价的最小集合没有冗余的或属性定义冗余冗余可以从中的其他推断出来无关属性和无关定义无关属性如果我们可以删除中的一个属性而不改变则该属性是无关的动机左边或右边的属性可能是无关的性质从的左边移除一个属性可能会使它成为一个更强的约束例如如果我们有并移除我们得到可能更强的结果因为逻辑蕴含但不逻辑蕴含但是根据集合的具体情况我们可能可以安全地从中移除假设证明逻辑蕴含使得在中是无关的性质从的右边移除一个属性可能会使它成为一个更弱的约束例如如果我们有并移除我们得到可能更弱的结果但是根据集合的具体情况我们可能可以安全地从中移除例如假设在用替换后我们仍然可以推断出从而测试一个属性是否无关考虑中的属性测试在中是否无关考虑集合检查在下是否包含即如果是则在中是无关的考虑中的属性测试在中是否无关令检查是否可以从推断出来使用中的计算如果包含中的所有属性即那么在中是无关的无关属性示例例给定在中是无关的因为逻辑蕴含例给定在中是无关的因为删除后仍然可以从其他依赖推断出例检查在中是否无关步骤计算在下的闭包步骤闭包是包含结论是无关的正则覆盖定义与计算定义的一个正则覆盖是一个满足以下条件的集合逻辑蕴含中的所有依赖逻辑蕴含中的所有依赖中不包含无关属性中每个的左部是唯一的不存在两个和使得计算的正则覆盖使用合并律将中形式为和的替换为在中找到一个它在或中有一个无关属性如果找到了无关属性将其从中删除不再改变注意在删除一些无关属性后合并律可能变得适用注意一个集合可能有多个正则覆盖正则覆盖计算示例步骤使用合并律将和合并为集合变为步骤在中是无关的检查从中删除的结果是否被其他依赖蕴含是的已经存在集合变为步骤在中是无关的检查是否被和其他依赖逻辑蕴含是的使用和的传递性结论正则覆盖是无损连接分解对于我们要求对于模式上所有可能的关系都有将分解为和是无损连接的如果以下依赖中至少有一个在中注意上述是无损连接分解的充分条件只有当所有约束都是时这些依赖才是必要条件不同于表间存在外键关联无损连接是一个更广义的概念依赖保持定义对于模式在上成立以及的分解到的限制记作定义为且这是中仅包含中属性的集合定义设是到的限制如果则分解是依赖保持的注意测试依赖保持是指数时间的依赖保持测试算法测试在分解中是否被保持在下计算的闭包然后与取交集不再改变如果包含中的所有属性则被保持对所有进行测试以检查分解是否是依赖保持的该过程需要多项式时间依赖保持示例例在上无损分解问题是否被保持所以被保持例分解无损因为是和的键非依赖保持因为丢失了原因对于中的使用算法关于关于最终不包含所以该未被保持分解无损连接因为并且是的键依赖保持因为使用函数依赖的分解算法内容概览测试分解分解算法测试分解分解算法测试关系是否属于方法要判断是否导致违反计算的属性闭包验证它是否包含的所有属性即它是否是的超键简化测试要检查一个关系模式是否属于只需检查中而不是中的每个是否违反即可如果中没有导致违反那么中也没有会导致违反注意当测试的分解中的关系时仅使用的简化测试是不正确的示例将分解为和中的都不只包含中的属性所以我们可能误以为满足事实上中的表明不属于因为不是的超键测试分解中的关系是否属于要么使用到的限制来测试要么使用原始集合但进行如下测试对于每个属性集检查要么不包含中的任何属性要么包含的所有属性分解算法输入关系模式以及在其上成立的集合输出的一个无损分解中存在一个不属于的子模式令是上成立的一个使得不是的超键由于并且关于在上的限制是非平凡的即用两个子模式替换中的和注意如何判断是否属于检查是否有非平凡在上成立且不是的超键算法将非的替换为和被分解为和属于的到模式的限制是且是的超键所以属于分解示例例键不属于成立但不是超键分解由于违反不是超键将分解为例候选键计算过程略分解成立但不是超键将替换为属于是候选键检查候选键不属于因为成立但不是超键将替换为属于属于最终被分解为和分解可能无法保持依赖例两个候选键和不属于因为成立不是超键一个分解具有没有问题不保持依赖丢失了的任何分解都无法保持第三范式分解动机有些情况下不是依赖保持的而检查违反很重要解决方案定义一个较弱的范式它允许一些冗余但存在到的无损连接依赖保持分解注意应计算出的所有候选键测试关系是否属于优化只检查中的而不是中的所有如果是超键使用属性闭包检查每个如果不是超键检查中的每个属性是否包含在某个候选键中测试是昂贵的因为它涉及找到所有候选键测试已被证明是问题但是分解到可以在多项式时间内完成分解算法输入关系模式在其上成立的集合输出的一个无损且依赖保持的分解步骤找出的所有候选键找出的一个正则覆盖对于中的每个如果还没有被包含在任何已生成的模式中则创建一个新的子模式如果第步生成的子模式中没有一个包含的任一候选键则挑选的任意一个候选键为其单独创建一个子模式返回注意只要有一个候选键包含在第步构造出的某个子模式中就无需在第步中为候选键单独构造子模式第步中只需挑选的一个候选键分解示例例考虑模式在上成立给出一个无损依赖保持的分解解法步骤求候选键使用附录算法类类空类空类计算所以是唯一的候选键步骤求正则覆盖原始考虑中的和中的蕴含所以中的和中的都是无关属性因此一个正则覆盖是注意的其他正则覆盖还有步骤根据算法生成子模式对中的每个创建已被包含创建创建检查候选键它没有被任何现有子模式包含因此为候选键创建一个分解是如果使用其他正则覆盖会得到不同的但等价的分解例如例所有候选键计算过程略的最高范式不属于因为存在左部不是超键左部不是超键左部不是超键不属于因为对于不是超键且中的属性不包含在任何候选键中候选键是和这些属性不在键中给出一个无损连接且依赖保持的分解假设已是最小对每个创建子模式已包含在中检查候选键已包含在中因此无需为另一个候选键单独创建子模式分解为与对比注意总是可以将一个关系分解为一组属于的关系使得分解是无损的依赖是保持的注意总是可以将一个关系分解为一组属于的关系使得分解是无损的但可能无法保持依赖附录计算候选键算法定理如果属性只出现在中函数依赖的左部则一定是主属性必然出现在候选键中方法输入关系模式及其函数依赖集输出的所有候选键步骤将的所有属性分为四类类仅出现在中函数依赖左部的属性类仅出现在中函数依赖右部的属性类在中函数依赖左右两边均未出现的属性类在中函数依赖左右两边均出现的属性令类类类计算如果则为的唯一候选键转到步骤否则转到步骤在中取一个属性计算若它包含了的所有属性则转步骤否则调换属性重复此过程直到试完中的所有单个属性如果已找出所有的候选键则转步骤否则在中依次取两个三个属性求其属性闭包直至其闭包包含的所有属性注意排除已找到的候选键的超集停止输出结果计算候选键示例例类类无类无类计算所以是候选键也是唯一的例类类类类计算所以是一个候选键例步骤类无类无类类步骤不为步骤从中取单个属性都不等于所以是一个候选键继续寻找其他候选键不包括取两个属性不包括所以是一个候选键检查其他两个属性组合如不含或不等于取三个属性不包括且不包含无法构成新的候选键所以候选键是例出现在左边的属性出现在右边的属性类类类类无计算候选键测试所以是候选键测试所以是候选键测试都不等于测试所以是候选键测试等不等于最终找到个候选键还有需要检查所有可能组合例如根据闭包计算可能等于实际上可能包含然后得到然后得到所以也是候选键需要仔细计算题目给出答案是个可能为附录习题类型给定关系表和若干函数依赖判断是否满足根据公理系统判断关于函数依赖的一些公式是否成立例如如果则根据文字描述抽象出函数依赖关系设计语句判断函数依赖和键利用算法求候选键计算属性闭包计算函数依赖集的最小正则集给定关系模式和定义在上的函数依赖集判断属于第几范式为什么只考虑判断一个模式分解是否为无损连接使用定理函数依赖保持使用定义或算法给定非的关系模式和定义在上的函数依赖集将分解为第三范式给定非的关系模式和定义在上的函数依赖集将分解为范式本章结构总结良好关系设计的特征为什么需要规范化良好模式模式修改中的问题使用函数依赖进行分解分解无损分解规范化原则键和函数依赖无损分解和函数依赖范式良好模式的标准定义依赖保持属性与关系函数依赖理论闭包逻辑蕴含属性集闭包正则覆盖无损连接分解依赖保持使用函数依赖的分解算法和的分解算法略使用多值依赖的分解更高范式不基于略数据库设计过程附录求解候选键算法附录示例与练习感谢关注北京师范大学',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-12-26 22:36:07',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><style>
  /* === 只添加半透明磨砂效果，不改变任何布局 === */
  
  /* 1. 导航栏内所有可点击元素添加磨砂背景 */
  #nav a,
  #nav button {
    /* 保持原有布局，只添加背景效果 */
    backdrop-filter: blur(6px) !important;
    -webkit-backdrop-filter: blur(6px) !important;
    transition: backdrop-filter 0.3s ease !important;
  }
  
  /* 2. 浅色模式：白色半透明 */
  body:not([data-theme="dark"]) #nav a,
  body:not([data-theme="dark"]) #nav button {
    background-color: rgba(255, 255, 255, 0.1) !important;
  }
  
  /* 3. 深色模式：黑色半透明 */
  [data-theme="dark"] #nav a,
  [data-theme="dark"] #nav button {
    background-color: rgba(0, 0, 0, 0.1) !important;
  }
  
  /* 4. 悬停效果：稍微增加透明度 */
  #nav a:hover,
  #nav button:hover {
    backdrop-filter: blur(8px) !important;
    -webkit-backdrop-filter: blur(8px) !important;
  }
  
  body:not([data-theme="dark"]) #nav a:hover,
  body:not([data-theme="dark"]) #nav button:hover {
    background-color: rgba(255, 255, 255, 0.15) !important;
  }
  
  [data-theme="dark"] #nav a:hover,
  [data-theme="dark"] #nav button:hover {
    background-color: rgba(0, 0, 0, 0.15) !important;
  }
</style>
<link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 8.1.1"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Yuejin's Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Platform/" style="font-size: 1.05rem;">AI Platform<sup>1</sup></a><a href="/tags/Database/" style="font-size: 1.05rem;">Database<sup>6</sup></a><a href="/tags/English/" style="font-size: 1.05rem;">English<sup>1</sup></a><a href="/tags/RNN/" style="font-size: 1.05rem;">RNN<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 1.05rem;">SQL<sup>5</sup></a><a href="/tags/Self-Attention/" style="font-size: 1.05rem;">Self Attention<sup>1</sup></a><a href="/tags/plan/" style="font-size: 1.05rem;">plan<sup>2</sup></a><a href="/tags/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" style="font-size: 1.05rem;">关系模型<sup>1</sup></a><a href="/tags/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B/" style="font-size: 1.05rem;">自注意力<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/12/"><span class="card-archive-list-date">December 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">14</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url">数据库</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Database/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Database</span></a><a class="article-meta__tags" href="/tags/SQL/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>SQL</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Schema Normalization-Relational Database Design 解读</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-12-26T14:25:50.639Z" title="发表于 2025-12-26 22:25:50">2025-12-26</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-12-26T14:36:07.810Z" title="更新于 2025-12-26 22:36:07">2025-12-26</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/C7_cover.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/"><header><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url">数据库</a><a href="/tags/Database/" tabindex="-1" itemprop="url">Database</a><a href="/tags/SQL/" tabindex="-1" itemprop="url">SQL</a><h1 id="CrawlerTitle" itemprop="name headline">Schema Normalization-Relational Database Design 解读</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Yuejin Wu</span><time itemprop="dateCreated datePublished" datetime="2025-12-26T14:25:50.639Z" title="发表于 2025-12-26 22:25:50">2025-12-26</time><time itemprop="dateCreated datePublished" datetime="2025-12-26T14:36:07.810Z" title="更新于 2025-12-26 22:36:07">2025-12-26</time></header><h3 id="关系数据库设计-模式规范化"><a href="#关系数据库设计-模式规范化" class="headerlink" title="关系数据库设计 模式规范化"></a>关系数据库设计 模式规范化</h3><h2 id="数据库设计流程概述"><a href="#数据库设计流程概述" class="headerlink" title="数据库设计流程概述"></a>数据库设计流程概述</h2><h3 id="独立于DBMS的步骤"><a href="#独立于DBMS的步骤" class="headerlink" title="独立于DBMS的步骤"></a>独立于DBMS的步骤</h3><ol>
<li><strong>应用领域&#x2F;现实世界问题</strong>：需求分析。</li>
<li><strong>功能需求规格说明</strong>：概念数据库设计。</li>
<li><strong>概念数据库模式</strong>：即E-R模式。</li>
</ol>
<h3 id="依赖于DBMS的步骤"><a href="#依赖于DBMS的步骤" class="headerlink" title="依赖于DBMS的步骤"></a>依赖于DBMS的步骤</h3><ol>
<li><strong>逻辑数据库设计</strong>：<ul>
<li>初始关系模式生成。</li>
<li>关系模式。</li>
<li><strong>逻辑数据库模式</strong>：即关系数据模拟。</li>
</ul>
</li>
<li><strong>物理数据库设计</strong>：<ul>
<li><strong>物理数据库模式</strong>：关于物理存储结构和访问方法。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="本章大纲"><a href="#本章大纲" class="headerlink" title="本章大纲"></a>本章大纲</h2><ol>
<li>良好关系设计的特征</li>
<li>函数依赖理论</li>
<li>范式</li>
<li>使用函数依赖进行分解</li>
<li>分解算法</li>
</ol>
<hr>
<h2 id="7-1-良好的关系数据库设计"><a href="#7-1-良好的关系数据库设计" class="headerlink" title="7.1 良好的关系数据库设计"></a>7.1 良好的关系数据库设计</h2><h3 id="困难与挑战"><a href="#困难与挑战" class="headerlink" title="困难与挑战"></a>困难与挑战</h3><ul>
<li><strong>概念设计</strong>、E-R<strong>图转换</strong>、逻辑设计后得到初始关系模式。</li>
<li>初始关系模式存在关系模式属性间的数据依赖关系，主要是<strong>函数依赖</strong>。</li>
<li>直接根据初始关系模式及属性间数据依赖关系构造数据库系统，可能导致数据库完整性约束被违反，并引起性能下降，具体表现为以下问题：<ul>
<li><strong>冗余问题</strong></li>
<li><strong>插入问题</strong></li>
<li><strong>更新问题</strong></li>
<li><strong>删除问题</strong></li>
</ul>
</li>
</ul>
<h3 id="逻辑设计步骤"><a href="#逻辑设计步骤" class="headerlink" title="逻辑设计步骤"></a>逻辑设计步骤</h3><ol>
<li><strong>生成</strong>：初始关系模式。</li>
<li><strong>规范化</strong>：关系模式。</li>
</ol>
<ul>
<li>不良设计会导致问题：<ul>
<li>信息重复。</li>
<li>无法表示某些信息。</li>
</ul>
</li>
</ul>
<h3 id="示例：合并模式带来的问题"><a href="#示例：合并模式带来的问题" class="headerlink" title="示例：合并模式带来的问题"></a>示例：合并模式带来的问题</h3><ul>
<li>假设将两个具有多对一映射的表合并：<ul>
<li><code>instructor (ID, name, salary, dept_name)</code></li>
<li><code>department (dept_name, building, budget)</code></li>
</ul>
</li>
<li>合并为：<ul>
<li><code>ins_dept (ID, name, salary, dept_name, building, budget)</code></li>
</ul>
</li>
<li><strong>问题</strong>：<strong>department</strong>的信息可能重复。<ul>
<li>从<code>instructor</code>到<code>department</code>是<strong>多对一</strong>的映射基数。</li>
<li>对于ID&#x3D;45565, 10101, 83821的教师，其所属系的<strong>building</strong>和<strong>budget</strong>属性值将重复。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">ID</th>
<th align="left">name</th>
<th align="left">salary</th>
<th align="left">dept_name</th>
<th align="left">building</th>
<th align="left">budget</th>
</tr>
</thead>
<tbody><tr>
<td align="left">22222</td>
<td align="left">Einstein</td>
<td align="left">95000</td>
<td align="left">Physics</td>
<td align="left">Watson</td>
<td align="left">70000</td>
</tr>
<tr>
<td align="left">12121</td>
<td align="left">Wu</td>
<td align="left">90000</td>
<td align="left">Finance</td>
<td align="left">Painter</td>
<td align="left">120000</td>
</tr>
<tr>
<td align="left">32343</td>
<td align="left">El Said</td>
<td align="left">60000</td>
<td align="left">History</td>
<td align="left">Painter</td>
<td align="left">50000</td>
</tr>
<tr>
<td align="left">45565</td>
<td align="left">Katz</td>
<td align="left">75000</td>
<td align="left">Comp.Sci.</td>
<td align="left">Taylor</td>
<td align="left">100000</td>
</tr>
<tr>
<td align="left">98345</td>
<td align="left">Kim</td>
<td align="left">80000</td>
<td align="left">Elec.Eng.</td>
<td align="left">Taylor</td>
<td align="left">85000</td>
</tr>
<tr>
<td align="left">76766</td>
<td align="left">Crick</td>
<td align="left">72000</td>
<td align="left">Biology</td>
<td align="left">Watson</td>
<td align="left">90000</td>
</tr>
<tr>
<td align="left">10101</td>
<td align="left">Srinivasan</td>
<td align="left">65000</td>
<td align="left">Comp.Sci.</td>
<td align="left">Taylor</td>
<td align="left">100000</td>
</tr>
<tr>
<td align="left">58583</td>
<td align="left">Califieri</td>
<td align="left">62000</td>
<td align="left">History</td>
<td align="left">Painter</td>
<td align="left">50000</td>
</tr>
<tr>
<td align="left">83821</td>
<td align="left">Brandt</td>
<td align="left">92000</td>
<td align="left">Comp.Sci.</td>
<td align="left">Taylor</td>
<td align="left">100000</td>
</tr>
<tr>
<td align="left">15151</td>
<td align="left">Mozart</td>
<td align="left">40000</td>
<td align="left">Music</td>
<td align="left">Packard</td>
<td align="left">80000</td>
</tr>
<tr>
<td align="left">33456</td>
<td align="left">Gold</td>
<td align="left">87000</td>
<td align="left">Physics</td>
<td align="left">Watson</td>
<td align="left">70000</td>
</tr>
<tr>
<td align="left">76543</td>
<td align="left">Singh</td>
<td align="left">80000</td>
<td align="left">Finance</td>
<td align="left">Painter</td>
<td align="left">120000</td>
</tr>
<tr>
<td align="left">(t₁)</td>
<td align="left">(201081, null)</td>
<td align="left">(Zhang, null)</td>
<td align="left">(60000, null)</td>
<td align="left">(Comp.Sci, Soft.Eng.)</td>
<td align="left">(Taylor, Taylor)</td>
</tr>
</tbody></table>
<p><strong>具体问题</strong>：</p>
<ol>
<li><strong>插入问题（信息冗余）</strong>：<ul>
<li>添加一个新教师<code>t₁ = (201081, Zhang, 60000, Comp.Sci, Taylor, 100000)</code>时，其所在系的<code>dept_name</code>, <code>building</code>和<code>budget</code>信息会重复存储。</li>
</ul>
</li>
<li><strong>删除问题</strong>：<ul>
<li>如果取消<code>Comp.Sci</code>系，需要删除所有属于该系的教师元组。每次删除系信息都会级联删除教师信息。</li>
</ul>
</li>
<li><strong>更新问题（信息冗余）</strong>：<ul>
<li>信息冗余使更新复杂化，可能导致预算值不一致。例如，将<code>Comp.Sci</code>系的预算从100000改为120000时，所有属于该系的教师元组都必须更新。</li>
</ul>
</li>
<li><strong>信息表示问题</strong>：<ul>
<li>要表示一个<strong>新开设</strong>的、尚无教师的系，必须插入包含<code>null</code>值的元组，例如<code>t₂ = (null, null, null, Soft.Eng., Taylor, 100000)</code>。数据库中的<code>null</code>值使数据处理复杂化。</li>
</ul>
</li>
</ol>
<h3 id="问题解决：规范化原则"><a href="#问题解决：规范化原则" class="headerlink" title="问题解决：规范化原则"></a>问题解决：规范化原则</h3><ul>
<li><strong>等价变换</strong>：对初始关系模式集进行模式分解，保证关系模式满足：<ol>
<li><strong>函数无损连接性</strong></li>
<li><strong>函数依赖保持性</strong></li>
</ol>
</li>
<li><strong>动机</strong>：关系模式集需要规范化。</li>
</ul>
<hr>
<h2 id="7-2-使用函数依赖进行分解"><a href="#7-2-使用函数依赖进行分解" class="headerlink" title="7.2 使用函数依赖进行分解"></a>7.2 使用函数依赖进行分解</h2><h3 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h3><ol>
<li>键和函数依赖</li>
<li>三类特殊函数依赖：平凡、部分、传递</li>
<li>无损分解</li>
</ol>
<h3 id="示例对比"><a href="#示例对比" class="headerlink" title="示例对比"></a>示例对比</h3><ol>
<li><strong>合并模式无重复（一对一映射）</strong>：<ul>
<li>将<code>section (sec_id, building, room_number)</code>和<code>class (course_id, sec_id, semester, year)</code>合并为<code>sec_class (course_id, sec_id, semester, year, building, room_number)</code>。</li>
<li>由于从<code>section</code>到<code>class</code>的映射基数是<strong>一对一</strong>的，因此无信息重复。</li>
</ul>
</li>
<li><strong>分解为较小模式（正确的分解）</strong>：<ul>
<li>从<code>ins_dept (ID, name, salary, dept_name, building, budget)</code>开始。</li>
<li>将其分解为<code>instructor</code>和<code>department</code>。</li>
<li>假设有一个模式<code>(dept_name, building, budget)</code>，那么<code>dept_name</code>将是一个候选键。</li>
<li>记为一个函数依赖：<code>dept_name → building, budget</code>。</li>
<li>注意：在<code>ins_dept</code>中，因为<code>dept_name</code>不是候选键，所以系的<code>dept_name</code>、<code>building</code>和<code>budget</code>信息不得不重复。</li>
</ul>
</li>
<li><strong>并非所有分解都是好的（有损分解）</strong>：<ul>
<li><strong>示例</strong>：将<code>employee (ID, name, street, city, salary)</code>分解为<code>employee1 (ID, name)</code>和<code>employee2 (name, street, city, salary)</code>。</li>
<li><strong>问题</strong>：信息丢失。我们无法重构原始的<code>employee</code>关系（因为不同ID的人可能同名，自然连接会产生额外元组）。</li>
</ul>
</li>
<li><strong>无损连接分解示例</strong>：<ul>
<li>关系模式<code>R = (A, B, C)</code>分解为<code>R1 = (A, B)</code>和<code>R2 = (B, C)</code>。因为<code>R1 ∩ R2 = {B}</code>，且<code>B</code>是<code>R2</code>的键（<code>B → BC</code>），所以是无损分解。通过投影和自然连接可以恢复原关系。</li>
</ul>
</li>
</ol>
<h3 id="无损分解定义"><a href="#无损分解定义" class="headerlink" title="无损分解定义"></a>无损分解定义</h3><ul>
<li><strong>定义1</strong>：设<code>R</code>是一个关系模式，<code>R1</code>和<code>R2</code>构成<code>R</code>的一个分解，即<code>R = R1 ∪ R2</code>。如果通过用<code>R1</code>和<code>R2</code>替换模式<code>R</code><strong>没有丢失</strong>信息，则该分解是<strong>无损分解</strong>。<ul>
<li>形式化：<code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li>
</ul>
</li>
<li><strong>定义2</strong>：如果<code>r ⊂ ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>，则该分解是<strong>有损分解</strong>。</li>
</ul>
<h3 id="规范化理论"><a href="#规范化理论" class="headerlink" title="规范化理论"></a>规范化理论</h3><ul>
<li><strong>动机</strong>：假设初始关系<code>R</code>形式不佳，将<code>R</code>分解为关系<code>{R1, R2, ..., Rn}</code>，使得：<ul>
<li>每个关系<code>Ri</code>形式良好。</li>
<li>分解是无损连接分解。</li>
</ul>
</li>
<li><strong>分解</strong>基于：函数依赖。</li>
<li><strong>讨论</strong>：关系规范化理论是否有用，数据库设计是否需要？<ul>
<li>1）设计要求，存在的问题。</li>
<li>2）解决手段，权衡取舍。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="函数依赖作为约束"><a href="#函数依赖作为约束" class="headerlink" title="函数依赖作为约束"></a>函数依赖作为约束</h2><h3 id="函数依赖概述"><a href="#函数依赖概述" class="headerlink" title="函数依赖概述"></a>函数依赖概述</h3><ul>
<li><strong>作为约束</strong>：通常存在关于数据的（完整性）<strong>约束</strong>（规则）。</li>
<li><strong>示例</strong>：期望成立的约束：<ul>
<li>学生和教师由其ID<strong>唯一标识</strong>。</li>
<li>每个学生和教师<strong>只有一个</strong>姓名。</li>
<li>每个教师和学生<strong>只关联于一个</strong>系。</li>
</ul>
</li>
</ul>
<h3 id="函数依赖定义"><a href="#函数依赖定义" class="headerlink" title="函数依赖定义"></a>函数依赖定义</h3><ul>
<li><strong>定义</strong>：关系<code>R</code>的一个合法实例<code>r(R)</code>是满足所有此类现实世界约束的关系实例。</li>
<li><strong>函数</strong>：<code>f: X → Y, x ∈ X, y ∈ Y, y = f(x)</code>。对于<code>x1, x2 ∈ X</code>，如果<code>x1 = x2</code>，则<code>f(x1) = f(x2)</code>。</li>
<li><strong>函数依赖</strong>：关于合法关系的<strong>现实世界</strong>约束，即某个属性集的值<strong>唯一确定</strong>另一个属性集的值。</li>
<li><strong>注意</strong>：FD是键的推广。</li>
</ul>
<h3 id="关系实例满足函数依赖"><a href="#关系实例满足函数依赖" class="headerlink" title="关系实例满足函数依赖"></a>关系实例满足函数依赖</h3><ul>
<li><strong>定义1</strong>：对于模式<code>R</code>，<code>α ⊆ R</code>，<code>β ⊆ R</code>，如果对于<code>r(R)</code>中的任意元组对<code>ti</code>和<code>tj</code>，满足<code>ti[α] = tj[α] → ti[β] = tj[β]</code>，则关系实例<code>r(R)</code>满足<code>FD α → β</code>，或者说<code>α → β</code>被<code>r(R)</code>满足。</li>
<li><strong>定义2</strong>：如果<code>α → β</code>被<code>r(R)</code>满足，则<code>r(R)</code>在<code>α → β</code>下是合法的。</li>
<li><strong>注意</strong>：某个属性集的值唯一确定了另一个属性集的值。</li>
</ul>
<h3 id="SQL语句判断函数依赖"><a href="#SQL语句判断函数依赖" class="headerlink" title="SQL语句判断函数依赖"></a>SQL语句判断函数依赖</h3><ul>
<li><strong>给定关系模式</strong> <code>R(A, B, C)</code> 和关系<code>r(R)</code>，利用SQL语句判断关系<code>r(R)</code>是否满足函数依赖 <code>B → C</code>。</li>
<li><strong>要求</strong>：如果<code>r(R)</code>不满足该函数依赖，找出导致不满足的<code>r(R)</code>中的元组。</li>
<li><strong>方法</strong>：<ol>
<li><strong>使用元组变量（自连接）</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> r <span class="keyword">as</span> T, r <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.B <span class="operator">=</span> S.B <span class="keyword">and</span> T.C <span class="operator">&lt;&gt;</span> S.C</span><br></pre></td></tr></table></figure>
如果查询结果非空，则函数依赖不成立，结果中的元组即为反例。</li>
<li><strong>使用GROUP BY</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> B <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> B</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> C) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
如果查询结果为<code>null</code>（即不存在这样的B），则函数依赖成立。</li>
</ol>
</li>
<li><strong>用断言维护FD</strong>：设计一个断言，以保证在<code>R(A, B, C)</code>上成立 <code>B → C</code>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion B_determines_C <span class="keyword">check</span></span><br><span class="line">  (<span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span> B</span><br><span class="line">      <span class="keyword">from</span> R</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> B</span><br><span class="line">      <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> C) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="示例：判断FD是否被满足"><a href="#示例：判断FD是否被满足" class="headerlink" title="示例：判断FD是否被满足"></a>示例：判断FD是否被满足</h3><ul>
<li>给定关系<code>r(R)</code>如下，判断哪些FD被<code>r</code>满足？<ul>
<li>A. <code>A → B</code></li>
<li>B. <code>AC → B</code></li>
<li>C. <code>BC → A</code></li>
<li>D. <code>B → C</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">元组</th>
<th align="left">A</th>
<th align="left">B</th>
<th align="left">C</th>
</tr>
</thead>
<tbody><tr>
<td align="left">t1</td>
<td align="left">1</td>
<td align="left">4</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">t2</td>
<td align="left">3</td>
<td align="left">5</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">t3</td>
<td align="left">3</td>
<td align="left">4</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">t4</td>
<td align="left">7</td>
<td align="left">3</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">t5</td>
<td align="left">9</td>
<td align="left">1</td>
<td align="left">0</td>
</tr>
</tbody></table>
<ul>
<li><strong>分析</strong>：<ul>
<li><code>t2[A] = t3[A] = 3</code>, 但 <code>t2[B] = 5 ≠ t3[B] = 4</code>，因此 <code>A → B</code> <strong>不满足</strong>。</li>
<li><code>t2[AC] = t3[AC] = 36</code> (假设连接表示)，但 <code>t2[B] = 5 ≠ t3[B] = 4</code>，因此 <code>AC → B</code> <strong>不满足</strong>。</li>
<li><code>BC → A</code> <strong>满足</strong>。检查所有BC值相同的元组，其A值也必须相同。元组中BC组合唯一，自然满足。</li>
<li><code>t1[B] = t3[B] = 4</code>, 但 <code>t1[C] = 2 ≠ t3[C] = 6</code>，因此 <code>B → C</code> <strong>不满足</strong>。</li>
</ul>
</li>
</ul>
<h3 id="函数依赖在模式R上成立-vs-函数依赖被r-R-满足"><a href="#函数依赖在模式R上成立-vs-函数依赖被r-R-满足" class="headerlink" title="函数依赖在模式R上成立 vs 函数依赖被r(R)满足"></a>函数依赖在模式R上成立 vs 函数依赖被r(R)满足</h3><ul>
<li><p><strong>定义</strong>：设<code>R</code>为一个关系模式，<code>α ⊆ R</code>，<code>β ⊆ R</code>。如果每个合法实例<code>r(R)</code>都满足<code>α → β</code>，则FD <code>α → β</code>在<code>R</code>上<strong>成立</strong>。</p>
</li>
<li><p><strong>注意</strong>：只要<code>R</code>的两个元组在属性<code>α</code>上一致，它们也必须在属性<code>β</code>上一致：<code>t1[α] = t2[α] ⇒ t1[β] = t2[β]</code>。</p>
</li>
<li><p><strong>示例</strong>：考虑<code>r(A, B)</code>的以下实例：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td>1</td>
<td>5</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
</tr>
</tbody></table>
<ul>
<li>在这个实例上，<code>B → A</code><strong>成立</strong>（因为每个B值只对应一个A值：4-&gt;1, 5-&gt;1, 7-&gt;3）。</li>
<li><code>A → B</code><strong>不成立</strong>（因为A&#x3D;1对应了两个不同的B值：4和5）。</li>
</ul>
</li>
<li><p><strong>区别与联系</strong>：</p>
<ul>
<li><strong>FD在R上成立</strong>：定义在<code>R</code>的属性间的语义约束，或<code>R</code>的属性间体现出的语义约束。从设计角度，是<code>R</code>应满足的约束。</li>
<li><strong>FD被r(R)满足</strong>：根据<code>R</code>构造的实际数据<code>r(R)</code>是否满足语义约束。</li>
<li>如果<code>α → β</code>在<code>R</code>上成立，那么<code>R</code>的每个合法实例<code>r(R)</code>都满足这个FD。</li>
<li>但是，对于模式<code>R</code>和<code>α → β</code>，如果只有某些<code>r(R)</code>满足<code>R</code>，<code>α → β</code>可能不在<code>R</code>上成立。</li>
<li>对于定义在模式<code>R</code>上的关系<code>r(R)</code>，如果<code>r</code>满足<code>FD = {α → β}</code>，那么<code>FD</code>在模式<code>R</code>上成立吗？<strong>可能不成立</strong>（因为其他合法实例可能违反该FD）。</li>
</ul>
</li>
</ul>
<h3 id="函数依赖示例建模"><a href="#函数依赖示例建模" class="headerlink" title="函数依赖示例建模"></a>函数依赖示例建模</h3><ul>
<li>考虑 <code>R = {employee_ID, date, turnover per-day, department_name, manager}</code>。</li>
<li>假设：<ul>
<li>每个员工每天<strong>只有一条</strong>日营业额记录。</li>
<li>每个员工工作于<strong>只有一个</strong>部门。</li>
<li>每个部门<strong>只有一名</strong>经理。</li>
</ul>
</li>
<li><code>R</code>上的FD：<ul>
<li><code>F = {employee_ID, date → turnover per-day, employee_ID → department_name, department_name → manager}</code></li>
</ul>
</li>
</ul>
<h3 id="键和函数依赖"><a href="#键和函数依赖" class="headerlink" title="键和函数依赖"></a>键和函数依赖</h3><ul>
<li><strong>定义</strong>：如果且仅如果<code>K → R</code>，则<code>K</code>是关系模式<code>R</code>的超键。</li>
<li><strong>定义</strong>：如果且仅如果：<ol>
<li><code>K → R</code>，且</li>
<li>对于任何<code>α ⊂ K</code>，<code>α → R</code>不成立，<br>则<code>K</code>是<code>R</code>的候选键。</li>
</ol>
</li>
<li><strong>示例</strong>：考虑模式<code>in_dep (ID, name, salary, dept_name, building, budget)</code>。<ul>
<li>我们期望成立的FD：<code>dept_name → building</code>；<code>ID → building</code>（？此处似乎有误，ID应能确定dept_name？更典型的是<code>ID → dept_name</code>）。</li>
<li>不期望成立的FD：<code>dept_name → salary</code>。</li>
</ul>
</li>
</ul>
<h3 id="函数依赖在数据库中的完整性约束"><a href="#函数依赖在数据库中的完整性约束" class="headerlink" title="函数依赖在数据库中的完整性约束"></a>函数依赖在数据库中的完整性约束</h3><ul>
<li>E-R图描述对象及它们之间的关联，而FD则说明对象（即E-R图中的实体或联系）属性间的关系。</li>
<li><strong>如何在DBS中保证FD？</strong><ul>
<li>使用DBMS的完整性机制，例如：键、检查约束、触发器。</li>
</ul>
</li>
</ul>
<h3 id="函数依赖的用途"><a href="#函数依赖的用途" class="headerlink" title="函数依赖的用途"></a>函数依赖的用途</h3><ul>
<li><strong>注意1</strong>：FD的用途：<ol>
<li><strong>测试</strong>关系是否合法。如果关系<code>R</code>在FD集合<code>F</code>下是合法的，则<code>R</code>满足<code>F</code>。</li>
<li><strong>指定</strong>合法关系集合上的约束。如果所有在<code>R</code>上的合法关系都满足FD集合<code>F</code>，则<code>F</code>在<code>R</code>上成立。</li>
</ol>
</li>
<li><strong>注意2</strong>：关系模式<code>R</code>的一个特定实例<code>r0(R)</code>可能满足<code>F</code>中的一个FD，即使该FD并非在所有合法实例<code>{ri(R)}</code>上都成立。</li>
</ul>
<hr>
<h2 id="特殊类型的函数依赖"><a href="#特殊类型的函数依赖" class="headerlink" title="特殊类型的函数依赖"></a>特殊类型的函数依赖</h2><h3 id="1-平凡函数依赖"><a href="#1-平凡函数依赖" class="headerlink" title="1. 平凡函数依赖"></a>1. 平凡函数依赖</h3><ul>
<li><strong>定义1</strong>：如果一个FD被关系的所有实例满足，则它是平凡的。<ul>
<li><code>α → β</code>是平凡的，如果<code>β ⊆ α</code>。</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li><code>name → name</code></li>
<li><code>ID, name → ID</code></li>
</ul>
</li>
<li><strong>定义</strong>：<strong>主属性</strong>：出现在至少一个候选键中的属性。</li>
</ul>
<h3 id="2-传递依赖"><a href="#2-传递依赖" class="headerlink" title="2. 传递依赖"></a>2. 传递依赖</h3><ul>
<li><strong>定义2</strong>：一个函数依赖<code>α → γ</code>是<em>传递</em>的，如果：<ol>
<li><code>α → β</code>成立，但<code>β → α</code>不成立。</li>
<li><code>β → γ</code>成立。</li>
<li><code>γ</code>不在<code>α</code>中。</li>
</ol>
<ul>
<li>则称<code>γ</code>传递依赖于<code>α</code>。</li>
</ul>
</li>
<li><strong>示例</strong>：<code>Student (sno, sname, address, depart)</code><ul>
<li>对于两个FD：<code>sno → sname</code>和<code>sname → address</code>，存在传递依赖<code>sno → address</code>。</li>
</ul>
</li>
</ul>
<h3 id="3-部分依赖"><a href="#3-部分依赖" class="headerlink" title="3. 部分依赖"></a>3. 部分依赖</h3><ul>
<li><strong>定义3</strong>：一个FD <code>α → β</code>是<em>部分</em>的，如果存在<code>α</code>的一个子集<code>γ</code>（即<code>γ ⊂ α</code>），使得<code>γ → β</code>成立。<ul>
<li>部分函数依赖，表明<code>α</code>非最小化，存在冗余。</li>
<li><code>β</code>部分依赖于<code>α</code>。</li>
</ul>
</li>
<li><strong>示例</strong>：<code>Student (sno, sname, address, depart)</code><ul>
<li>对于部分依赖<code>(sno, sname) → address</code>，存在属性子集使得<code>sname → address</code>或<code>sno → address</code>成立。</li>
</ul>
</li>
</ul>
<h3 id="4-函数依赖集F的闭包-F"><a href="#4-函数依赖集F的闭包-F" class="headerlink" title="4. 函数依赖集F的闭包 F*"></a>4. 函数依赖集F的闭包 F*</h3><ul>
<li><strong>定义4</strong>：用符号<code>F*</code>表示FD集合<code>F</code>的闭包。<ul>
<li>它是给定FD集合<code>F</code>可以推导出的所有FD的集合。</li>
<li><code>F*</code>包含<code>F</code>中的所有FD。</li>
</ul>
</li>
<li><strong>示例</strong>：<br><code>F* = {A → B, B → C}+ = {A → B, B → C, A → C, AB → B, AC → BC, ...}</code></li>
</ul>
<h3 id="5-无损分解"><a href="#5-无损分解" class="headerlink" title="5. 无损分解"></a>5. 无损分解</h3><ul>
<li><strong>定义1（无损分解）</strong>：对于<code>R = (R1, R2)</code>，要求对于模式<code>R</code>上所有可能的关系<code>r</code>，都有 <code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li>
<li><strong>定义2</strong>：将<code>R</code>分解为<code>R1</code>和<code>R2</code>是无损的，如果以下FD中至少有一个在<code>F*</code>中：<ul>
<li><code>R1 ∩ R2 → R1</code></li>
<li><code>R1 ∩ R2 → R2</code></li>
</ul>
</li>
<li><strong>结论</strong>：如果只有<code>R1 ∩ R2 → R1</code>成立，那么<code>R1 ∩ R2</code>是<code>R1</code>的主键，并且是<code>R2</code>的外键。这是一个充分条件。</li>
<li><strong>示例</strong>：<ul>
<li>考虑模式<code>in-dep (ID, name, salary, dept_name, building, budget)</code>。</li>
<li>分解为<code>instructor</code>和<code>department</code>模式：<ul>
<li><code>instructor (ID, name, dept_name, salary)</code> （包含外键<code>dept_name</code>）</li>
<li><code>department (dept_name, building, budget)</code></li>
</ul>
</li>
<li>考虑两个模式的交集，即<code>dept_name</code>。<ul>
<li>由于<code>dept_name → building, budget</code>，满足<strong>无损分解规则</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li><code>R = {A, B, C}</code>， <code>F = {A → B, B → C}</code>。</li>
<li><code>R1 = {A, B}</code>, <code>R2 = {B, C}</code>。<ul>
<li>无损分解：<code>R1 ∩ R2 = {B}</code> 且 <code>B → BC</code>。</li>
</ul>
</li>
<li><code>R1 = {A, B}</code>, <code>R2 = {A, C}</code>。<ul>
<li>无损分解：<code>R1 ∩ R2 = {A}</code> 且 <code>A → AB</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：<code>BC</code>是<code>{B, C}</code>的简写。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-3-范式"><a href="#7-3-范式" class="headerlink" title="7.3 范式"></a>7.3 范式</h2><h3 id="范式种类"><a href="#范式种类" class="headerlink" title="范式种类"></a>范式种类</h3><ol>
<li><strong>1NF</strong>：第一范式</li>
<li><strong>2NF</strong>：第二范式</li>
<li><strong>BCNF</strong>：Boyce-Codd范式</li>
<li><strong>3NF</strong>：第三范式</li>
</ol>
<h3 id="规范化原则"><a href="#规范化原则" class="headerlink" title="规范化原则"></a>规范化原则</h3><ul>
<li>关系模式规范化处理的基本要求为：<ul>
<li>静态关系具有第一范式形式。</li>
<li>动态关系最好具有3NF或BCNF形式。</li>
</ul>
</li>
<li>范式1NF、2NF、3NF、BCNF可以看作由符合范式要求的各种关系模式组成的关系模式的集合。<ul>
<li>例如：<code>1NF = { R | R 满足第一范式的定义 }</code>。</li>
</ul>
</li>
<li>范式间的关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1NF ⊃ 2NF ⊃ 3NF ⊃ BCNF</span><br></pre></td></tr></table></figure>
（更准确地说，满足BCNF则一定满足3NF，满足3NF则一定满足2NF，满足2NF则一定满足1NF）。</li>
</ul>
<h3 id="原子域和第一范式"><a href="#原子域和第一范式" class="headerlink" title="原子域和第一范式"></a>原子域和第一范式</h3><ul>
<li><strong>定义</strong>：一个关系模式<code>R</code>属于<strong>第一范式</strong>，如果<code>R</code>的所有属性的域都是<strong>原子的</strong>。</li>
<li><strong>域是原子的</strong>：如果它的元素是<strong>不可分割</strong>的单位。</li>
<li><strong>非原子域示例</strong>：<ul>
<li>集合，例如<code>student_names = {Henry, Codd, ...}</code>（一个属性值包含多个学生姓名）。</li>
<li>复合属性，例如<code>[last_name, middle_name, first_name]</code>。</li>
</ul>
</li>
<li><strong>定义</strong>：原子性是域元素如何使用的一个属性。</li>
<li><strong>示例</strong>：字符串通常被认为是不可分割的。但是，如果给学生分配像<code>CS0012</code>或<code>EE1127</code>这样的学号，并且提取前两个字符来查找系别，那么学号的域就不是原子的。<strong>这样做是一个坏主意</strong>。</li>
<li><strong>示例</strong>：<table>
<thead>
<tr>
<th>ID</th>
<th>name</th>
<th>age</th>
<th>origin</th>
<th>department</th>
<th>grade</th>
</tr>
</thead>
<tbody><tr>
<td>2020 211 3xx</td>
<td>Li</td>
<td>20</td>
<td>Beijing</td>
<td>CS</td>
<td>2019</td>
</tr>
<tr>
<td>2019 211 4xx</td>
<td>Wang</td>
<td>21</td>
<td>SD</td>
<td>CS</td>
<td>2018</td>
</tr>
</tbody></table>
<ul>
<li>这里的ID似乎是一个复合值（可能包含入学年份、班级、序号），违反了原子性。</li>
</ul>
</li>
</ul>
<h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><ul>
<li><strong>定义</strong>：一个关系模式<code>R</code>关于一个FD集合<code>F</code>属于<strong>2NF</strong>，如果：<ol>
<li><code>R</code>属于1NF，且</li>
<li>每个属性<code>A</code>满足以下条件之一：<ul>
<li>它出现在一个候选键中（是主属性）。</li>
<li>它不是主属性，并且<strong>完全依赖</strong>于某个候选键（即不存在部分依赖）。</li>
</ul>
</li>
</ol>
</li>
<li><strong>2NF特点</strong>：<ul>
<li>不存在非主属性对候选键的<strong>部分依赖</strong>。</li>
<li>非主属性<strong>完全依赖</strong>于候选键。</li>
</ul>
</li>
</ul>
<h4 id="2NF示例"><a href="#2NF示例" class="headerlink" title="2NF示例"></a>2NF示例</h4><ul>
<li><strong>示例1</strong>：<code>SLC (S#, SDpt, SLocation, C#, Grade)</code><ul>
<li>FD: <code>(S#, C#) → Grade</code>, <code>SDpt → SLocation</code>, <code>S# → SDpt</code>, <code>(S#, C#) → SDpt</code>, <code>S# → SLocation</code>, <code>(S#, C#) → SLocation</code></li>
<li><code>SLC</code> <strong>不属于2NF</strong>，因为：<ul>
<li>对于非主属性<code>SDpt</code>，存在<code>S# → SDpt</code>，所以<code>SDpt</code>部分依赖于键<code>(S#, C#)</code>。</li>
<li>对于非主属性<code>SLocation</code>，存在<code>S# → SLocation</code>，所以<code>SLocation</code>部分依赖于键<code>(S#, C#)</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>示例2</strong>：<code>R (Sno, Sname, Status, City, Pno, Qty)</code><ul>
<li>FD: <code>Sno → Sname</code>, <code>Sno → Status</code>, <code>Status → City</code>, <code>(Sno, Pno) → Qty</code></li>
<li><code>R</code> <strong>不属于2NF</strong>，因为：<ul>
<li>对于非主属性<code>Sname</code>和<code>Status</code>，它们部分依赖于键<code>(Sno, Pno)</code>。</li>
</ul>
</li>
<li><strong>注意</strong>：<code>R</code>可以被分解为两个2NF模式：<ul>
<li><code>R1(Sno, Sname, Status, City)</code></li>
<li><code>R2(Sno, Pno, Qty)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Boyce-Codd范式"><a href="#Boyce-Codd范式" class="headerlink" title="Boyce-Codd范式"></a>Boyce-Codd范式</h3><ul>
<li><strong>定义3</strong>：一个关系模式<code>R</code>关于一个FD集合<code>F</code>属于<strong>BCNF</strong>，如果对于<code>F*</code>中所有形式为<code>α → β</code>（其中<code>α ⊆ R</code>且<code>β ⊆ R</code>）的FD，至少满足以下条件之一：<ol>
<li><code>α → β</code>是平凡的（即<code>β ⊆ α</code>）。</li>
<li><code>α</code>是<code>R</code>的一个超键。</li>
</ol>
</li>
</ul>
<h4 id="BCNF示例"><a href="#BCNF示例" class="headerlink" title="BCNF示例"></a>BCNF示例</h4><ul>
<li><strong>示例</strong>：不属于<strong>BCNF</strong>的模式：<code>in_dep (ID, name, salary, dept_name, building, budget)</code><ul>
<li><strong>两个FD</strong>：<code>ID → name, salary</code>；<code>dept_name → building, budget</code></li>
<li><strong>因为</strong>：<code>dept_name → building, budget</code>在<code>in_dep</code>上成立，但<code>dept_name</code><strong>不是</strong>一个<strong>超键</strong>。</li>
</ul>
</li>
<li><strong>注意</strong>：将<code>in_dept</code>分解为<code>instructor</code>和<code>department</code>：<ul>
<li><code>instructor (ID, name, salary, dept_name)</code> 属于BCNF。</li>
<li><code>department (dept_name, building, budget)</code> 属于BCNF。</li>
</ul>
</li>
</ul>
<h4 id="将模式分解为BCNF"><a href="#将模式分解为BCNF" class="headerlink" title="将模式分解为BCNF"></a>将模式分解为BCNF</h4><ul>
<li>设<code>R</code>是一个不属于BCNF的模式。设<code>α → β</code>是导致违反BCNF的FD。</li>
<li>将<code>R</code>分解为：<ol>
<li><code>(α ∪ β)</code> （<code>α → β</code>组成单独模式）</li>
<li><code>(R - (β - α))</code> （从<code>R</code>中去掉只出现在<code>α → β</code>的右部<code>β</code>，而没有出现在左部<code>α</code>的属性）</li>
</ol>
</li>
<li><code>(α ∪ β)</code> 和 <code>(R - (β - α))</code> 之间存在外键关联。</li>
<li><strong>示例</strong>：<code>in-dep (ID, name, salary, dept_name, building, budget)</code><ul>
<li><code>α = dept_name</code>, <code>β = building, budget</code></li>
<li><code>in_dep</code>被替换为：<ul>
<li><code>(α ∪ β) = (dept_name, building, budget)</code> （对应<code>department</code>）</li>
<li><code>(R - (β - α)) = (ID, name, dept_name, salary)</code> （对应<code>instructor</code>）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="BCNF与依赖保持"><a href="#BCNF与依赖保持" class="headerlink" title="BCNF与依赖保持"></a>BCNF与依赖保持</h4><ul>
<li><p><strong>并非总是可能同时实现BCNF和依赖保持</strong>。</p>
</li>
<li><p><strong>示例</strong>：考虑模式<code>dept_advisor (s_ID, i_ID, dept_name)</code>。</p>
<ul>
<li>具有FD：<code>i_ID → dept_name</code>；<code>s_ID, dept_name → i_ID</code>。</li>
<li>两个候选键：<code>{s_ID, dept_name}</code> 和 <code>{s_ID, i_ID}</code>。</li>
<li><code>dept_advisor</code>不属于BCNF，因为<code>i_ID</code>不是一个超键。</li>
</ul>
</li>
<li><p>我们需要将<code>dept_advisor</code>分解为两个BCNF模式：</p>
<ul>
<li><code>(s_ID, i_ID)</code></li>
<li><code>(i_ID, dept_name)</code></li>
</ul>
</li>
<li><p>任何这样的分解都<strong>不会</strong>包含<code>s_ID, dept_name → i_ID</code>中的所有属性。</p>
</li>
<li><p>因此，该分解<strong>不是</strong>依赖保持的。函数依赖<code>s_ID, dept_name → i_ID</code>只能通过分解后的关系的连接来检查。</p>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><code>R = {A, B, C}</code>， <code>F = {A → B, B → C}</code>。</li>
<li><code>R1 = {A, B}</code>, <code>R2 = {B, C}</code>。<ul>
<li>无损连接分解：<code>R1 ∩ R2 = {B}</code> 且 <code>B → BC</code>。</li>
<li>依赖保持。</li>
</ul>
</li>
<li><code>R1 = {A, B}</code>, <code>R2 = {A, C}</code>。<ul>
<li>无损连接分解：<code>R1 ∩ R2 = {A}</code> 且 <code>A → AB</code>。</li>
<li><strong>不是</strong>依赖保持的（不计算<code>R1</code>和<code>R2</code>的连接就无法检查<code>B → C</code>）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>注意</strong>：对FD的约束，在实践中检查成本很高，除非它们只<strong>涉及一个</strong>关系。</p>
</li>
<li><p>如果只需测试分解中每个单独关系上的FD就能确保<strong>所有</strong>FD都成立，那么该分解就是<strong>依赖保持的</strong>。</p>
</li>
<li><p><strong>注意</strong>：因为<strong>并非总是</strong>可能同时实现BCNF和依赖保持，我们考虑一个较弱的范式，称为<strong>第三范式</strong>。</p>
</li>
</ul>
<h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><ul>
<li><strong>定义</strong>：一个关系模式<code>R</code>属于<strong>第三范式</strong>，如果对于<code>F*</code>中所有的<code>α → β</code>，至少满足以下条件之一：<ol>
<li><code>α → β</code>是<strong>平凡的</strong>（即<code>β ⊆ α</code>）。</li>
<li><code>α</code>是<code>R</code>的一个<strong>超键</strong>。</li>
<li><code>β - α</code>中的每个属性都包含在<code>R</code>的某个候选键中。（即出现在右端但不出现在左端的属性）<ul>
<li>示例：<code>B → ABC</code>，<code>(ABC) - (B) = AC</code>。A和C可能分别出现在不同的候选键中。</li>
<li><strong>注意</strong>：每个属性可能在不同的候选键中。</li>
</ul>
</li>
</ol>
</li>
<li><strong>注意</strong>：如果一个关系属于BCNF，那么它也属于3NF。</li>
<li>如果<code>R</code>属于3NF，那么它也属于2NF。</li>
<li>3NF<strong>消除</strong>了非主属性对键的传递函数依赖。</li>
<li><strong>性质</strong>：<ul>
<li><code>R</code>也属于2NF。</li>
<li>不存在非主属性对候选键的部分和传递依赖。</li>
<li>每一个非主属性都不传递依赖于<code>R</code>的任何候选键。</li>
</ul>
</li>
</ul>
<h4 id="3NF示例"><a href="#3NF示例" class="headerlink" title="3NF示例"></a>3NF示例</h4><ul>
<li>考虑模式<code>R</code>：<code>dept_advisor (s_ID, i_ID, dept_name)</code>。</li>
<li>具有FD：<code>i_ID → dept_name</code>；<code>s_ID, dept_name → i_ID</code>。</li>
<li>两个候选键：<code>{s_ID, dept_name}</code>， <code>{s_ID, i_ID}</code>。</li>
<li><code>dept_advisor</code>不属于BCNF。</li>
<li>但是，<code>dept_advisor</code><strong>属于3NF</strong>：<ul>
<li><code>s_ID, dept_name</code>是一个超键。</li>
<li><code>i_ID → dept_name</code>成立，而<code>i_ID</code><strong>不是</strong>一个超键，但是：<ul>
<li><code>{dept_name} - {i_ID} = {dept_name}</code>，并且</li>
<li><code>dept_name</code>包含在一个候选键<code>{s_ID, dept_name}</code>中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3NF中的冗余"><a href="#3NF中的冗余" class="headerlink" title="3NF中的冗余"></a>3NF中的冗余</h4><ul>
<li>考虑以下属于3NF的模式<code>R</code>：<ul>
<li><code>R = {J, K, L}</code></li>
<li><code>F = {JK → L, L → K}</code></li>
</ul>
</li>
<li><strong>问题</strong>：<ul>
<li><strong>信息重复</strong>：当某个<code>L</code>值（例如<code>l1</code>）指导多名学生（对应多个<code>J</code>值）时，其关联的<code>K</code>值会重复。</li>
<li><strong>需要使用空值</strong>：例如，为了表示关系<code>(l2, k2)</code>，其中没有对应的<code>J</code>值（即某个教师没有指导学生），则<code>J</code>列必须为<code>null</code>。</li>
</ul>
</li>
<li>映射到<code>dept_advisor</code>示例：<code>J</code>对应<code>s_ID</code>，<code>L</code>对应<code>i_ID</code>，<code>K</code>对应<code>dept_name</code>。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">J (s_ID)</th>
<th align="left">L (i_ID)</th>
<th align="left">K (dept_name)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">j1</td>
<td align="left">l1</td>
<td align="left">k1</td>
</tr>
<tr>
<td align="left">j2</td>
<td align="left">l1</td>
<td align="left">k1</td>
</tr>
<tr>
<td align="left">j3</td>
<td align="left">l1</td>
<td align="left">k1</td>
</tr>
<tr>
<td align="left">null</td>
<td align="left">l2</td>
<td align="left">k2</td>
</tr>
</tbody></table>
<h3 id="BCNF与3NF的比较"><a href="#BCNF与3NF的比较" class="headerlink" title="BCNF与3NF的比较"></a>BCNF与3NF的比较</h3><ul>
<li><strong>3NF相对于BCNF的优点</strong>：总是可以在不牺牲无损连接性或依赖保持性的情况下获得一个3NF设计。<ul>
<li>3NF分解可以保证无损连接、函数依赖保持。</li>
<li>BCNF分解保证无损连接，但不保证函数依赖保持。</li>
</ul>
</li>
<li><strong>3NF的缺点</strong>：<ul>
<li>我们可能不得不使用空值来表示数据项之间一些可能的有意义的关系。</li>
<li>存在信息重复的问题。</li>
</ul>
</li>
</ul>
<h3 id="规范化的目标"><a href="#规范化的目标" class="headerlink" title="规范化的目标"></a>规范化的目标</h3><ul>
<li>设<code>R</code>是一个具有FD集合<code>F</code>的关系模式。</li>
<li>决定一个关系模式<code>R</code>是否形式良好。</li>
<li>当一个关系模式<code>R</code>形式不佳时，将其分解为<code>{R1, R2, ..., Rn}</code>，使得：<ul>
<li>每个关系模式<strong>形式良好</strong>，例如属于2NF、3NF、BCNF。</li>
<li>该分解是<strong>无损分解</strong>。</li>
<li>该分解应该是<strong>依赖保持的</strong>。</li>
</ul>
</li>
</ul>
<h3 id="范式总结"><a href="#范式总结" class="headerlink" title="范式总结"></a>范式总结</h3><ul>
<li><strong>1NF</strong>：属性原子。</li>
<li><strong>2NF</strong>：消除非主属性对键的<strong>部分函数依赖</strong>。</li>
<li><strong>3NF</strong>：消除非主属性对键的<strong>传递函数依赖</strong>。</li>
<li><strong>BCNF</strong>：消除<strong>所有属性</strong>（包括主属性和非主属性）对键的部分和传递依赖。更严格：所有非平凡的FD，其左部必须是超键。</li>
</ul>
<hr>
<h2 id="7-4-函数依赖理论"><a href="#7-4-函数依赖理论" class="headerlink" title="7.4 函数依赖理论"></a>7.4 函数依赖理论</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ol>
<li>由给定FD集合逻辑蕴含的FD（Armstrong公理）。</li>
<li>开发算法，生成到BCNF和3NF的无损分解。</li>
<li>开发算法，测试分解是否是依赖保持的。</li>
</ol>
<h3 id="函数依赖间的逻辑蕴含"><a href="#函数依赖间的逻辑蕴含" class="headerlink" title="函数依赖间的逻辑蕴含"></a>函数依赖间的逻辑蕴含</h3><ul>
<li>给定一个FD集合<code>F</code>，存在其他被<code>F</code>逻辑蕴含的FD <code>f</code>。</li>
<li><strong>示例</strong>：如果<code>A → B</code>且<code>B → C</code>，则可推断<code>A → C</code>。</li>
<li><strong>定义</strong>：给定模式<code>R</code>，一个FD <code>f</code>被FD集合<code>F</code><strong>逻辑蕴含</strong>，如果每个满足<code>F</code>的实例<code>r(R)</code>也都满足<code>f</code>。<ul>
<li><code>{f} = {A → B, B → C}* = {A → B, B → C, A → C, ...}</code></li>
</ul>
</li>
<li><strong>定义</strong>：被<code>F</code>逻辑蕴含的所有FD的集合称为<code>F</code>的闭包。用<code>F+</code>表示<code>F</code>的闭包。<ul>
<li><code>F+ = {f | f 被 F 逻辑蕴含}</code>。</li>
</ul>
</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>F = {A → B, B → C}</code>;<br><code>f: A → C</code> 被<code>F</code>逻辑蕴含。</p>
<h3 id="函数依赖集的闭包"><a href="#函数依赖集的闭包" class="headerlink" title="函数依赖集的闭包"></a>函数依赖集的闭包</h3><ul>
<li>通过重复应用Armstrong公理计算<code>F</code>的闭包<code>F+</code>：<ol>
<li><strong>自反律</strong>：如果<code>β ⊆ α</code>，则<code>α → β</code>。</li>
<li><strong>增广律</strong>：如果<code>α → β</code>，则<code>γα → γβ</code>。</li>
<li><strong>传递律</strong>：如果<code>α → β</code>，且<code>β → γ</code>，则<code>α → γ</code>。</li>
</ol>
</li>
<li>这些规则是：<ul>
<li><strong>健全的</strong>：只生成实际成立的FD。</li>
<li><strong>完备的</strong>：生成所有成立的FD。</li>
</ul>
</li>
<li><strong>附加规则</strong>（可从上述公理推导）：<ul>
<li><strong>合并律</strong>：如果<code>α → β</code>成立且<code>α → γ</code>成立，则<code>α → βγ</code>成立。</li>
<li><strong>分解律</strong>：如果<code>α → βγ</code>成立，则<code>α → β</code>成立且<code>α → γ</code>成立。</li>
<li><strong>伪传递律</strong>：如果<code>α → β</code>成立且<code>γβ → δ</code>成立，则<code>αγ → δ</code>成立。</li>
</ul>
</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><ul>
<li><code>R = {A, B, C, G, H, I}</code></li>
<li><code>F = {A → B, A → C, CG → H, CG → I, B → H}</code></li>
<li><strong>F+中的一些成员</strong>：<ul>
<li><code>A → H</code>：根据<code>A → B</code>和<code>B → H</code>的传递性。</li>
<li><code>AG → I</code>：用<code>G</code>增广<code>A → C</code>得到<code>AG → CG</code>，然后与<code>CG → I</code>传递得到。</li>
<li><code>CG → HI</code>：增广<code>CG → I</code>推导出<code>CG → CGI</code>，增广<code>CG → H</code>推导出<code>CGI → HI</code>，然后传递。</li>
</ul>
</li>
</ul>
<h3 id="属性集的闭包"><a href="#属性集的闭包" class="headerlink" title="属性集的闭包"></a>属性集的闭包</h3><ul>
<li><strong>定义</strong>：在<code>F</code>下，如果<code>α → B</code>在<code>F</code>下成立，则属性<code>B</code>被<code>α</code><strong>函数确定</strong>。记作 <code>α |-F-&gt; B</code>。</li>
<li><strong>定义</strong>：给定一个属性集<code>α</code>，<code>α</code>在<code>F</code>下的闭包（记作<code>α+</code>）是被<code>α</code>在<code>F</code>下函数确定的属性集合。<ul>
<li><code>α+ = {β | β 被 α 在 F 下函数确定} = {β | α |-F-&gt; β}</code></li>
</ul>
</li>
</ul>
<h4 id="属性集闭包算法"><a href="#属性集闭包算法" class="headerlink" title="属性集闭包算法"></a>属性集闭包算法</h4><ul>
<li><strong>输入</strong>：<code>α</code>， <code>F</code></li>
<li><strong>输出</strong>：<code>α+</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result := α;</span><br><span class="line">while (result 发生改变) do</span><br><span class="line">    for each β → γ in F do</span><br><span class="line">        if β ⊆ result then result := result ∪ γ</span><br></pre></td></tr></table></figure>

<h4 id="属性集闭包示例"><a href="#属性集闭包示例" class="headerlink" title="属性集闭包示例"></a>属性集闭包示例</h4><ul>
<li><code>R = {A, B, C, G, H, I}</code></li>
<li><code>F = {A → B, A → C, CG → H, CG → I, B → H}</code></li>
<li>计算<code>(AG)+</code>：<ol>
<li><code>result = AG</code></li>
<li><code>result = ABCG</code> （<code>A → C</code> 和 <code>A → B</code>）</li>
<li><code>result = ABCGH</code> （<code>CG → H</code> 且 <code>CG ⊆ AGBCH</code>）</li>
<li><code>result = ABCGHI</code> （<code>CG → I</code> 且 <code>CG ⊆ AGBCH</code>）</li>
</ol>
</li>
<li><code>(AG)+ = R</code>，所以<code>AG</code>是<code>R</code>的一个<strong>超键</strong>。</li>
<li><strong>问题</strong>：<code>AG</code>是候选键吗？<ol>
<li><code>AG</code>是超键吗？是。</li>
<li><code>AG</code>的任何子集是超键吗？<ul>
<li>计算<code>(A)+</code>：<code>(A)+ = {A, B, C, H}</code> ≠ <code>R</code>，所以<code>A</code>不是超键。</li>
<li>计算<code>(G)+</code>：<code>(G)+ = {G}</code> ≠ <code>R</code>，所以<code>G</code>不是超键。</li>
</ul>
</li>
<li>因此，<code>AG</code>是一个候选键。</li>
</ol>
</li>
</ul>
<h4 id="属性闭包算法的用途"><a href="#属性闭包算法的用途" class="headerlink" title="属性闭包算法的用途"></a>属性闭包算法的用途</h4><ol>
<li><strong>测试超键</strong>：要测试<code>α</code>是否是超键，计算<code>α+</code>并检查<code>α+</code>是否包含<code>R</code>的所有属性。</li>
<li><strong>测试FD</strong>：要检查FD <code>α → β</code>是否成立（即是否在<code>F+</code>中），只需检查<code>β ⊆ α+</code>。<ul>
<li><strong>注意</strong>：通过属性闭包计算<code>α+</code>，然后检查它是否包含<code>β</code>。</li>
</ul>
</li>
</ol>
<h3 id="FD集合的等价"><a href="#FD集合的等价" class="headerlink" title="FD集合的等价"></a>FD集合的等价</h3><ul>
<li><strong>定义</strong>：对于两个FD集合<code>F</code>和<code>G</code>，如果<code>F+ = G+</code>，则<code>F</code>和<code>G</code>是<strong>等价的</strong>。</li>
<li><strong>示例</strong>：<code>F = {A → B, B → C}</code> 等价于 <code>G = {A → B, B → C, A → C}</code>。</li>
</ul>
<h3 id="正则覆盖"><a href="#正则覆盖" class="headerlink" title="正则覆盖"></a>正则覆盖</h3><ul>
<li><strong>动机</strong>：当用户对<code>R</code>执行<strong>更新</strong>时，DBS必须确保该更新不会<strong>违反</strong>任何FD。所有在<code>F</code>中的FD都必须被DBS满足，通常通过执行检查约束、断言、触发器或更复杂的SQL语句来实现，成本很高。<ul>
<li>例如，更新<code>Student_grade</code>， <code>set grade = grade + 10</code>，要求<code>grade</code>在0到100之间。如果更新前的值为60,70,80,90,100，更新后70,80,90,100,110，最后一条记录违反了约束。</li>
</ul>
</li>
<li>检查<code>R</code>上所有<code>α → β</code>是否成立是耗时的。<ul>
<li><code>F</code>中可能有<strong>冗余</strong>的依赖，可以从其他依赖推导出来。</li>
<li>例如，在<code>{A → B, B → C, A → C}</code>中，<code>A → C</code>是冗余的。</li>
</ul>
</li>
<li><strong>正则覆盖</strong>：简化后的集合称为<strong>正则覆盖</strong>。我们希望测试一个与<code>F</code>等价的<strong>最小</strong>FD集合。</li>
<li><strong>定义1</strong>：<code>F</code>的一个<strong>正则覆盖</strong> <code>Fc</code> 是一个与<code>F</code>等价的<strong>最小</strong>FD集合，没有冗余的FD或属性。<ul>
<li><code>F+ = Fc+</code></li>
</ul>
</li>
<li><strong>定义2：冗余FD</strong>：冗余FD可以从<code>F</code>中的其他FD推断出来。</li>
</ul>
<h4 id="无关属性和无关FD"><a href="#无关属性和无关FD" class="headerlink" title="无关属性和无关FD"></a>无关属性和无关FD</h4><ul>
<li><strong>定义3：无关属性</strong>：如果我们可以删除FD中的一个属性而不改变<code>F+</code>，则该属性是<strong>无关的</strong>。</li>
<li><strong>动机</strong>：FD左边或右边的属性可能是无关的。</li>
<li><strong>性质1</strong>：从FD的左边移除一个属性可能会使它成为一个<strong>更强的</strong>约束。<ul>
<li>例如，如果我们有<code>AB → C</code>并移除<code>B</code>，我们得到可能更强的结果<code>A → C</code>。因为<code>AB → BC</code>逻辑蕴含<code>AB → C</code>，但<code>AB → C</code>不逻辑蕴含<code>A → C</code>。</li>
<li>但是，根据FD集合<code>F</code>的具体情况，我们可能可以安全地从<code>AB → C</code>中移除<code>B</code>。假设<code>F = {AB → C, A → D, D → C}</code>。证明<code>F</code>逻辑蕴含<code>A → C</code>，使得<code>B</code>在<code>AB → C</code>中是无关的。</li>
</ul>
</li>
<li><strong>性质2</strong>：从FD的右边移除一个属性可能会使它成为一个<strong>更弱的</strong>约束。<ul>
<li>例如，如果我们有<code>AB → CD</code>并移除<code>C</code>，我们得到可能更弱的结果<code>AB → D</code>。</li>
<li>但是，根据FD集合<code>F</code>的具体情况，我们可能可以安全地从<code>AB → CD</code>中移除<code>C</code>。</li>
<li>例如，假设<code>F = {AB → CD, A → C} = {AB → CD, AB → BC}</code>。在用<code>AB → D</code>替换<code>AB → CD</code>后，我们仍然可以推断出<code>AB → C</code>，从而<code>AB → CD</code>。</li>
</ul>
</li>
</ul>
<h4 id="测试一个属性是否无关"><a href="#测试一个属性是否无关" class="headerlink" title="测试一个属性是否无关"></a>测试一个属性是否无关</h4><ul>
<li>考虑FD <code>α → β</code>中的属性<code>B ∈ β</code>。<ul>
<li><strong>测试<code>B</code>在<code>β</code>中是否无关</strong>：<ul>
<li>考虑集合 <code>F&#39; = (F - {α → β}) ∪ {α → (β - B)}</code>。</li>
<li>检查在<code>F&#39;</code>下<code>α+</code>是否包含<code>B</code>（即<code>B ∈ α+</code>）。</li>
<li>如果是，则<code>B</code>在<code>β</code>中是无关的。</li>
</ul>
</li>
</ul>
</li>
<li>考虑FD <code>α → β</code>中的属性<code>A ∈ α</code>。<ul>
<li><strong>测试<code>A</code>在<code>α</code>中是否无关</strong>：<ul>
<li>令 <code>γ = α - {A}</code>。检查<code>γ → β</code>是否可以从<code>F</code>推断出来。</li>
<li>使用<code>F</code>中的DF计算<code>γ+</code>。</li>
<li>如果<code>γ+</code>包含<code>β</code>中的所有属性（即<code>β ⊆ γ+</code>），那么<code>A</code>在<code>α</code>中是无关的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="无关属性示例"><a href="#无关属性示例" class="headerlink" title="无关属性示例"></a>无关属性示例</h4><ul>
<li><strong>例1</strong>：给定<code>F = {A → C, AB → C}</code>。<code>B</code>在<code>AB → C</code>中是无关的，因为<code>{A → C, AB → C}</code>逻辑蕴含<code>A → C</code>。</li>
<li><strong>例2</strong>：给定<code>F = {A → C, AB → CD}</code>。<code>C</code>在<code>AB → CD</code>中是无关的，因为删除<code>C</code>后，仍然可以从其他依赖推断出<code>AB → C</code>。</li>
<li><strong>例3</strong>：<code>F = {AB → CD, A → E, E → C}</code>。检查<code>C</code>在<code>AB → CD</code>中是否无关。<ul>
<li><strong>步骤1</strong>：计算<code>AB</code>在<code>F&#39; = {AB → D, A → E, E → C}</code>下的闭包。</li>
<li><strong>步骤2</strong>：闭包是<code>ABCDE</code>，包含<code>C</code>。</li>
<li><strong>结论</strong>：<code>C</code>是无关的。</li>
</ul>
</li>
</ul>
<h4 id="正则覆盖定义与计算"><a href="#正则覆盖定义与计算" class="headerlink" title="正则覆盖定义与计算"></a>正则覆盖定义与计算</h4><ul>
<li><strong>定义4</strong>：<code>F</code>的一个正则覆盖<code>Fc</code>是一个满足以下条件的FD集合：<ol>
<li><code>F</code>逻辑蕴含<code>Fc</code>中的所有依赖。</li>
<li><code>Fc</code>逻辑蕴含<code>F</code>中的所有依赖。</li>
<li><code>Fc</code>中不包含无关属性。</li>
<li><code>Fc</code>中每个FD的左部是唯一的。不存在两个FD <code>α1 → β1</code>和<code>α2 → β2</code>使得<code>α1 = α2</code>。</li>
</ol>
</li>
<li><strong>计算</strong><code>F</code>的正则覆盖：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fc = F</span><br><span class="line">repeat</span><br><span class="line">    使用合并律，将Fc中形式为α1 → β1和α1 → β2的FD替换为α1 → β1β2。</span><br><span class="line">    在Fc中找到一个FD α → β，它在α或β中有一个无关属性。</span><br><span class="line">    如果找到了无关属性，将其从α → β中删除。</span><br><span class="line">until (Fc不再改变)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意1</strong>：在删除一些无关属性后，合并律可能变得适用。</li>
<li><strong>注意2</strong>：一个FD集合<code>F</code>可能有多个正则覆盖<code>Fc</code>。</li>
</ul>
<h4 id="正则覆盖计算示例"><a href="#正则覆盖计算示例" class="headerlink" title="正则覆盖计算示例"></a>正则覆盖计算示例</h4><ul>
<li><code>R = {A, B, C}</code></li>
<li><code>F = {A → BC, B → C, A → B, AB → C}</code></li>
<li><strong>步骤1</strong>：使用合并律将<code>A → BC</code>和<code>A → B</code>合并为<code>A → BC</code>。<ul>
<li>集合变为<code>F1 = {A → BC, B → C, AB → C}</code>。</li>
</ul>
</li>
<li><strong>步骤2</strong>：<code>A</code>在<code>AB → C</code>中是无关的。<ul>
<li>检查从<code>AB → C</code>中删除<code>A</code>的结果是否被其他依赖蕴含。是的：<code>B → C</code>已经存在！</li>
<li>集合变为<code>F2 = {A → BC, B → C}</code>。</li>
</ul>
</li>
<li><strong>步骤3</strong>：<code>C</code>在<code>A → BC</code>中是无关的。<ul>
<li>检查<code>A → C</code>是否被<code>A → B</code>和其他依赖逻辑蕴含。是的：使用<code>A → B</code>和<code>B → C</code>的传递性。</li>
</ul>
</li>
<li><strong>结论</strong>：正则覆盖是：<code>Fc = {A → B, B → C}</code>。</li>
</ul>
<h3 id="无损连接分解"><a href="#无损连接分解" class="headerlink" title="无损连接分解"></a>无损连接分解</h3><ul>
<li>对于<code>R = (R1, R2)</code>，我们要求对于模式<code>R</code>上所有可能的关系<code>r</code>，都有 <code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li>
<li>将<code>R</code>分解为<code>R1</code>和<code>R2</code>是无损连接的，如果以下依赖中至少有一个在<code>F*</code>中：<ul>
<li><code>R1 ∩ R2 → R1</code></li>
<li><code>R1 ∩ R2 → R2</code></li>
</ul>
</li>
<li><strong>注意</strong>：上述FD是无损连接分解的<strong>充分条件</strong>；只有当所有约束都是FD时，这些依赖才是<strong>必要条件</strong>。</li>
<li><strong>不同于表间存在外键关联</strong>：无损连接是一个更广义的概念。</li>
</ul>
<h3 id="依赖保持"><a href="#依赖保持" class="headerlink" title="依赖保持"></a>依赖保持</h3><ul>
<li><strong>定义1</strong>：对于模式<code>R</code>，<code>F</code>在<code>R</code>上成立，以及<code>R</code>的分解<code>{R1, R2, ..., Rn}</code>：<ul>
<li><code>F</code>到<code>Ri</code>的<strong>限制</strong>，记作<code>Fi</code>，定义为 <code>Fi = {α → β | α → β ∈ F+ 且 αβ ⊆ Ri}</code>。<ul>
<li>这是<code>F+</code>中仅包含<code>Ri</code>中属性的FD集合。</li>
</ul>
</li>
</ul>
</li>
<li><strong>定义2</strong>：设<code>Fi</code>是<code>F</code>到<code>Ri</code>的限制。如果 <code>(F1 ∪ F2 ∪ ... ∪ Fn)+ = F+</code>，则分解是<strong>依赖保持的</strong>。</li>
<li><strong>注意</strong>：测试依赖保持是指数时间的。</li>
</ul>
<h4 id="依赖保持测试算法"><a href="#依赖保持测试算法" class="headerlink" title="依赖保持测试算法"></a>依赖保持测试算法</h4><ul>
<li><strong>测试</strong>：FD <code>α → β</code>在分解<code>R = {R1, R2, ..., Rn}</code>中是否被保持？</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = α</span><br><span class="line">repeat</span><br><span class="line">    for each Ri in the decomposition</span><br><span class="line">        t = ((result ∩ Ri)+ ∩ Ri) // 在F下计算(result ∩ Ri)的闭包，然后与Ri取交集</span><br><span class="line">        result = result ∪ t</span><br><span class="line">until (result不再改变)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果<strong>result</strong>包含<code>β</code>中的所有属性，则FD <code>α → β</code>被保持。</li>
<li>对所有FD进行测试以检查分解是否是依赖保持的。</li>
<li>该过程需要多项式时间。</li>
</ul>
<h4 id="依赖保持示例"><a href="#依赖保持示例" class="headerlink" title="依赖保持示例"></a>依赖保持示例</h4><ul>
<li><strong>例1</strong>：<code>R (A, B, C, D)</code>， <code>F = {A → B, B → C, A → D, B → D}</code> 在<code>R</code>上。<ul>
<li><code>F+ = F ∪ {A → C} ∪ ...</code></li>
<li>无损分解：<code>R1(A, B, C)</code>， <code>F1 = {A → B, B → C}</code>；<code>R2(B, D)</code>， <code>F2 = {B → D}</code>。</li>
<li><strong>问题</strong>：<code>A → D</code>是否被保持？</li>
<li><code>A |-F1-&gt; B</code>， <code>B |-F2-&gt; D</code>，所以<code>A → D</code>被保持。</li>
</ul>
</li>
<li><strong>例2</strong>：<code>Student (sno, dept, head)</code>， <code>F = {sno → dept, dept → head}</code>。<ul>
<li><code>F+ = F ∪ {sno → head} ∪ {...}</code></li>
<li><strong>分解1</strong>：<code>R1(sno, dept)</code>， <code>F1 = {sno → dept}</code>；<code>R2(sno, head)</code>， <code>F2 = {sno → head}</code>。<ul>
<li><strong>无损</strong>，因为<code>R1 ∩ R2 = {sno}</code>，是<code>R1</code>和<code>R2</code>的键。</li>
<li><strong>非依赖保持</strong>，因为<code>(F1 ∪ F2)+ ≠ F+</code>，<strong>dept → head</strong>丢失了。</li>
<li><strong>原因</strong>：对于<code>F</code>中的<strong>dept → head</strong>，使用算法：<ul>
<li>关于<code>R1</code>：<code>result = (dept ∩ {sno, dept})+ ∩ {sno, dept} = {dept}+ ∩ {sno, dept} = {dept, head} ∩ {sno, dept} = {dept}</code>。</li>
<li>关于<code>R2</code>：<code>result = (dept ∩ {sno, head})+ ∩ {sno, head} = ∅+ ∩ {sno, head} = ∅</code>。</li>
<li>最终<code>result = {dept}</code>，不包含<code>head</code>，所以该FD未被保持。</li>
</ul>
</li>
</ul>
</li>
<li><strong>分解2</strong>：<code>R1(sno, dept)</code>， <code>F1 = {sno → dept}</code>；<code>R2(dept, head)</code>， <code>F2 = {dept → head}</code>。<ul>
<li><strong>无损连接</strong>，因为<code>R1 ∩ R2 = {dept}</code>，并且是<code>R2</code>的键。</li>
<li><strong>依赖保持</strong>，因为<code>(F1 ∪ F2)+ = F+</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="7-5-使用函数依赖的分解算法"><a href="#7-5-使用函数依赖的分解算法" class="headerlink" title="7.5 使用函数依赖的分解算法"></a>7.5 使用函数依赖的分解算法</h2><h3 id="内容概览-1"><a href="#内容概览-1" class="headerlink" title="内容概览"></a>内容概览</h3><ul>
<li>测试BCNF</li>
<li>BCNF分解</li>
<li>BCNF分解算法</li>
<li>测试3NF</li>
<li>3NF分解</li>
<li>3NF分解算法</li>
</ul>
<h3 id="测试关系是否属于BCNF"><a href="#测试关系是否属于BCNF" class="headerlink" title="测试关系是否属于BCNF"></a>测试关系是否属于BCNF</h3><ul>
<li><strong>方法</strong>：要判断FD <code>α → β</code>是否导致违反BCNF：<ol>
<li>计算<code>α+</code>（<code>α</code>的属性闭包）。</li>
<li>验证它是否包含<code>R</code>的所有属性，即它是否是<code>R</code>的超键。</li>
</ol>
</li>
<li><strong>简化测试</strong>：要检查一个关系模式<code>R</code>是否属于BCNF，只需检查<code>F</code>中（而不是<code>F+</code>中）的每个FD是否违反BCNF即可。<ul>
<li>如果<code>F</code>中没有FD导致违反BCNF，那么<code>F+</code>中也没有FD会导致违反BCNF。</li>
</ul>
</li>
<li><strong>注意</strong>：当测试<strong>R的分解</strong>中的关系时，仅使用<code>F</code>的简化测试是<strong>不正确</strong>的。<ul>
<li><strong>示例</strong>：<code>R = {A, B, C, D, E}</code>， <code>F = {A → B, BC → D}</code>。<ul>
<li>将<code>R</code>分解为<code>R1 = {A, B}</code>和<code>R2 = {A, C, D, E}</code>。</li>
<li><code>F</code>中的FD都不只包含<code>{A, C, D, E}</code>中的属性，所以我们可能误以为<code>R2</code>满足BCNF。</li>
<li>事实上，<code>F+</code>中的FD <code>AC → D</code>表明<code>R2</code>不属于BCNF（因为<code>AC</code>不是<code>R2</code>的超键）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="测试分解中的关系是否属于BCNF"><a href="#测试分解中的关系是否属于BCNF" class="headerlink" title="测试分解中的关系是否属于BCNF"></a>测试分解中的关系是否属于BCNF</h3><ul>
<li>要么使用<code>Fi</code>（<code>F+</code>到<code>Ri</code>的限制）来测试<code>Ri</code>。</li>
<li>要么使用原始FD集合<code>F</code>，但进行如下测试：对于每个属性集<code>α ⊆ Ri</code>，检查<code>α+</code>要么不包含<code>Ri - α</code>中的任何属性，要么包含<code>Ri</code>的所有属性。</li>
</ul>
<h3 id="BCNF分解算法"><a href="#BCNF分解算法" class="headerlink" title="BCNF分解算法"></a>BCNF分解算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：关系模式 R，以及在其上成立的 FD 集合 F。</span><br><span class="line">输出：R 的一个无损 BCNF 分解。</span><br><span class="line"></span><br><span class="line">result := &#123;R&#125;;</span><br><span class="line">done := false;</span><br><span class="line">while (not done) do</span><br><span class="line">    if (result 中存在一个不属于 BCNF 的子模式 Ri)</span><br><span class="line">    then begin</span><br><span class="line">        令 α → β 是 Ri 上成立的一个 FD，使得：</span><br><span class="line">            (1) α 不是 Ri 的超键（由于 α → β，并且关于 F 在 R 上的限制）。</span><br><span class="line">            (2) α → β 是非平凡的（即 β ⊈ α）。</span><br><span class="line">        用两个子模式替换 result 中的 Ri：</span><br><span class="line">            (α ∪ β) 和 (Ri - β)</span><br><span class="line">        result := (result - &#123;Ri&#125;) ∪ &#123;(Ri - β), (α ∪ β)&#125;;</span><br><span class="line">    end</span><br><span class="line">    else done := true;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：<ul>
<li>如何判断<code>Ri</code>是否属于BCNF？检查是否有非平凡FD <code>α → β</code>在<code>Ri</code>上成立，且<code>α</code>不是<code>Ri</code>的超键。</li>
<li>算法将非BCNF的<code>Ri</code>替换为<code>(Ri - β)</code>和<code>(α, β)</code>。<code>Ri</code>被分解为<code>(Ri - β)</code>和属于BCNF的<code>(α, β)</code>。</li>
<li><code>F</code>到模式<code>{α, β}</code>的限制是<code>α → β</code>，且<code>α</code>是<code>(α, β)</code>的超键，所以<code>(α, β)</code>属于BCNF。</li>
</ul>
</li>
</ul>
<h4 id="BCNF分解示例"><a href="#BCNF分解示例" class="headerlink" title="BCNF分解示例"></a>BCNF分解示例</h4><ul>
<li><strong>例1</strong>：<ul>
<li><code>R = {A, B, C}</code></li>
<li><code>F = {A → B, B → C}</code></li>
<li>键 &#x3D; <code>{A}</code></li>
<li><code>R</code>不属于BCNF（<code>B → C</code>成立但<code>B</code>不是超键）。</li>
<li><strong>分解</strong>：<ul>
<li>由于<code>B → C</code>违反BCNF（<code>B</code>不是超键），将<code>R</code>分解为：<ul>
<li><code>R1 = {B, C}</code>， <code>F1 = {B → C}</code></li>
<li><code>R2 = {A, B}</code>， <code>F2 = {A → B}</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>例2</strong>：<ul>
<li><code>class (course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code></li>
<li>FDs:<ul>
<li><code>course_id → title, dept_name, credits</code></li>
<li><code>building, room_number → capacity</code></li>
<li><code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li>
</ul>
</li>
<li>候选键：<code>{course_id, sec_id, semester, year}</code>（计算过程略）。</li>
<li><strong>BCNF分解</strong>：<ul>
<li>FD <code>course_id → title, dept_name, credits</code> 成立，但 <code>course_id</code> 不是超键。将 <code>class</code> 替换为：<ul>
<li><code>course (course_id, title, dept_name, credits)</code> （属于BCNF，<code>course_id</code>是候选键）</li>
<li><code>class-1 (course_id, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code></li>
</ul>
</li>
<li>检查 <code>class-1</code>：<ul>
<li>FDs: <code>building, room_number → capacity</code>；<code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li>
<li>候选键：<code>{course_id, sec_id, semester, year}</code></li>
<li><code>class-1</code>不属于BCNF，因为<code>building, room_number → capacity</code>成立，但<code>{building, room_number}</code>不是超键。</li>
<li>将<code>class-1</code>替换为：<ul>
<li><code>classroom (building, room_number, capacity)</code> （属于BCNF）</li>
<li><code>section (course_id, sec_id, semester, year, building, room_number, time_slot_id)</code> （属于BCNF）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>最终<code>class</code>被分解为<code>course</code>、<code>classroom</code>和<code>section</code>。</li>
</ul>
</li>
</ul>
<h4 id="BCNF分解可能无法保持依赖"><a href="#BCNF分解可能无法保持依赖" class="headerlink" title="BCNF分解可能无法保持依赖"></a>BCNF分解可能无法保持依赖</h4><ul>
<li><strong>例3</strong>：<ul>
<li><code>R = {J, K, L}</code></li>
<li><code>F = {JK → L, L → K}</code></li>
<li>两个候选键：<code>JK</code> 和 <code>JL</code></li>
<li><code>R</code>不属于BCNF（因为<code>L → K</code>成立，<code>L</code>不是超键）。</li>
<li>一个BCNF分解：<ul>
<li><code>R1 = {L, K}</code> 具有 <code>L → K</code>，</li>
<li><code>R2 = {J, L}</code> 没有FD。</li>
</ul>
</li>
<li><strong>问题</strong>：不保持依赖。<code>JK → L</code>丢失了。<code>R</code>的任何分解都无法保持<code>JK → L</code>。</li>
</ul>
</li>
</ul>
<h3 id="第三范式分解"><a href="#第三范式分解" class="headerlink" title="第三范式分解"></a>第三范式分解</h3><ul>
<li><strong>动机</strong>：<ul>
<li>有些情况下，BCNF不是依赖保持的，而检查FD违反很重要。</li>
<li><strong>解决方案</strong>：定义一个较弱的范式，3NF。它允许一些冗余，但存在到3NF的无损连接、依赖保持分解。</li>
</ul>
</li>
<li><strong>注意</strong>：应计算出<code>R</code>的所有候选键！</li>
</ul>
<h4 id="测试关系是否属于3NF"><a href="#测试关系是否属于3NF" class="headerlink" title="测试关系是否属于3NF"></a>测试关系是否属于3NF</h4><ul>
<li><strong>优化</strong>：只检查<code>F</code>中的FD，而不是<code>F+</code>中的所有FD。<ol>
<li>如果<code>α</code>是超键（使用属性闭包检查每个FD <code>α → β</code>）。</li>
<li>如果<code>α</code>不是超键，检查<code>β</code>中的<strong>每个属性</strong>是否包含在某个<strong>候选键</strong>中。</li>
</ol>
</li>
<li>测试是<strong>昂贵的</strong>，因为它涉及找到<strong>所有</strong>候选键。</li>
<li>测试3NF已被证明是NP-hard问题。</li>
<li>但是，<strong>分解</strong>到3NF可以在多项式时间内完成。</li>
</ul>
<h4 id="3NF分解算法"><a href="#3NF分解算法" class="headerlink" title="3NF分解算法"></a>3NF分解算法</h4><ul>
<li><strong>输入</strong>：关系模式<code>R</code>，在其上成立的FD集合<code>F</code>。</li>
<li><strong>输出</strong>：<code>R</code>的一个无损且依赖保持的3NF分解。</li>
<li><strong>步骤</strong>：<ol start="0">
<li><strong>找出<code>R</code>的所有候选键</strong>。</li>
<li>找出<code>F</code>的一个正则覆盖<code>Fc</code>。</li>
<li>对于<code>Fc</code>中的每个FD <code>α → β</code>，如果<code>αβ</code>还没有被包含在任何已生成的模式<code>Rj (1 ≤ j ≤ i)</code>中，则创建一个新的子模式<code>Ri := αβ</code>。</li>
<li>如果第2步生成的子模式中没有一个包含<code>R</code>的<strong>任一候选键</strong>，则挑选<code>R</code>的任意一个候选键，为其单独创建一个子模式<code>Ri</code>。</li>
<li>返回<code>(R1, R2, ..., Ri)</code>。</li>
</ol>
</li>
<li><strong>注意</strong>：<ul>
<li>只要有一个候选键包含在第2步构造出的某个子模式<code>Ri</code>中，就无需在第3步中为候选键单独构造子模式。</li>
<li>第3步中只需挑选<code>R</code>的<strong>一个</strong>候选键。</li>
</ul>
</li>
</ul>
<h4 id="3NF分解示例"><a href="#3NF分解示例" class="headerlink" title="3NF分解示例"></a>3NF分解示例</h4><ul>
<li><strong>例1</strong>：<ul>
<li>考虑模式<code>R(X, Y, Z, W)</code>，<code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code>在<code>R</code>上成立。给出一个无损、依赖保持的3NF分解。</li>
<li><strong>解法</strong>：<ul>
<li><strong>步骤1. 求候选键</strong>：<ul>
<li>使用附录7-1算法：L类&#x3D;{Y, W}，R类&#x3D;空，N类&#x3D;空，LR类&#x3D;{X, Z}。X_set&#x3D;{Y, W}，计算<code>(YW)+ = R</code>，所以<code>YW</code>是唯一的候选键。</li>
</ul>
</li>
<li><strong>步骤2. 求正则覆盖<code>Fc</code></strong>：<ul>
<li>原始<code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code>。</li>
<li>考虑<code>Y → XZ</code>中的<code>X</code>和<code>W → XZ</code>中的<code>Z</code>。</li>
<li><code>{X → Z, Z → X, Y → Z, W → X}</code> 蕴含 <code>F</code>，所以<code>Y → XZ</code>中的<code>X</code>和<code>W → XZ</code>中的<code>Z</code>都是无关属性。</li>
<li>因此，一个正则覆盖是 <code>Fc = {X → Z, Z → X, Y → Z, W → X}</code>。</li>
<li>（注意：<code>F</code>的其他正则覆盖还有：<code>{X → Z, Z → X, Y → X, W → Z}</code>， <code>{X → Z, Z → X, Y → X, W → X}</code>， <code>{X → Z, Z → X, Y → Z, W → Z}</code>）</li>
</ul>
</li>
<li><strong>步骤3. 根据算法生成子模式</strong>：<ul>
<li>对<code>Fc = {X → Z, Z → X, Y → Z, W → X}</code>中的每个FD：<ul>
<li><code>X → Z</code>：创建 <code>R1 = {X, Z}</code></li>
<li><code>Z → X</code>：已被<code>R1</code>包含（<code>XZ</code>）。</li>
<li><code>Y → Z</code>：创建 <code>R2 = {Y, Z}</code></li>
<li><code>W → X</code>：创建 <code>R3 = {W, X}</code></li>
</ul>
</li>
<li>检查候选键<code>YW</code>：它没有被任何现有子模式包含（<code>R1={X,Z}</code>, <code>R2={Y,Z}</code>, <code>R3={W,X}</code>）。</li>
<li>因此，为候选键<code>YW</code>创建 <code>R4 = {Y, W}</code>。</li>
</ul>
</li>
<li>一个3NF分解是：<code>{XZ, YZ, WX, YW}</code>。</li>
<li>如果使用其他正则覆盖，会得到不同的但等价的分解，例如：<code>{XZ, YX, WX, YW}</code>， <code>{XZ, YX, WZ, YW}</code>， <code>{XZ, YZ, WZ, YW}</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>例2</strong>：<ul>
<li><code>R {stNo, Name, Telno, stId, Classno, Cno, Cname, Grade}</code></li>
<li><code>F = {stNo → Name, Telno, stId, Classno, stId → stNo, stNo, Cno → Grade, Cno → Cname}</code></li>
<li><strong>所有候选键</strong>：<code>(stNo, Cno)</code>， <code>(stId, Cno)</code> （计算过程略）。</li>
<li><strong>R的最高范式</strong>？<ul>
<li>不属于BCNF，因为存在<code>stNo → ...</code>（左部不是超键），<code>stId → stNo</code>（左部不是超键），<code>Cno → Cname</code>（左部不是超键）。</li>
<li>不属于3NF，因为对于FD1 <code>stNo → Name, Telno, stId, Classno</code>，<code>α = stNo</code>不是超键，且<code>β - α</code>中的属性<code>{Name, Telno, stId, Classno}</code>不包含在任何候选键中（候选键是<code>(stNo, Cno)</code>和<code>(stId, Cno)</code>，这些属性不在键中）。</li>
</ul>
</li>
<li><strong>给出一个无损连接且依赖保持的3NF分解</strong>：<ul>
<li><code>Fc = F</code> （假设已是最小）。</li>
<li>对每个FD创建子模式：<ul>
<li><code>stNo → Name, Telno, stId, Classno</code>：<code>R1(stNo, Name, Telno, stId, Classno)</code></li>
<li><code>stId → stNo</code>：<code>stId, stNo</code>已包含在<code>R1</code>中。</li>
<li><code>stNo, Cno → Grade</code>：<code>R2(stNo, Cno, Grade)</code></li>
<li><code>Cno → Cname</code>：<code>R3(Cno, Cname)</code></li>
</ul>
</li>
<li>检查候选键：<code>(stNo, Cno)</code>已包含在<code>R2</code>中，因此无需为另一个候选键<code>(stId, Cno)</code>单独创建子模式。</li>
<li>分解为：<code>R1, R2, R3</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BCNF与3NF对比"><a href="#BCNF与3NF对比" class="headerlink" title="BCNF与3NF对比"></a>BCNF与3NF对比</h3><ul>
<li><strong>注意</strong>：总是可以将一个关系分解为一组属于3NF的关系，使得：<ul>
<li>分解是无损的。</li>
<li>依赖是保持的。</li>
</ul>
</li>
<li><strong>注意</strong>：总是可以将一个关系分解为一组属于BCNF的关系，使得：<ul>
<li>分解是无损的。</li>
<li>但可能无法保持依赖。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="附录7-1-计算候选键算法"><a href="#附录7-1-计算候选键算法" class="headerlink" title="附录7-1 计算候选键算法"></a>附录7-1 计算候选键算法</h2><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ul>
<li>如果属性<code>A</code>只出现在<code>F</code>中函数依赖的左部<code>α</code>，则<code>A</code>一定是主属性，必然出现在候选键中。</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><strong>输入</strong>：关系模式<code>R</code>及其函数依赖集<code>F</code>。</li>
<li><strong>输出</strong>：<code>R</code>的所有候选键。</li>
<li><strong>步骤</strong>：<ol>
<li>将<code>R</code>的所有属性分为四类：<ul>
<li><strong>L类</strong>：仅出现在<code>F</code>中函数依赖<strong>左部</strong>的属性。</li>
<li><strong>R类</strong>：仅出现在<code>F</code>中函数依赖<strong>右部</strong>的属性。</li>
<li><strong>N类</strong>：在<code>F</code>中函数依赖左右两边均<strong>未出现</strong>的属性。</li>
<li><strong>LR类</strong>：在<code>F</code>中函数依赖左右两边均<strong>出现</strong>的属性。</li>
</ul>
</li>
<li>令 <code>X_set = L类 ∪ N类</code>， <code>Y_set = LR类</code>。</li>
<li>计算<code>X_set+</code>：<ul>
<li>如果<code>X_set+ = R</code>，则<code>X_set</code>为<code>R</code>的唯一候选键。转到步骤5。</li>
<li>否则，转到步骤4。</li>
</ul>
</li>
<li>在<code>Y_set</code>中取一个属性<code>A</code>，计算<code>(X_set ∪ {A})+</code>。若它包含了<code>R</code>的所有属性，则转步骤4.1；否则，调换属性重复此过程，直到试完<code>Y_set</code>中的所有单个属性。<ul>
<li>4.1 如果已找出所有的候选键，则转步骤5。</li>
<li>否则，在<code>Y_set</code>中依次取两个、三个……属性，求其属性闭包，直至其闭包包含<code>R</code>的所有属性。注意排除已找到的候选键的超集。</li>
</ul>
</li>
<li>停止，输出结果。</li>
</ol>
</li>
</ul>
<h3 id="计算候选键示例"><a href="#计算候选键示例" class="headerlink" title="计算候选键示例"></a>计算候选键示例</h3><ul>
<li><strong>例1</strong>：<ul>
<li><code>R(X, Y, Z, W)</code>， <code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code></li>
<li>L类：<code>Y, W</code></li>
<li>R类：无</li>
<li>N类：无</li>
<li>LR类：<code>X, Z</code></li>
<li><code>X_set = {Y, W}</code>，计算<code>(YW)+ = R</code>，所以<code>YW</code>是候选键（也是唯一的）。</li>
</ul>
</li>
<li><strong>例2</strong>：<ul>
<li><code>R(B, D, I, O, Q, S)</code>， <code>F = {B → Q, I → S, IS → Q, S → D}</code></li>
<li>L类：<code>B, I</code></li>
<li>R类：<code>D, Q</code></li>
<li>N类：<code>O</code></li>
<li>LR类：<code>S</code></li>
<li><code>X_set = {B, I, O}</code>，计算<code>(BIO)+ = R</code>，所以<code>BIO</code>是一个候选键。</li>
</ul>
</li>
<li><strong>例3</strong>：<ul>
<li><code>R(A, B, C, D, E)</code>， <code>F = {AB → CE, E → AB, C → D}</code></li>
<li>步骤1：<code>X_set = ∅</code>（L类：无；N类：无），<code>Y_set = {A, B, C, E}</code>（LR类），R类：<code>D</code>。</li>
<li>步骤2：<code>X_set+ = ∅+ = ∅</code>，不为<code>R</code>。</li>
<li>步骤3：从<code>Y_set</code>中取单个属性：<ul>
<li><code>(A)+</code>，<code>(B)+</code>，<code>(C)+</code>都不等于<code>R</code>。</li>
<li><code>(E)+ = {E, A, B, C, D} = R</code>，所以<code>E</code>是一个候选键。</li>
</ul>
</li>
<li>继续寻找其他候选键（不包括E）：<ul>
<li>取两个属性（不包括E）：<code>AB</code>。<code>(AB)+ = R</code>，所以<code>AB</code>是一个候选键。</li>
<li>检查其他两个属性组合（如<code>BC</code>，<code>(BC)+</code>不含<code>A</code>或<code>E</code>，不等于<code>R</code>）。</li>
<li>取三个属性（不包括E，且不包含AB）：无法构成新的候选键。</li>
</ul>
</li>
<li>所以候选键是：<code>E</code>， <code>AB</code>。</li>
</ul>
</li>
<li><strong>例4</strong>：<ul>
<li><code>R(A, B, C, D, E)</code>， <code>F = {A → BC, CD → E, B → D, E → AB}</code></li>
<li>出现在左边的属性：<code>{A, C, D, B, E}</code>，出现在右边的属性：<code>{A, C, D, B, E}</code>。</li>
<li>L类：<code>{}</code>， R类：<code>{}</code>， LR类：<code>{A, C, D, B, E}</code>， N类：无。</li>
<li>计算候选键：<ul>
<li>测试<code>(A)+ = {A, B, C, D, E} = R</code>，所以<code>A</code>是候选键。</li>
<li>测试<code>(E)+ = {E, A, B, C, D} = R</code>，所以<code>E</code>是候选键。</li>
<li>测试<code>(C)+</code>，<code>(D)+</code>，<code>(B)+</code>都不等于<code>R</code>。</li>
<li>测试<code>(CD)+ = {C, D, E, A, B} = R</code>，所以<code>CD</code>是候选键。</li>
<li>测试<code>(BD)+</code>等不等于<code>R</code>。</li>
</ul>
</li>
<li>最终找到4个候选键：<code>A</code>， <code>E</code>， <code>CD</code>，还有？需要检查所有可能组合，例如<code>BC</code>？根据闭包计算，<code>(BC)+</code>可能等于<code>R</code>？<code>B → D</code>，<code>BC → D</code>，<code>CD → E</code>，<code>BC → CD</code>？实际上<code>(BC)+</code>可能包含<code>BCD</code>，然后<code>CD → E</code>，得到<code>BCDE</code>，然后<code>E → AB</code>，得到<code>ABCDE</code>，所以<code>BC</code>也是候选键？需要仔细计算。题目给出答案是4个，可能为<code>A, E, CD, BC</code>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="附录7-2-习题类型"><a href="#附录7-2-习题类型" class="headerlink" title="附录7-2 习题类型"></a>附录7-2 习题类型</h2><ol>
<li>给定关系表<code>r(R)</code>和若干函数依赖<code>α → β</code>，判断<code>r</code>是否满足<code>α → β</code>。</li>
<li>根据Armstrong公理系统，判断关于函数依赖的一些公式是否成立（例如，如果<code>A → B, B → C</code>，则<code>A → C</code>）。</li>
<li>根据文字描述，抽象出函数依赖关系。</li>
<li><strong>设计SQL语句，判断函数依赖和键</strong>。</li>
<li>利用算法，求候选键。</li>
<li>计算属性闭包<code>α+</code>。</li>
<li>计算函数依赖集<code>F</code>的最小正则集<code>Fc</code>。</li>
<li>给定关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，判断<code>R</code>属于第几范式，为什么？（只考虑1NF, 2NF, 3NF, BCNF）</li>
<li>判断一个模式分解是否为无损连接（使用定理）、函数依赖保持（使用定义或算法）。</li>
<li>给定非3NF的关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，将<code>R</code>分解为第三范式。</li>
<li>给定非BCNF的关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，将<code>R</code>分解为BCNF范式。</li>
</ol>
<hr>
<h2 id="本章结构总结"><a href="#本章结构总结" class="headerlink" title="本章结构总结"></a>本章结构总结</h2><ul>
<li><strong>I. 良好关系设计的特征 (7.1)</strong>：为什么需要规范化？良好模式？（模式修改中的问题）。</li>
<li><strong>II. 使用函数依赖进行分解 (7.2)</strong>：分解、无损分解、规范化原则、键和函数依赖、无损分解和函数依赖。</li>
<li><strong>III. 范式 (7.3)</strong>：良好模式的标准。定义：BCNF、3NF、2NF、依赖保持、属性与关系。</li>
<li><strong>IV. 函数依赖理论 (7.4)</strong>：闭包、逻辑蕴含、属性集闭包、正则覆盖、无损连接分解、依赖保持。</li>
<li><strong>V. 使用函数依赖的分解算法 (7.5)</strong>：BCNF和3NF的分解算法。</li>
<li><strong>VI. [略] 使用多值依赖的分解 (7.6)</strong>：更高范式（不基于FD）。</li>
<li><strong>VII. [略] 数据库设计过程 (7.9)</strong></li>
<li><strong>附录7-1</strong> 求解候选键算法</li>
<li><strong>附录7-2</strong> 示例与练习</li>
</ul>
<hr>
<p>感谢关注！</p>
<p>北京师范大学</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src="/img/my_avatar.png" title="头像" alt="头像"><img class="post-copyright__author_img_front" src="/img/my_avatar.png" title="头像" alt="头像"></a><div class="post-copyright__author_name">Yuejin Wu</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/')">Schema Normalization-Relational Database Design 解读</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Schema Normalization-Relational Database Design 解读&amp;url=http://example.com/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/&amp;pic=/img/C7_cover.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Yuejin's Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__category-list"><a class="post-meta__box__categoryes" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="categoryes-punctuation"> <i class="anzhiyufont anzhiyu-icon-inbox"></i></span>数据库<span class="categoryesPageCount">6</span></a></div><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Database/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Database<span class="tagsPageCount">6</span></a><a class="post-meta__box__tags" href="/tags/SQL/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>SQL<span class="tagsPageCount">5</span></a></div></div><div class="post_share"><div class="social-share" data-image="/img/C7_cover.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/12/24/DB_Intermediate%20SQL/"><img class="prev-cover" src="/img/SQL_cover.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Intermediate-SQL 解读</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/" title="Intro-to-SQL 简读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-22</div><div class="title">Intro-to-SQL 简读</div></div></a></div><div><a href="/2025/12/24/DB_AdvancedSQL/" title="Advanced-SQL课件详解"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-24</div><div class="title">Advanced-SQL课件详解</div></div></a></div><div><a href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/" title="高级SQL 简读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-24</div><div class="title">高级SQL 简读</div></div></a></div><div><a href="/2025/12/24/DB_Intermediate%20SQL/" title="Intermediate-SQL 解读"><img class="cover" src="/img/SQL_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-24</div><div class="title">Intermediate-SQL 解读</div></div></a></div><div><a href="/2025/12/22/DB_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%AF%BB/" title="关系模型 简读"><img class="cover" src="/img/db_cover.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2025-12-22</div><div class="title">关系模型 简读</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src="/img/my_avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"><div class="author-intro" style="line-height: 1.7; text-align: center; font-family: inherit; margin-top: -0.5rem; margin-bottom: 0.5rem;">
  <p style="font-size: 1.15rem; margin-bottom: 0.8rem; font-weight: 500; color: var(--anzhiyu-fontcolor);">你好，我是 <span style="color: #00ffcc; font-weight: 600; text-shadow: 0 0 5px #00ffccaa;">Yuejin Wu</span>！👋</p>
  <p style="font-size: 1.05rem; margin-bottom: 0.6rem; opacity: 0.9; color: var(--anzhiyu-fontcolor);">BUPT 本科生 · 人工智能专业</p>
  <p style="font-size: 1.05rem; margin-bottom: 1rem; opacity: 0.9; color: var(--anzhiyu-fontcolor);">记录学习、思考与生活</p>
  <p style="font-size: 1.1rem; margin-top: 1rem; padding-top: 0.8rem; border-top: 1px solid var(--anzhiyu-theme-op); font-weight: 600; color: #FF0066; text-shadow: 0 0 5px #FF0066, 0 0 5px #FF0066aa;">
   保持好奇，持续探索
  </p>
</div>
</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Yuejin Wu</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/YuejinWu/YuejinWu.github.io" target="_blank" title="Github"></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-%E6%A8%A1%E5%BC%8F%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-number">1.</span> <span class="toc-text">关系数据库设计 模式规范化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">数据库设计流程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E4%BA%8EDBMS%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.1.</span> <span class="toc-text">独立于DBMS的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E4%BA%8EDBMS%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.</span> <span class="toc-text">依赖于DBMS的步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E5%A4%A7%E7%BA%B2"><span class="toc-number">3.</span> <span class="toc-text">本章大纲</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%89%AF%E5%A5%BD%E7%9A%84%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">7.1 良好的关系数据库设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE%E4%B8%8E%E6%8C%91%E6%88%98"><span class="toc-number">4.1.</span> <span class="toc-text">困难与挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.</span> <span class="toc-text">逻辑设计步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%90%88%E5%B9%B6%E6%A8%A1%E5%BC%8F%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">示例：合并模式带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E8%A7%84%E8%8C%83%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-number">4.4.</span> <span class="toc-text">问题解决：规范化原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E8%BF%9B%E8%A1%8C%E5%88%86%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">7.2 使用函数依赖进行分解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%A6%82%E8%A7%88"><span class="toc-number">5.1.</span> <span class="toc-text">内容概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.</span> <span class="toc-text">示例对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%8D%9F%E5%88%86%E8%A7%A3%E5%AE%9A%E4%B9%89"><span class="toc-number">5.3.</span> <span class="toc-text">无损分解定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA"><span class="toc-number">5.4.</span> <span class="toc-text">规范化理论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E4%BD%9C%E4%B8%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.</span> <span class="toc-text">函数依赖作为约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">函数依赖概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.</span> <span class="toc-text">函数依赖定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E5%AE%9E%E4%BE%8B%E6%BB%A1%E8%B6%B3%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.3.</span> <span class="toc-text">关系实例满足函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.4.</span> <span class="toc-text">SQL语句判断函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%A4%E6%96%ADFD%E6%98%AF%E5%90%A6%E8%A2%AB%E6%BB%A1%E8%B6%B3"><span class="toc-number">6.5.</span> <span class="toc-text">示例：判断FD是否被满足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%9C%A8%E6%A8%A1%E5%BC%8FR%E4%B8%8A%E6%88%90%E7%AB%8B-vs-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E8%A2%ABr-R-%E6%BB%A1%E8%B6%B3"><span class="toc-number">6.6.</span> <span class="toc-text">函数依赖在模式R上成立 vs 函数依赖被r(R)满足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%A4%BA%E4%BE%8B%E5%BB%BA%E6%A8%A1"><span class="toc-number">6.7.</span> <span class="toc-text">函数依赖示例建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E5%92%8C%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">6.8.</span> <span class="toc-text">键和函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">6.9.</span> <span class="toc-text">函数依赖在数据库中的完整性约束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">6.10.</span> <span class="toc-text">函数依赖的用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">7.</span> <span class="toc-text">特殊类型的函数依赖</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%B9%B3%E5%87%A1%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">7.1.</span> <span class="toc-text">1. 平凡函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%A0%E9%80%92%E4%BE%9D%E8%B5%96"><span class="toc-number">7.2.</span> <span class="toc-text">2. 传递依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%83%A8%E5%88%86%E4%BE%9D%E8%B5%96"><span class="toc-number">7.3.</span> <span class="toc-text">3. 部分依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86F%E7%9A%84%E9%97%AD%E5%8C%85-F"><span class="toc-number">7.4.</span> <span class="toc-text">4. 函数依赖集F的闭包 F*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%A0%E6%8D%9F%E5%88%86%E8%A7%A3"><span class="toc-number">7.5.</span> <span class="toc-text">5. 无损分解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E8%8C%83%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">7.3 范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E7%A7%8D%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">范式种类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E5%8E%9F%E5%88%99"><span class="toc-number">8.2.</span> <span class="toc-text">规范化原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%9F%9F%E5%92%8C%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">原子域和第一范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">第二范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2NF%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.4.1.</span> <span class="toc-text">2NF示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Boyce-Codd%E8%8C%83%E5%BC%8F"><span class="toc-number">8.5.</span> <span class="toc-text">Boyce-Codd范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BCNF%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.5.1.</span> <span class="toc-text">BCNF示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%A8%A1%E5%BC%8F%E5%88%86%E8%A7%A3%E4%B8%BABCNF"><span class="toc-number">8.5.2.</span> <span class="toc-text">将模式分解为BCNF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCNF%E4%B8%8E%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81"><span class="toc-number">8.5.3.</span> <span class="toc-text">BCNF与依赖保持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">8.6.</span> <span class="toc-text">第三范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3NF%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.6.1.</span> <span class="toc-text">3NF示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3NF%E4%B8%AD%E7%9A%84%E5%86%97%E4%BD%99"><span class="toc-number">8.6.2.</span> <span class="toc-text">3NF中的冗余</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF%E4%B8%8E3NF%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.7.</span> <span class="toc-text">BCNF与3NF的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83%E5%8C%96%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">8.8.</span> <span class="toc-text">规范化的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">8.9.</span> <span class="toc-text">范式总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%90%86%E8%AE%BA"><span class="toc-number">9.</span> <span class="toc-text">7.4 函数依赖理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">9.1.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%97%B4%E7%9A%84%E9%80%BB%E8%BE%91%E8%95%B4%E5%90%AB"><span class="toc-number">9.2.</span> <span class="toc-text">函数依赖间的逻辑蕴含</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E9%9B%86%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">9.3.</span> <span class="toc-text">函数依赖集的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">9.3.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%9B%86%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-number">9.4.</span> <span class="toc-text">属性集的闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%9B%86%E9%97%AD%E5%8C%85%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.1.</span> <span class="toc-text">属性集闭包算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%9B%86%E9%97%AD%E5%8C%85%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.4.2.</span> <span class="toc-text">属性集闭包示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%97%AD%E5%8C%85%E7%AE%97%E6%B3%95%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">9.4.3.</span> <span class="toc-text">属性闭包算法的用途</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FD%E9%9B%86%E5%90%88%E7%9A%84%E7%AD%89%E4%BB%B7"><span class="toc-number">9.5.</span> <span class="toc-text">FD集合的等价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96"><span class="toc-number">9.6.</span> <span class="toc-text">正则覆盖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E6%97%A0%E5%85%B3FD"><span class="toc-number">9.6.1.</span> <span class="toc-text">无关属性和无关FD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E6%97%A0%E5%85%B3"><span class="toc-number">9.6.2.</span> <span class="toc-text">测试一个属性是否无关</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E5%B1%9E%E6%80%A7%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.6.3.</span> <span class="toc-text">无关属性示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%AE%A1%E7%AE%97"><span class="toc-number">9.6.4.</span> <span class="toc-text">正则覆盖定义与计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96%E8%AE%A1%E7%AE%97%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.6.5.</span> <span class="toc-text">正则覆盖计算示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%8D%9F%E8%BF%9E%E6%8E%A5%E5%88%86%E8%A7%A3"><span class="toc-number">9.7.</span> <span class="toc-text">无损连接分解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81"><span class="toc-number">9.8.</span> <span class="toc-text">依赖保持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81%E6%B5%8B%E8%AF%95%E7%AE%97%E6%B3%95"><span class="toc-number">9.8.1.</span> <span class="toc-text">依赖保持测试算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E4%BF%9D%E6%8C%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.8.2.</span> <span class="toc-text">依赖保持示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96%E7%9A%84%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="toc-number">10.</span> <span class="toc-text">7.5 使用函数依赖的分解算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E6%A6%82%E8%A7%88-1"><span class="toc-number">10.1.</span> <span class="toc-text">内容概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8EBCNF"><span class="toc-number">10.2.</span> <span class="toc-text">测试关系是否属于BCNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%88%86%E8%A7%A3%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8EBCNF"><span class="toc-number">10.3.</span> <span class="toc-text">测试分解中的关系是否属于BCNF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">BCNF分解算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BCNF%E5%88%86%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.4.1.</span> <span class="toc-text">BCNF分解示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BCNF%E5%88%86%E8%A7%A3%E5%8F%AF%E8%83%BD%E6%97%A0%E6%B3%95%E4%BF%9D%E6%8C%81%E4%BE%9D%E8%B5%96"><span class="toc-number">10.4.2.</span> <span class="toc-text">BCNF分解可能无法保持依赖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F%E5%88%86%E8%A7%A3"><span class="toc-number">10.5.</span> <span class="toc-text">第三范式分解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E3NF"><span class="toc-number">10.5.1.</span> <span class="toc-text">测试关系是否属于3NF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3NF%E5%88%86%E8%A7%A3%E7%AE%97%E6%B3%95"><span class="toc-number">10.5.2.</span> <span class="toc-text">3NF分解算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3NF%E5%88%86%E8%A7%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.5.3.</span> <span class="toc-text">3NF分解示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BCNF%E4%B8%8E3NF%E5%AF%B9%E6%AF%94"><span class="toc-number">10.6.</span> <span class="toc-text">BCNF与3NF对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%957-1-%E8%AE%A1%E7%AE%97%E5%80%99%E9%80%89%E9%94%AE%E7%AE%97%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">附录7-1 计算候选键算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E7%90%86"><span class="toc-number">11.1.</span> <span class="toc-text">定理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%80%99%E9%80%89%E9%94%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.3.</span> <span class="toc-text">计算候选键示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%957-2-%E4%B9%A0%E9%A2%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">12.</span> <span class="toc-text">附录7-2 习题类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E7%AB%A0%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">13.</span> <span class="toc-text">本章结构总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/" title="Schema Normalization-Relational Database Design 解读"><img src="/img/C7_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Schema Normalization-Relational Database Design 解读"/></a><div class="content"><a class="title" href="/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/" title="Schema Normalization-Relational Database Design 解读">Schema Normalization-Relational Database Design 解读</a><time datetime="2025-12-26T14:25:50.639Z" title="发表于 2025-12-26 22:25:50">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/DB_Intermediate%20SQL/" title="Intermediate-SQL 解读"><img src="/img/SQL_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intermediate-SQL 解读"/></a><div class="content"><a class="title" href="/2025/12/24/DB_Intermediate%20SQL/" title="Intermediate-SQL 解读">Intermediate-SQL 解读</a><time datetime="2025-12-23T17:45:01.113Z" title="发表于 2025-12-24 01:45:01">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/DB_AdvancedSQL/" title="Advanced-SQL课件详解"><img src="/img/SQL_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Advanced-SQL课件详解"/></a><div class="content"><a class="title" href="/2025/12/24/DB_AdvancedSQL/" title="Advanced-SQL课件详解">Advanced-SQL课件详解</a><time datetime="2025-12-23T17:31:49.070Z" title="发表于 2025-12-24 01:31:49">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/" title="高级SQL 简读"><img src="/img/SQL_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高级SQL 简读"/></a><div class="content"><a class="title" href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/" title="高级SQL 简读">高级SQL 简读</a><time datetime="2025-12-23T17:27:51.680Z" title="发表于 2025-12-24 01:27:51">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/" title="Intro-to-SQL 简读"><img src="/img/SQL_cover.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Intro-to-SQL 简读"/></a><div class="content"><a class="title" href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/" title="Intro-to-SQL 简读">Intro-to-SQL 简读</a><time datetime="2025-12-22T06:53:42.900Z" title="发表于 2025-12-22 14:53:42">2025-12-22</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Yuejin Wu" target="_blank">Yuejin Wu</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" href="/" title="首页">首页</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">8</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://hexo.anheyu.com/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/AI-Platform/" style="font-size: 0.88rem;">AI Platform<sup>1</sup></a><a href="/tags/Database/" style="font-size: 0.88rem;">Database<sup>6</sup></a><a href="/tags/English/" style="font-size: 0.88rem;">English<sup>1</sup></a><a href="/tags/RNN/" style="font-size: 0.88rem;">RNN<sup>1</sup></a><a href="/tags/SQL/" style="font-size: 0.88rem;">SQL<sup>5</sup></a><a href="/tags/Self-Attention/" style="font-size: 0.88rem;">Self Attention<sup>1</sup></a><a href="/tags/plan/" style="font-size: 0.88rem;">plan<sup>2</sup></a><a href="/tags/%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/" style="font-size: 0.88rem;">关系模型<sup>1</sup></a><a href="/tags/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B/" style="font-size: 0.88rem;">自注意力<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@6.1.6/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.7.0",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Yuejin Wu 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://cdn.cbd.int/qrcodejs@1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>