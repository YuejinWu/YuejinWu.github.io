<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>§17 Transaction 解读</title>
      <link href="/2025/12/28/DB_Transaction/"/>
      <url>/2025/12/28/DB_Transaction/</url>
      
        <content type="html"><![CDATA[<h3 id="第17章：事务管理">第17章：事务管理</h3><h2 id="第5部分：事务管理">第5部分：事务管理</h2><ul><li>对数据库的单用户访问体现为一个或多个<strong>事务</strong>的执行。<ul><li>例如：<code>SELECT</code>, <code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code>。</li><li>事务是数据库应用系统的基本逻辑单元，也是DBMS管理数据库系统的基本单位。</li></ul></li><li>对数据库的多用户并发访问体现为一个或多个事务的<strong>并发执行</strong>。</li></ul><hr><h2 id="事务管理">事务管理</h2><ul><li>多个事务并发访问共享数据项 <code>Q</code>，为保证数据正确性，必须满足<strong>ACID</strong>特性：<ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul></li><li>DBMS的<strong>恢复管理</strong>组件负责保障原子性和持久性。</li><li>DBMS的<strong>并发控制</strong>组件负责保障隔离性和一致性。</li></ul><hr><h2 id="17-1-事务概念">17.1 事务概念</h2><h3 id="定义1">定义1</h3><p>事务是数据库应用系统的一个单元，用于执行对数据库中各种数据项的<strong>访问</strong>和<strong>更新</strong>。</p><h3 id="定义2">定义2</h3><p>一个事务由一组操作构成，这些操作由特定的语句界定：</p><ul><li><code>BEGIN TRANSACTION</code> 和 <code>END TRANSACTION</code>。</li><li>操作：对数据库的读或写。<ul><li><code>BEGIN TRANSACTION</code><br><code>op₁; op₂; ...</code><br><code>END TRANSACTION</code> <strong>(COMMIT</strong> 或 <strong>ABORT/ROLLBACK)</strong>。</li></ul></li><li>事务由应用程序发起，这些程序可以用以下语言编写：<ul><li>数据操作语言，如SQL。</li><li>编程语言，如嵌入了数据库访问的C++。</li></ul></li></ul><hr><h3 id="事务：由读写元操作定义【逻辑读、逻辑写】">事务：由读写元操作定义【逻辑读、逻辑写】</h3><p><strong>示例1：账户转账 T1</strong>：从账户A转账$50到账户B。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">T1: begin-transaction</span><br><span class="line">    read (A);</span><br><span class="line">    A := A - 50;</span><br><span class="line">    write (A);</span><br><span class="line">    read (B);</span><br><span class="line">    B := B + 50;</span><br><span class="line">    write (B);</span><br><span class="line">end-transaction</span><br></pre></td></tr></table></figure><p><strong>需要处理的问题</strong>：</p><ul><li>故障，例如硬件故障和系统崩溃。</li><li>多个事务的并发执行。</li></ul><hr><h3 id="包含回滚的事务">包含回滚的事务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">T2: begin-transaction</span><br><span class="line">    read (A);</span><br><span class="line">    A := A - 50;</span><br><span class="line">    if A &lt; 0 then</span><br><span class="line">    begin</span><br><span class="line">        print(&#x27;insufficient funds&#x27;)</span><br><span class="line">        rollback T2</span><br><span class="line">    end</span><br><span class="line">    else begin</span><br><span class="line">        write (A);</span><br><span class="line">        read (B);</span><br><span class="line">        B := B + 50;</span><br><span class="line">        write (B);</span><br><span class="line">        commit T2</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p><code>ROLLBACK/ABORT T2</code>：撤销之前对 <code>A</code> 的修改（即恢复 <code>A</code> 的原始值），并立即终止T2，不再执行其后的操作。</p><hr><h3 id="SQL语句-vs-读写元操作">SQL语句 vs. 读写元操作</h3><ul><li>SQL语句可以分解为读和写操作。</li><li><strong>示例</strong>：表 <code>SC(s#, c#, grade)</code>。</li></ul><ol><li><p><strong>SQL语句</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> MaxGrade(c#, maxG)</span><br><span class="line"><span class="keyword">SELECT</span> c#, <span class="built_in">MAX</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span> SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> c#;</span><br></pre></td></tr></table></figure><p><strong>对应的读写操作</strong>:</p><ul><li><code>read(SC(c#, grade))</code></li><li><code>write(MaxGrade(c#, maxG))</code></li></ul></li><li><p><strong>SQL语句</strong>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> grade <span class="operator">=</span> grade <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> c# <span class="operator">=</span> <span class="number">301141</span>;</span><br></pre></td></tr></table></figure><p><strong>对应的读写操作</strong>:</p><ul><li><code>read(SC.c#)</code></li><li><code>read(SC.grade)</code></li><li><code>write(grade)</code></li></ul></li></ol><hr><h3 id="SQL-Server中的事务示例">SQL Server中的事务示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@transfer_name</span> <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@transfer_name</span> <span class="operator">=</span> <span class="string">&#x27;I-transfer-from-A-to-B&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION <span class="variable">@transfer_name</span></span><br><span class="line">USE ACCOUNT</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">UPDATE</span> A</span><br><span class="line">    <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">50</span></span><br><span class="line">    <span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line"><span class="keyword">UPDATE</span> B</span><br><span class="line">    <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span></span><br><span class="line">    <span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line">GO</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION <span class="variable">@transfer_name</span></span><br><span class="line">GO</span><br></pre></td></tr></table></figure><ul><li>事务变量定义</li><li>事务命名</li><li>事务开始</li><li>打开数据库 <code>ACCOUNT</code></li><li>将批处理语句提交给 SQL Server</li><li>修改账户A</li><li>修改账户B</li><li>事务提交</li></ul><hr><h2 id="17-2-事务模型">17.2 事务模型</h2><ul><li>每个数据访问（如SQL中的<code>SELECT</code>, <code>UPDATE</code>）都会被<strong>转换/分解</strong>为读和写操作。</li><li><strong>DBMS</strong>：执行读写操作以实现事务中的数据访问。</li><li><strong>DBMS</strong>：在主存中分配<strong>局部缓冲区</strong>作为工作区域。</li><li>数据库持久驻留在磁盘上，但部分数据会暂时驻留在主存的缓冲区中。</li></ul><hr><h3 id="事务模型中的操作定义">事务模型中的操作定义</h3><ul><li><p><strong>定义：<code>read(X)</code></strong></p><ul><li>将数据项 <code>X</code> 从磁盘上的数据库文件（或磁盘缓冲区）<strong>传输</strong>到执行该读操作的事务所属局部缓冲区中的一个变量（也称为 <code>X</code>）中。</li></ul></li><li><p><strong>定义：<code>write(X)</code></strong></p><ul><li>将局部缓冲区中变量 <code>X</code> 的值<strong>传输</strong>回磁盘上数据库文件中对应的数据项 <code>X</code>。</li></ul></li><li><p><strong>注意</strong>：<br>写操作不会立即更新磁盘上的数据。它可能暂时存储在磁盘缓冲区中。</p></li></ul><hr><h3 id="事务读写操作示意图">事务读写操作示意图</h3><p><strong>示例</strong>：<code>Instructor</code> 表中的 <code>name</code> 字段。</p><ul><li>事务 T₁ 发出的对数据项 <code>x</code> 和 <code>y</code> 的数据访问（如 <code>SELECT</code>, <code>INSERT</code>, <code>DELETE</code>, <code>UPDATE</code> 等）。</li><li>DBMS为事务T₁分配的局部缓冲区变量 <code>x₁</code>, <code>y₁</code>。</li><li><strong>逻辑读写</strong>：<code>read(x)</code>, <code>write(y)</code>。</li><li><strong>磁盘缓冲区</strong>中的数据项块：<code>Bₓ</code>, <code>Bᵧ</code>, ..., <code>B_z</code>。</li><li><strong>物理读写</strong>：<code>input(X)</code>, <code>output(Y)</code> / 反映 / 持久化。</li><li><strong>磁盘上的数据库文件</strong>：<code>Bₓ</code>, <code>Bᵧ</code>, ..., <code>B_z</code>, <code>B_w</code>; <code>Bᵤ</code>, <code>Bᵥ</code>, ..., <code>B_q</code>, <code>Bᵣ</code>（在检查点或提交时写回）。</li></ul><hr><h3 id="资金转账示例">资金转账示例</h3><p><strong>示例</strong>：从账户A转账$50到账户B的事务。</p><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">A的值</th><th style="text-align:left">B的值</th><th style="text-align:left">A + B</th></tr></thead><tbody><tr><td style="text-align:left">初始值</td><td style="text-align:left">1000</td><td style="text-align:left">2000</td><td style="text-align:left">3000</td></tr><tr><td style="text-align:left">1. <code>read(A)</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2. <code>A := A - 50</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">3. <code>write(A)</code></td><td style="text-align:left">950</td><td style="text-align:left">2000</td><td style="text-align:left">2950</td></tr><tr><td style="text-align:left">4. <code>read(B)</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">5. <code>B := B + 50</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">6. <code>write(B)</code></td><td style="text-align:left">950</td><td style="text-align:left">2050</td><td style="text-align:left"><strong>3000</strong></td></tr></tbody></table><hr><h2 id="ACID特性详解">ACID特性详解</h2><h3 id="1-一致性">1. 一致性</h3><ul><li>事务在<strong>隔离</strong>状态下执行能够<strong>保持</strong>数据库的<strong>一致性</strong>。在事务执行前后，数据库都处于正确的状态。</li><li>事务的正确执行使得数据库从一个正确状态转移到另一个正确状态。</li><li><strong>数据库状态</strong>：数据库中表的内容或数据库实例。</li></ul><table><thead><tr><th style="text-align:left">一致性/正确性定义示例：</th></tr></thead><tbody><tr><td style="text-align:left">A=1000, B=2000， A+B=3000</td></tr><tr><td style="text-align:left">完整性约束未被违反。</td></tr><tr><td style="text-align:left"><strong>一致性要求示例</strong>：A和B的总和保持不变，即 <code>A + B = 3000</code>。</td></tr></tbody></table><ul><li><strong>一致性要求</strong>包括：<ul><li><strong>显式</strong>的完整性约束，如主键和外键。</li><li><strong>隐式</strong>的完整性约束。<ul><li>例如：所有账户余额总和减去所有贷款金额总和必须等于手头现金价值。</li></ul></li></ul></li><li>在事务执行<strong>过程中</strong>，数据库可能暂时处于不一致状态。<ul><li>例如：在上述转账示例的第3步之后、第6步之前，<code>A+B=2950</code>。</li></ul></li><li>当事务<strong>成功完成</strong>时，数据库必须是一致的。</li></ul><hr><h3 id="2-原子性">2. 原子性</h3><ul><li>事务中的所有操作要么<strong>全部反映/持久化</strong>到数据库，要么<strong>一个都不反映</strong>。<ul><li>事务中所有操作或者全部成功完成，并且这些操作结果被写入数据库；</li><li>或者事务中的所有操作一个都不做，该事务对数据库和其他事务没有任何影响。</li></ul></li><li>确保<strong>部分</strong>执行的事务的更新不会被反映到数据库中。</li></ul><hr><h3 id="3-隔离性">3. 隔离性</h3><ul><li><strong>定义</strong>：即使多个事务并发执行，所有事务看起来都像是在串行执行，从而保持了一致性。</li><li>每个事务都<strong>不知道</strong>其他事务正在并发执行。</li><li>对于并发执行的事务，一个事务的执行不能被其他事务干扰。即，一个事务内部的操作和数据对其他事务是隔离的，并发执行的事务之间不能相互干扰。从执行结果来看，相当于事务串行执行。</li><li><strong>隔离性</strong>保证了多个事务并发执行的<strong>正确性</strong>。</li><li>并发控制机制确保了隔离性。</li></ul><p><strong>示例</strong>：如果在转账事务T1的第3步和第6步之间，允许另一个事务T2访问部分更新的数据库，T2将看到一个不一致的数据库（A=950，B=2000，总和为2950）。</p><ul><li>通过<strong>串行</strong>地运行事务（一个接一个）可以确保隔离性。</li></ul><hr><h3 id="4-持久性">4. 持久性</h3><ul><li><strong>定义</strong>：一旦事务完成，该事务对数据库的更新必须<strong>持久保持</strong>，即使发生软件或硬件故障。</li><li>缓冲区中数据项的修改值应该<strong>反映/写入</strong>到磁盘上的数据库文件中。</li><li>事务一旦提交（成功完成），对数据库数据的改变是<strong>永久性</strong>的——即持久化。</li><li><strong>示例</strong>：$50的转账已经发生，即使发生软件或硬件故障，该事务对数据库的更新也必须持久保持。</li></ul><p><strong>示例2</strong>：对于图17.0中的T₃。</p><ul><li>事务开始时，局部缓冲区和磁盘缓冲区中A=1000，B=2000。</li><li>执行<code>update(A)</code>后，局部缓冲区中a=950。</li><li>执行<code>update(B)</code>后，局部缓冲区中b=2050。</li><li>提交时，磁盘缓冲区中a=950，b=2050。</li><li>最终，磁盘上的数据库文件中A=950，B=2050。</li></ul><hr><h3 id="ACID特性的保障机制">ACID特性的保障机制</h3><p>数据库系统中的ACID保障机制：</p><ul><li><strong>原子性</strong>：由事务管理/恢复管理组件保障。</li><li><strong>一致性</strong>：由完整性约束和DBMS中的测试机制保障。</li><li><strong>隔离性</strong>：由并发控制组件保障。</li><li><strong>持久性</strong>：由恢复管理组件保障。</li></ul><hr><h2 id="17-4-事务原子性与持久性（状态模型）">17.4 事务原子性与持久性（状态模型）</h2><h3 id="关键定义">关键定义</h3><ul><li><strong>定义1</strong>：如果一个事务可能无法成功完成其执行，则称其为<strong>中止</strong>。</li><li><strong>定义2</strong>：如果一个事务成功完成其执行，则称其为<strong>提交</strong>。</li><li><strong>定义3</strong>：一旦一个<strong>已中止</strong>事务所做的更改被<strong>撤销</strong>，则该事务被称为<strong>回滚</strong>。</li><li><strong>定义4</strong>：如果一个事务已提交或已中止，则称其已<strong>终止</strong>。</li></ul><hr><h3 id="事务状态（生命周期）">事务状态（生命周期）</h3><ul><li><strong>活动</strong> - 初始状态。</li><li><strong>部分提交</strong> - 在最终语句（通常是<code>COMMIT</code>）被执行之后。</li><li><strong>失败</strong> - 正常执行无法再继续进行。</li><li><strong>中止</strong> - 在事务已回滚且数据库恢复到事务开始前的状态之后。<ul><li>中止后的两个选项：<ul><li><strong>重启</strong>事务：仅当没有内部逻辑错误时。</li><li><strong>终止</strong>事务。</li></ul></li></ul></li><li><strong>提交</strong> - 在成功完成之后。</li></ul><hr><h3 id="事务状态图-图17-1">事务状态图 (图17.1)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     begin-transaction</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">       active</span><br><span class="line">         |\</span><br><span class="line">         | \</span><br><span class="line">         |  \ (失败)</span><br><span class="line">         |   \</span><br><span class="line">         |    v</span><br><span class="line">         |   failed</span><br><span class="line">         |    |</span><br><span class="line">         |    v</span><br><span class="line">         |  aborted</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">partially committed</span><br><span class="line">         |</span><br><span class="line">         v</span><br><span class="line">      committed</span><br></pre></td></tr></table></figure><ul><li><code>active</code> -&gt; <code>partially committed</code>: 最终操作执行。</li><li><code>partially committed</code> -&gt; <code>committed</code>: 提交。</li><li><code>active</code> -&gt; <code>failed</code>: 回滚或发生故障。</li><li><code>failed</code> -&gt; <code>aborted</code>: 回滚完成。</li><li><code>aborted</code> -&gt; <code>active</code>: 重启（可选）。</li></ul><hr><h3 id="成功提交的事务流程">成功提交的事务流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin-trans. -&gt; op_i; ... op_n; -&gt; commit.</span><br></pre></td></tr></table></figure><p>DBMS操作：</p><ol><li>分配资源（如局部缓冲区），创建并启动事务。</li><li>执行操作（<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>等）。</li><li>将数据反映到磁盘（持久化）。</li><li>释放资源；结束事务。</li></ol><p>状态流：<code>活动</code> -&gt; <code>部分提交</code> -&gt; <code>已提交</code></p><hr><h3 id="回滚的事务流程">回滚的事务流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin-trans. -&gt; op_i; ... op_n; -&gt; (故障/回滚)</span><br></pre></td></tr></table></figure><p>DBMS操作：</p><ol><li>分配资源（如局部缓冲区），创建并启动事务。</li><li>执行操作。</li><li>发生故障，触发回滚。</li><li>回滚（撤销或重做）之前的操作。</li><li>释放资源；结束事务。</li></ol><p>状态流：<code>活动</code> -&gt; <code>失败</code> -&gt; <code>中止</code></p><hr><h3 id="事务状态详述">事务状态详述</h3><ul><li><p><strong>活动</strong>：</p><ul><li>初始状态，事务从<code>begin-transaction</code>开始执行时处于此状态。</li><li>事务被创建（在<code>begin-transaction</code>提交后），例如，为事务分配了局部缓冲区。</li><li><strong>注意</strong>：事务操作被执行，但操作对数据库发出的修改<strong>可能</strong>只<strong>临时</strong>存储在磁盘缓冲区中，<strong>并未立即反映</strong>到磁盘上的数据库文件。</li></ul></li><li><p><strong>部分提交</strong>：</p><ul><li>在最终语句（<code>COMMIT</code>）提交后，事务进入此状态。</li><li>事务操作产生的影响从磁盘缓冲区<strong>反映</strong>到数据库文件（持久化）。</li></ul></li><li><p><strong>已提交</strong>：</p><ul><li>在所有操作成功完成后，事务进入此状态。所有结果已在<strong>部分提交</strong>状态反映到数据库文件。</li><li>事务释放所占用的资源，终止（退出数据库系统），其生命周期结束。</li></ul></li><li><p><strong>失败</strong>：</p><ul><li>如果发现正常执行无法继续进行，事务进入此状态。</li><li>事务被<strong>回滚</strong>以将数据库恢复到事务开始前的状态。在此状态下进行失败处理工作。</li></ul></li><li><p><strong>中止</strong>：</p><ul><li>在失败状态下事务被回滚后，数据库已恢复到事务开始前的状态，事务进入此状态以结束。</li><li>事务释放所占用的资源，向其用户报告事务已中止，终止（退出数据库系统），其生命周期结束。表示DBMS已完成失败处理工作，事务将要退出系统。</li></ul></li></ul><hr><h3 id="示例：事务中的回滚">示例：事务中的回滚</h3><ul><li><strong>定义：回滚</strong><ul><li>撤销到目前为止事务已经对数据库所做的所有修改，数据库状态恢复到事务开始前的状态。</li></ul></li></ul><p><strong>示例</strong>：<br>定义表 <code>SC</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> SC (</span><br><span class="line">    s# <span class="type">INTEGER</span>,</span><br><span class="line">    c# <span class="type">INTEGER</span>,</span><br><span class="line">    grade <span class="type">INTEGER</span>,</span><br><span class="line">    <span class="keyword">CHECK</span> (grade <span class="keyword">BETWEEN</span> <span class="number">0</span> <span class="keyword">AND</span> <span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>定义更新事务 <code>update-tran</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> SC</span><br><span class="line"><span class="keyword">SET</span> grade <span class="operator">=</span> grade <span class="operator">+</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">WHERE</span> ...;</span><br></pre></td></tr></table></figure><p><strong>回滚过程</strong>：</p><ol><li><strong>(a) 初始SC实例</strong>：例如，<code>(210, 5, 100)</code>。</li><li><strong>(b) 发生故障时的SC实例</strong>：执行更新后，<code>grade</code>变为105，违反完整性约束（<code>grade &gt; 100</code>）。</li><li><strong>(c) 回滚后的SC实例</strong>：撤销所有更新，恢复到初始状态，即<code>(210, 5, 100)</code>。</li></ol><hr><h2 id="17-5-事务隔离">17.5 事务隔离</h2><h3 id="并发事务的调度">并发事务的调度</h3><ul><li>事务的<strong>并发执行</strong>允许：<ul><li>高吞吐量和资源利用率，减少等待时间。</li><li>例如：多用户订票系统。</li></ul></li><li>允许事务并发的<strong>缺点</strong>：<ul><li>事务包含对共享数据的操作，不同的调度可能导致不同的最终数据库状态。</li></ul></li><li>需要<strong>并发控制方案和事务调度</strong>。</li></ul><hr><h3 id="并发执行与调度">并发执行与调度</h3><ul><li><strong>定义</strong>：对一组并发事务的<strong>调度</strong>，规定了并发事务操作的执行顺序。<ul><li>包含事务的所有操作。</li><li>保持每个独立事务内部操作的顺序。</li></ul></li><li><strong>注意</strong>：<ul><li>成功执行的事务将以<code>COMMIT</code>指令作为最后一条语句。</li><li>执行失败的事务将以<code>ABORT</code>指令作为最后一条语句。</li></ul></li></ul><hr><h3 id="示例：并发调度分析">示例：并发调度分析</h3><ul><li><strong>事务</strong>:<ul><li>T₁: 从A转账$50到B。</li><li>T₂: 从A转账余额的10%到B。</li></ul></li><li><strong>初始值</strong>: A = $1000, B = $2000, (A + B) = $3000。</li></ul><h4 id="串行调度-S1-T₁-T₂">串行调度 S1 (T₁; T₂)</h4><table><thead><tr><th style="text-align:left">T₁</th><th style="text-align:left">T₂</th></tr></thead><tbody><tr><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>A := A - 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>read(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>B := B + 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>commit</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>temp := A * 0.1</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>A := A - temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(B)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>B := B + temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(B)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commit</code></td></tr></tbody></table><p><strong>最终结果</strong>：A = $855, B = $2145, (A + B) = $3000。</p><hr><h4 id="串行调度-S2-T₂-T₁">串行调度 S2 (T₂; T₁)</h4><table><thead><tr><th style="text-align:left">T₁</th><th style="text-align:left">T₂</th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>temp := A * 0.1</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>A := A - temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(B)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>B := B + temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(B)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commit</code></td></tr><tr><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>A := A - 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>read(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>B := B + 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>commit</code></td><td style="text-align:left"></td></tr></tbody></table><p><strong>最终结果</strong>：A = $850, B = $2150, (A + B) = $3000。</p><p><strong>结论</strong>：调度S1和S2导致共享数据项A和B的<strong>最终值不同</strong>，但都是<strong>正确</strong>的调度，因为都保持了总和不变。</p><hr><h4 id="并发调度-S3">并发调度 S3</h4><ul><li>将对A的两次写操作、对B的两次写操作安排在相近时间执行，利于在<code>COMMIT</code>时刻通过一次I/O操作一次性将A/B的修改结果写回数据库文件，减少写操作次数。</li><li>将对A的两次读操作、对B的两次读操作安排在相近时间执行，有利于减少读操作次数（第二次可从磁盘缓冲区读取）。</li></ul><p><strong>最终结果</strong>：A = $855, B = $2145, (A + B) = $3000。（与S1结果相同）</p><hr><h4 id="并发调度-S4">并发调度 S4</h4><ul><li>假设<code>read</code>直接从磁盘上的数据库文件读取数据。</li></ul><table><thead><tr><th style="text-align:left">T₁</th><th style="text-align:left">T₂</th></tr></thead><tbody><tr><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>A := A - 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>temp := A * 0.1</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>A := A - temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(B)</code></td></tr><tr><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>read(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>B := B + 50</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>commit</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>B := B + temp</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(B)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commit</code></td></tr></tbody></table><p><strong>最终结果</strong>：A = $950, B = $2100, (A + B) = $3050 <strong>（错误！）</strong></p><hr><h3 id="为什么S3正确而S4错误？">为什么S3正确而S4错误？</h3><ul><li><strong>S3（等价于S1）</strong>：<ul><li>T1和T2对共享数据A和B的访问实质上是串行的。</li><li>S3与串行调度S1的执行结果相同。</li><li>S3<strong>等价于</strong>串行调度S1。</li></ul></li><li><strong>S4（不等价于S1）</strong>：<ul><li>T1和T2以<strong>交错</strong>的方式操作共享数据A和B。</li><li>S4与串行调度S1的执行结果不同。</li><li>S4<strong>不等价于</strong>任何串行调度。</li><li>S4使数据库处于<strong>不一致</strong>状态。</li><li><strong>注意</strong>：<strong>隔离性</strong>和<strong>一致性</strong>被违反。</li></ul></li></ul><hr><h2 id="17-6-可串行化">17.6 可串行化</h2><ul><li><ol><li>多个事务串行执行可以保证事务的ACID特性（如S1，S2），但执行效率低。</li></ol></li><li><ol start="2"><li>多个事务并发执行时，如果事务操作调度顺序不当（如S4），会影响数据库系统的正确性。</li></ol></li><li><strong>事务并发控制基本原理</strong>：事务调度<strong>可串行化</strong>。<ul><li>相互冲突的操作串行执行。</li><li>非冲突的操作并行/交错执行。</li></ul></li><li><strong>动机：可串行化</strong><ul><li><strong>可串行化</strong>是判断并发调度是否正确的标准（如S3）。</li></ul></li></ul><hr><h3 id="可串行化">可串行化</h3><ul><li><strong>目的</strong>：判断一个并发事务调度S是否正确。<ul><li>标准：S是否<strong>等价于</strong>某个串行调度S‘。</li></ul></li><li><strong>基本假设</strong>：<ul><li>每个事务都保持数据库一致性。</li><li>事务的串行执行保持数据库一致性。</li></ul></li><li><strong>定义</strong>：如果一个调度S等价于某个串行调度S‘，则称S是<strong>可串行化</strong>的。</li><li><strong>可串行化调度</strong>的类型：<ul><li>冲突等价 / 冲突可串行化。</li><li>视图等价 / 视图可串行化。</li></ul></li><li>将对调度S正确性的判断转换为对S可串行性的判断。</li></ul><hr><h3 id="冲突可串行化">冲突可串行化</h3><ul><li>考虑两个事务 Tᵢ 和 Tⱼ，以及它们的调度 S。</li><li><strong>定义</strong>：事务Tᵢ的指令 Iᵢ 和事务Tⱼ的指令 Iⱼ 是<strong>冲突</strong>的，当且仅当：<ul><li>它们访问同一个数据项Q，并且</li><li>至少有一个指令是<code>write(Q)</code>。</li><li>即：<ul><li>Iᵢ = <code>read(Q)</code>, Iⱼ = <code>write(Q)</code> <strong>（冲突）</strong></li><li>Iᵢ = <code>write(Q)</code>, Iⱼ = <code>read(Q)</code> <strong>（冲突）</strong></li><li>Iᵢ = <code>write(Q)</code>, Iⱼ = <code>write(Q)</code> <strong>（冲突）</strong></li><li>Iᵢ = <code>read(Q)</code>, Iⱼ = <code>read(Q)</code> <strong>（不冲突）</strong></li></ul></li></ul></li></ul><hr><h4 id="冲突等价">冲突等价</h4><ul><li><strong>定义</strong>：如果调度S可以通过一系列<strong>交换非冲突指令</strong>的操作转换成调度S‘，则称S和S’是<strong>冲突等价</strong>的。</li></ul><p><strong>示例</strong>：</p><table><thead><tr><th style="text-align:left">S5</th><th style="text-align:left">S6</th></tr></thead><tbody><tr><td style="text-align:left">T₁: <code>read(A)</code></td><td style="text-align:left">T₁: <code>read(A)</code></td></tr><tr><td style="text-align:left">T₁: <code>write(A)</code></td><td style="text-align:left">T₂: <code>read(A)</code></td></tr><tr><td style="text-align:left">T₂: <code>read(A)</code></td><td style="text-align:left">T₁: <code>write(A)</code></td></tr><tr><td style="text-align:left">T₂: <code>write(B)</code></td><td style="text-align:left">T₂: <code>write(B)</code></td></tr><tr><td style="text-align:left">T₁: <code>read(B)</code></td><td style="text-align:left">T₁: <code>read(B)</code></td></tr><tr><td style="text-align:left">T₁: <code>write(B)</code></td><td style="text-align:left">T₁: <code>write(B)</code></td></tr></tbody></table><p>S5和S6是冲突等价的（交换了T₁的<code>write(A)</code>和T₂的<code>read(A)</code>？不，它们是冲突的。实际上S5中T₁的<code>write(A)</code>和T₂的<code>read(A)</code>是冲突操作，不能交换。需要检查具体指令。此例意在说明概念）。</p><hr><h4 id="冲突可串行化-2">冲突可串行化</h4><ul><li><strong>定义</strong>：如果一个并发调度S是<strong>冲突等价</strong>于某个串行调度S‘的，则称S是<strong>冲突可串行化</strong>的。</li><li><strong>注意</strong>：<ul><li>只允许交换分属两个不同事务的操作。</li><li>交换不能改变每个事务内部指令的顺序（例如，不允许交换T₁内部的<code>read(B)</code>和<code>write(B)</code>）。</li><li>交换不能改变调度S中<strong>冲突指令</strong>的执行顺序（例如，不允许交换T₁的<code>write(A)</code>和T₂的<code>read(A)</code>，如果它们冲突）。</li></ul></li><li>存在一些调度，它们不是冲突可串行化的。<ul><li><strong>示例</strong>：<table><thead><tr><th style="text-align:left">T₃</th><th style="text-align:left">T₄</th></tr></thead><tbody><tr><td style="text-align:left"><code>read(Q)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(Q)</code></td></tr><tr><td style="text-align:left"><code>write(Q)</code></td><td style="text-align:left"></td></tr></tbody></table></li></ul></li></ul><hr><h3 id="冲突可串行化的判定方法">冲突可串行化的判定方法</h3><p><strong>方法1</strong>：</p><ul><li>从给定的并发调度S开始。</li><li>保持S中<strong>冲突操作</strong>的执行顺序。</li><li>交换S中<strong>非冲突操作</strong>的执行顺序。</li><li>观察是否能得到一个串行调度S‘。</li></ul><p><strong>方法2</strong>：</p><ul><li>使用<strong>前驱图</strong>。</li></ul><hr><h3 id="示例1：判定冲突可串行化">示例1：判定冲突可串行化</h3><ul><li><strong>给定调度S</strong>（涉及T1, T2, T3, T4）：<table><thead><tr><th style="text-align:left">时间</th><th style="text-align:left">T1</th><th style="text-align:left">T2</th><th style="text-align:left">T3</th><th style="text-align:left">T4</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"></td><td style="text-align:left"><code>write(X)</code></td><td style="text-align:left"><code>read(X)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>write(Y)</code></td><td style="text-align:left"><code>read(Y)</code></td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>read(X)</code></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>write(Z)</code></td></tr></tbody></table></li><li><strong>答案</strong>：S等价于串行调度 <strong>&lt;T3; T2; T4; T1&gt;</strong>。（通过分析冲突边得出）</li></ul><hr><h3 id="构建冲突可串行化调度">构建冲突可串行化调度</h3><ul><li>构建一个与可串行化调度S冲突等价的串行调度S‘：<ul><li><strong>从</strong>给定的调度S开始。</li><li><strong>保持</strong>S中冲突操作的执行顺序。</li><li><strong>交换</strong>S中非冲突操作的执行顺序。</li><li><strong>得到</strong>一个冲突可串行化的S‘。</li></ul></li></ul><hr><h2 id="17-7-事务隔离性与原子性（考虑故障的调度）">17.7 事务隔离性与原子性（考虑故障的调度）</h2><ul><li><p>两种需要考虑故障的调度特性：</p><ul><li>可恢复调度</li><li>无级联回滚调度</li></ul></li><li><p><strong>可恢复性</strong>（当事务失败时）：</p><ul><li><strong>要求</strong>：当事务 Tᵢ 失败时，已经执行的、依赖于 Tᵢ 的事务 Tⱼ 也应该被回滚/撤销/中止/取消。<ul><li>Tⱼ <strong>读取</strong>了由 Tᵢ <strong>写入</strong>的数据。</li></ul></li><li>目的是<strong>确保原子性</strong>。</li></ul></li></ul><hr><h3 id="可恢复调度">可恢复调度</h3><ul><li><strong>定义</strong>：一个调度是<strong>可恢复的</strong>，如果对于每一对事务 Tᵢ 和 Tⱼ，满足：<ul><li>如果 Tⱼ 读取了之前由 Tᵢ 写入的数据项Q，那么 Tᵢ 的<code>COMMIT</code>操作必须在 Tⱼ 的<code>COMMIT</code>操作<strong>之前</strong>出现。</li></ul></li></ul><table><thead><tr><th style="text-align:left">Tᵢ</th><th style="text-align:left">Tⱼ</th></tr></thead><tbody><tr><td style="text-align:left"><code>write(Q)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">（故障/回滚点）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(Q)</code></td></tr><tr><td style="text-align:left"><code>commit</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commit</code></td></tr></tbody></table><p><strong>Tⱼ 依赖于 Tᵢ</strong>：当Tᵢ需要中止/回滚时，由于Tᵢ尚未提交，Tⱼ也尚未提交，因此Tⱼ可以回滚，Tⱼ中的<code>read(Q)</code>操作也随之被撤销。</p><hr><h3 id="示例1：不可恢复调度（违反完整性约束）">示例1：不可恢复调度（违反完整性约束）</h3><ul><li><strong>表</strong>：<code>SC(s#, c#, grade)</code>，约束：<code>CHECK (0 &lt;= grade &lt;= 100)</code>。</li><li><strong>表</strong>：<code>MaxGrade(c#, maxG)</code>。</li><li><strong>事务</strong>：<ul><li>Tᵢ: 插入一条记录，然后更新所有成绩加5。</li><li>Tⱼ: 从SC计算每门课最高分插入MaxGrade。</li></ul></li><li><strong>问题</strong>：<ul><li>Tᵢ的更新操作可能违反约束（如grade&gt;100），导致Tᵢ回滚。</li><li>但如果Tⱼ在Tᵢ回滚<strong>之前</strong>已经提交，它读取了Tᵢ更新后的中间数据（可能包括违反约束的105），并基于此计算了maxG=105，这个错误结果被持久化。</li><li>即使后来Tᵢ回滚，Tⱼ的错误结果也无法撤销，因为Tⱼ已提交。这违反了数据库一致性。</li></ul></li></ul><hr><h3 id="SQL-Server中的回滚设置：SET-XACT-ABORT">SQL Server中的回滚设置：<code>SET XACT_ABORT</code></h3><ul><li><code>SET XACT_ABORT { ON | OFF }</code><ul><li>指定当Transact-SQL语句产生运行时错误时，是否自动回滚当前事务。</li></ul></li><li><strong>为<code>ON</code>时</strong>：如果任何语句产生运行时错误，<strong>整个事务</strong>将终止并回滚。</li><li><strong>为<code>OFF</code>时</strong>（<strong>默认</strong>）：只回滚产生错误的<strong>单个Transact-SQL语句</strong>，而事务将继续处理后续语句。<ul><li>提高事务执行效率，但可能破坏事务原子性。</li></ul></li></ul><p><strong>示例</strong>：在<code>SET XACT_ABORT OFF</code>模式下，一个事务包含<code>INSERT</code>和可能违反约束的<code>UPDATE</code>。如果<code>UPDATE</code>失败回滚，<code>INSERT</code>可能仍然成功提交，不满足原子性。设置为<code>ON</code>可解决此问题。</p><hr><h3 id="示例2：不可恢复调度（简单读写）">示例2：不可恢复调度（简单读写）</h3><table><thead><tr><th style="text-align:left">T₈</th><th style="text-align:left">T₉</th></tr></thead><tbody><tr><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>commit</code></td></tr><tr><td style="text-align:left"><code>read(B)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>commit</code></td><td style="text-align:left"></td></tr></tbody></table><ul><li>S9是<strong>不可恢复</strong>的，如果T₉在<code>read(A)</code>之后立即提交。</li><li>如果T₈在T₉提交<strong>之后</strong>才中止，数据项A的值将被回滚到T₈执行前的旧值。</li><li><strong>但是</strong> T₉已经读取了A的<strong>新值</strong>并且已经提交了。T₉的提交无法撤销，导致数据不一致。</li></ul><hr><h3 id="无级联回滚调度">无级联回滚调度</h3><ul><li><p><strong>定义：级联回滚</strong></p><ul><li>单个事务的失败导致一系列事务回滚。</li></ul></li><li><p><strong>示例 S10</strong>：</p><table><thead><tr><th style="text-align:left">T₁₀</th><th style="text-align:left">T₁₁</th><th style="text-align:left">T₁₂</th></tr></thead><tbody><tr><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>read(B)</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"><code>write(A)</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"><code>read(A)</code></td></tr><tr><td style="text-align:left"><code>abort</code></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">（导致回滚）</td><td style="text-align:left">（级联回滚）</td><td style="text-align:left">（级联回滚）</td></tr></tbody></table><ul><li>在T₁₀、T₁₁、T₁₂提交之前，T₁₂读取了A。当T₁₀因故障回滚时，T₁₁应该回滚，进而导致T₁₂回滚。</li></ul></li><li><p>级联回滚是不希望的，因为它导致大量工作被撤销。</p></li></ul><hr><h3 id="无级联回滚调度-2">无级联回滚调度</h3><ul><li><strong>定义</strong>：<strong>无级联回滚调度</strong>是不会发生级联回滚的调度。<ul><li>对于任意一对事务Tᵢ和Tⱼ，如果Tⱼ读取了之前由Tᵢ写入的数据项Q，那么Tᵢ的<code>COMMIT</code>操作必须在Tⱼ的<code>READ</code>操作<strong>之前</strong>出现。</li><li>Tⱼ<strong>只读取</strong>已提交事务Tᵢ所修改的、不会再发生变化的数据。</li></ul></li><li>无级联回滚调度是并发事务的期望特性。</li></ul><table><thead><tr><th style="text-align:left">无级联回滚调度示例</th><th style="text-align:left">可恢复调度示例</th></tr></thead><tbody><tr><td style="text-align:left">Tᵢ: <code>write(Q)</code></td><td style="text-align:left">Tᵢ: <code>write(Q)</code></td></tr><tr><td style="text-align:left">Tᵢ: <code>commit</code></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">Tⱼ: <code>read(Q)</code></td><td style="text-align:left">Tⱼ: <code>read(Q)</code></td></tr><tr><td style="text-align:left">Tⱼ: <code>commit</code></td><td style="text-align:left">Tᵢ: <code>commit</code></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">Tⱼ: <code>commit</code></td></tr></tbody></table><ul><li><strong>关系</strong>：<ul><li>无级联回滚调度<strong>必定是</strong>可恢复调度。</li><li>但可恢复调度<strong>不一定</strong>是无级联回滚调度。</li></ul></li></ul><hr><h3 id="例题分析">例题分析</h3><ul><li><strong>考虑事务</strong> T₁, T₂, T₃, T₄ 在调度S下并发访问关系表 <code>Student</code> 和 <code>Grade</code>。</li><li><strong>问题</strong>：<ol><li>为S构建前驱图。</li><li>S是否是可串行化调度？如果不是，说明原因。</li><li>S是否是可恢复调度？为什么？</li><li>S是否是无级联回滚调度？为什么？</li></ol></li></ul><p><strong>给定调度S的操作顺序</strong>（详见课件第72页表格）：</p><ul><li>涉及对<code>Student</code>表的更新（<code>stuName</code>, <code>age</code>, <code>height</code>）和读取，对<code>Grade</code>表的更新和读取，以及各事务的<code>COMMIT</code>顺序。</li></ul><p><strong>分析结果</strong>（根据课件第73-75页）：</p><ol><li><strong>(1) 前驱图</strong>：存在从T₁到T₂的冲突边（T₁修改<code>stuID=10</code>的<code>stuName</code>，T₂随后读取它）。分析其他冲突边后可构建图，图中应无回路。</li><li><strong>(2) 可串行化</strong>：是（前驱图中无回路，因此是冲突可串行化的）。</li><li><strong>(3) 可恢复性</strong>：<strong>不是</strong>。因为T₂读取了T₁修改但<strong>尚未提交</strong>的<code>stuName</code>，而T₂的<code>COMMIT</code>操作早于T₁的<code>COMMIT</code>。如果T₁后来回滚，T₂已提交的读取结果无法撤销。</li><li><strong>(4) 无级联回滚</strong>：<strong>不是</strong>。因为它不是可恢复调度，且T₂读取了未提交的数据。</li></ol><hr><h2 id="附录-17-1-SQL-Server-中的事务">附录 17-1 SQL Server 中的事务</h2><h3 id="三种事务执行模式">三种事务执行模式</h3><ol><li><p><strong>显式事务</strong></p><ul><li>由 <code>BEGIN TRANSACTION</code> 和 <code>COMMIT</code> 或 <code>ROLLBACK</code> 界定。</li><li>由用户/应用程序定义，<strong>由用户显式控制</strong>。</li><li>例如：账户转账事务。</li></ul></li><li><p><strong>自动提交事务</strong>（<strong>SQL Server 默认模式</strong>）</p><ul><li>在此模式下，<strong>每条单独的</strong> Transact-SQL 语句本身就是一个事务。</li><li>语句成功完成则提交，失败则回滚该语句。</li><li>例如：<code>UPDATE SC SET Grade=Grade+10</code>，如果导致某成绩超过100而违反约束，则该<code>UPDATE</code>语句被回滚。</li></ul></li><li><p><strong>隐性事务</strong></p><ul><li>通过 <code>SET IMPLICIT_TRANSACTIONS ON</code> 设置。</li><li>在此模式下，事务无需用<code>BEGIN TRANSACTION</code>显式开始。当前事务以<code>COMMIT</code>或<code>ROLLBACK</code>结束时，系统自动开始下一个事务，形成连续的事务链。</li><li>每个事务仍需要显式结束。</li></ul></li></ol><hr><h3 id="SQL-Server-批处理中的事务">SQL Server 批处理中的事务</h3><ul><li><strong>批处理</strong>：包含一个或多个SQL语句的组，从客户端一次性发送到服务器执行。</li><li><strong>事务与批的关系</strong>：多对多。<ul><li>一个事务可包含多个批，一个批中也可有多个事务。</li></ul></li><li><strong>默认行为（<code>SET XACT_ABORT OFF</code>）</strong>：<ul><li>当批中的某些语句执行出错时，DBMS停止执行当前及后续语句，但<strong>出错前已成功执行的语句有效，不会被回滚</strong>。这可能破坏事务原子性。</li></ul></li><li><strong>确保原子性</strong>：<ul><li>在批提交前，使用 <code>SET XACT_ABORT ON</code>。</li><li>这样，任何运行时错误都会导致<strong>整个事务</strong>回滚。</li></ul></li></ul><p><strong>示例对比</strong>：</p><ul><li><code>SET XACT_ABORT OFF</code>：<code>INSERT</code> 成功，<code>UPDATE</code> 违反约束回滚，但<code>INSERT</code>结果保留 → 违反原子性。</li><li><code>SET XACT_ABORT ON</code>：<code>UPDATE</code> 违反约束 → 整个事务（包括<code>INSERT</code>）回滚 → 保证原子性。</li></ul><hr><h2 id="附录-17-2-保存点">附录 17-2 保存点</h2><ul><li><strong><code>SAVEPOINT</code></strong> 语句在事务执行过程中定义<strong>中间点/状态</strong>。<ul><li>使用保存点可以将相关语句分组，标识事务内的重要状态。</li></ul></li><li><strong><code>ROLLBACK TO SAVEPOINT</code></strong> 语句可以撤销该保存点之后的所有更改，将事务的执行<strong>回退</strong>到之前的状态。</li></ul><p><strong>示例</strong>（图17.0.14）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">USE student<span class="operator">-</span>DB</span><br><span class="line"><span class="keyword">INSERT INTO</span> student <span class="keyword">VALUES</span> (&quot;03402&quot;, &quot;王菲&quot;, &quot;CS&quot;, &quot;2000/05/15&quot;)</span><br><span class="line">SAVE TRAN My_savepoint <span class="comment">/* 定义保存点 */</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> name<span class="operator">=</span>&quot;王菲&quot; <span class="keyword">OR</span> name<span class="operator">=</span>&quot;章立&quot;</span><br><span class="line"><span class="keyword">ROLLBACK</span> TRAN My_savepoint <span class="comment">/* 回滚到保存点 */</span></span><br><span class="line"><span class="keyword">COMMIT</span> TRAN</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<code>ROLLBACK</code> 到 <code>My_savepoint</code> 仅撤销了 <code>DELETE</code> 操作，而 <code>INSERT</code> 操作不被撤销。数据库恢复到<code>DELETE</code>执行前的状态，新插入的元组仍然存在。</li></ul><p><strong>数据库实例变化</strong>（图17.0.15）：</p><ul><li>(a) 事务开始前。</li><li>(b) <code>INSERT</code> 执行后。</li><li>(c) <code>DELETE</code> 执行后（删除了“王菲”和“章立”）。</li><li>(d) <code>ROLLBACK</code> 到保存点后（恢复了被删除的“王菲”和“章立”）。</li></ul><hr><h2 id="第17章-事务：大纲概要">第17章 事务：大纲概要</h2><h3 id="I-事务概念与特性">I. 事务概念与特性</h3><ul><li>17.1 事务概念<ul><li>读写 vs. 输入输出</li><li>ACID特性</li></ul></li><li>17.2 简单事务模型</li></ul><h3 id="II-事务原子性与持久性">II. 事务原子性与持久性</h3><ul><li>17.4 事务状态模型与A、D特性保障</li></ul><h3 id="III-多事务并发执行">III. 多事务并发执行</h3><ul><li>17.5 事务隔离性</li><li>17.6 可串行化（正确的并发调度，无故障时）</li></ul><h3 id="IV-正确的并发调度（考虑故障时）">IV. 正确的并发调度（考虑故障时）</h3><ul><li>17.7 事务隔离性与原子性<ul><li>可恢复调度与无级联回滚调度</li></ul></li></ul><h3 id="V-事务在SQL中的实现">V. 事务在SQL中的实现</h3><ul><li>17.8 事务隔离级别（一致性与并发性的权衡）<ul><li><code>SERIALIZABLE</code>, <code>REPEATABLE READ</code>, <code>READ COMMITTED</code>, <code>READ UNCOMMITTED</code></li></ul></li><li>17.9 隔离级别的实现<ul><li>锁、时间戳、多版本与快照隔离</li></ul></li><li>17.10 SQL语句中的事务</li><li>附录：SQL Server中的事务、保存点</li></ul><p>（注：课件末尾列出了17.8-17.13等章节标题，但具体内容未在提供的PDF中展开。）</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§16 Query Optimization 解读</title>
      <link href="/2025/12/28/DB_QueryOptim/"/>
      <url>/2025/12/28/DB_QueryOptim/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库查询优化-讲义">数据库查询优化  讲义</h3><h2 id="第一章：查询优化概述">第一章：查询优化概述</h2><h3 id="1-1-查询优化的必要性与定义">1.1 查询优化的必要性与定义</h3><h4 id="1-1-1-问题背景">1.1.1 问题背景</h4><p>在数据库系统中，一个SQL查询语句可以对应<strong>多个等价的关系代数表达式</strong>。例如，连接操作的顺序不同、选择操作的位置不同，都会产生不同的执行路径。这些不同的执行路径在实际执行时会产生<strong>显著不同的代价</strong>，包括磁盘I/O次数、CPU处理时间、内存使用量等。</p><h4 id="1-1-2-查询优化的核心目标">1.1.2 查询优化的核心目标</h4><p><strong>查询优化</strong>就是数据库管理系统（DBMS）在多个等价的执行计划中，自动选择并生成一个<strong>代价最低或接近最低的评估计划</strong>的过程。其根本目的是在保证查询结果正确的前提下，最小化查询执行的总成本。</p><h4 id="1-1-3-示例：一个简单查询的多种可能">1.1.3 示例：一个简单查询的多种可能</h4><p>考虑一个简单的连接查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> r, s <span class="keyword">WHERE</span> r.A <span class="operator">=</span> s.A;</span><br></pre></td></tr></table></figure><p>这个查询至少对应两种关系代数表达式：</p><ol><li>先做笛卡尔积再做选择：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>A</mi><mo>=</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow></msub><mo>(</mo><mi>r</mi><mo>×</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{r.A = s.A}(r \times s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm">.</span><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">s</span><span class="mord mathrm">.</span><span class="mord mathit">A</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">×</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span></li><li>直接做等值连接：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><msub><mo>⋈</mo><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>A</mi><mo>=</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>A</mi></mrow></msub><mi>s</mi></mrow><annotation encoding="application/x-tex">r \bowtie_{r.A = s.A} s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.505em;"></span><span class="strut bottom" style="height:0.655em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm">.</span><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">s</span><span class="mord mathrm">.</span><span class="mord mathit">A</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">s</span></span></span></span></li></ol><p>显然，第二种方式（直接连接）的效率远高于第一种（先做代价高昂的笛卡尔积）。查询优化器的任务之一，就是避免生成第一种低效的计划。</p><h3 id="1-2-评估计划的组成">1.2 评估计划的组成</h3><p>一个完整的<strong>评估计划</strong>需要明确两件事：</p><ol><li><p><strong>操作算法</strong>：为计划中的每个关系代数操作（选择、投影、连接等）选择具体的实现算法。</p><ul><li>例如，选择操作是用线性扫描还是索引扫描？连接操作是用嵌套循环、归并连接还是哈希连接？</li></ul></li><li><p><strong>执行协调</strong>：确定操作之间的执行协调方式。</p><ul><li>是采用<strong>物化</strong>策略（将中间结果临时存储到磁盘），还是采用<strong>流水线</strong>策略（一个操作的输出直接作为下一个操作的输入）？</li></ul></li></ol><p><strong>图示示例：一个包含流水线的评估计划</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">       Π_&#123;name, title&#125; (去除重复)</span><br><span class="line">               |</span><br><span class="line">         (归并连接 Merge Join)</span><br><span class="line">               |</span><br><span class="line">        ---------------</span><br><span class="line">       |               |</span><br><span class="line">  (流水线)         (流水线)</span><br><span class="line">       |               |</span><br><span class="line">Π_&#123;ID, name&#125;     Π_&#123;course_id, title&#125;</span><br><span class="line">       |               |</span><br><span class="line">σ_&#123;dept_name=&#x27;Music&#x27;&#125;   (使用索引1)</span><br><span class="line">       |               |</span><br><span class="line">  instructor          course</span><br></pre></td></tr></table></figure><p><em>图：一个包含了归并连接、流水线传递和索引访问的查询评估计划示例</em></p><h3 id="1-3-查询优化的三阶段流程">1.3 查询优化的三阶段流程</h3><p>查询优化是一个系统化的过程，通常分为三个阶段：</p><h4 id="阶段一：生成等价表达式">阶段一：生成等价表达式</h4><ul><li><strong>输入</strong>：由查询解析器产生的初始关系代数表达式或查询树。</li><li><strong>过程</strong>：应用一系列<strong>等价规则</strong>（如选择下推、连接交换律等），对初始表达式进行变换，生成一系列在逻辑上等价的候选表达式。</li><li><strong>输出</strong>：一组等价的查询树/表达式集合。</li></ul><h4 id="阶段二：生成候选评估计划">阶段二：生成候选评估计划</h4><ul><li><strong>过程</strong>：为第一阶段生成的每个等价表达式，<strong>标注</strong>上具体的物理操作算法和协调策略。<ul><li>例如，标注某个选择操作使用&quot;在<code>salary</code>属性上的B+树索引查找（算法A2）&quot;。</li><li>标注两个关系的连接使用&quot;基于哈希的连接算法&quot;。</li></ul></li><li><strong>输出</strong>：一组完整的、可执行的<strong>候选评估计划</strong>。</li></ul><h4 id="阶段三：选择最优计划">阶段三：选择最优计划</h4><ul><li><strong>过程</strong>：基于数据库系统的<strong>统计信息</strong>（如关系的大小、属性的取值分布、索引的存在等），估算每个候选计划的执行代价。</li><li><strong>方法</strong>：<ol><li><strong>基于代价的优化</strong>：建立一个代价模型，精确或近似计算每个计划的代价，选择最小的。</li><li><strong>启发式优化</strong>：应用一系列经验规则（&quot;启发式&quot;），快速选择一个大概率较优的计划，不进行精确的代价比较。</li></ol></li><li><strong>输出</strong>：一个被选中的、优化后的查询评估计划，交由查询执行引擎运行。</li></ul><h2 id="第二章：关系表达式的等价转换">第二章：关系表达式的等价转换</h2><h3 id="2-1-等价性的严格定义">2.1 等价性的严格定义</h3><p>两个关系代数表达式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是<strong>等价的</strong>，记作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>≡</mo><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_1 \equiv E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≡</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，当且仅当对于<strong>任何合法的数据库实例</strong>（即任何符合模式的数据集合），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的计算结果都产生<strong>完全相同的元组集合</strong>（包括顺序，如果考虑有序关系）。</p><p>等价转换是查询优化的代数基础，它保证了我们变换查询形式时，不会改变查询结果的正确性。</p><h3 id="2-2-核心等价规则详解">2.2 核心等价规则详解</h3><h4 id="规则1：选择操作的串接律-Cascading-of-Selections"><strong>规则1：选择操作的串接律 (Cascading of Selections)</strong></h4><ul><li><strong>公式</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo><mo>=</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1 \wedge \theta_2}(E) = \sigma_{\theta_1}(\sigma_{\theta_2}(E))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>含义</strong>：一个包含AND（合取）的选择条件，可以拆分为两个连续的选择操作。顺序可以任意。</li><li><strong>作用</strong>：为后续将单个选择条件下推到表达式树的不同分支创造条件。</li><li><strong>示例</strong>：查找工资高于5万且属于计算机系的教师。<ul><li>原式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo>&gt;</mo><mn>5</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn><mo>∧</mo><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi mathvariant="normal">.</mi><mi>S</mi><mi>c</mi><mi>i</mi><msup><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{salary&gt;50000 \wedge dept\_name=&#x27;Comp. Sci.&#x27;}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">&gt;</span><span class="mord mathrm">5</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mbin">∧</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathrm">.</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li><li>可转换为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>r</mi><mi>y</mi><mo>&gt;</mo><mn>5</mn><mn>0</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>C</mi><mi>o</mi><mi>m</mi><mi>p</mi><mi mathvariant="normal">.</mi><mi>S</mi><mi>c</mi><mi>i</mi><msup><mi mathvariant="normal">.</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{salary&gt;50000}(\sigma_{dept\_name=&#x27;Comp. Sci.&#x27;}(instructor))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mrel">&gt;</span><span class="mord mathrm">5</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathit">o</span><span class="mord mathit">m</span><span class="mord mathit">p</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit">c</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathrm">.</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h4 id="规则2：选择操作的交换律-Commutativity-of-Selections"><strong>规则2：选择操作的交换律 (Commutativity of Selections)</strong></h4><ul><li><strong>公式</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo><mo>)</mo><mo>=</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1}(\sigma_{\theta_2}(E)) = \sigma_{\theta_2}(\sigma_{\theta_1}(E))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>含义</strong>：多个连续选择操作的执行顺序可以任意交换。</li><li><strong>作用</strong>：结合规则1，使得优化器可以灵活地安排选择条件的评估顺序，例如将选择性更强（能过滤掉更多元组）的条件先执行。</li></ul><h4 id="规则3：投影操作的串接律-Cascading-of-Projections"><strong>规则3：投影操作的串接律 (Cascading of Projections)</strong></h4><ul><li><strong>公式</strong>：若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>⊆</mo><msub><mi>L</mi><mn>2</mn></msub><mo>⊆</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>⊆</mo><msub><mi>L</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">L_1 \subseteq L_2 \subseteq ... \subseteq L_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⊆</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mrel">⊆</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，则<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mi>n</mi></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo><mo>)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>)</mo><mo>)</mo><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{L_1}(\Pi_{L_2}(...(\Pi_{L_n}(E))...)) = \Pi_{L_1}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">n</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mclose">)</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span></li><li><strong>含义</strong>：如果一串投影操作中，每个后续的投影属性列表都包含前一个的，那么只有最后一个投影是必要的。</li><li><strong>作用</strong>：在优化过程中，可以消除中间不必要的投影操作。</li><li><strong>示例</strong>：只需要教师的ID。<ul><li>原式：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi></mrow></msub><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{ID}(\Pi_{ID, name}(instructor))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>可简化为：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{ID}(instructor)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><h4 id="规则4：用连接操作替代选择和笛卡尔积"><strong>规则4：用连接操作替代选择和笛卡尔积</strong></h4><p>这是将低效操作转换为高效操作的关键规则。</p><ul><li><strong>公式4a</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mi>θ</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>×</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mi>θ</mi></msub><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\sigma_\theta(E_1 \times E_2) = E_1 \bowtie_\theta E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><strong>公式4b</strong>：更一般地，选择条件可以下推到笛卡尔积的一个操作数上：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>×</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><msub><mo>⋈</mo><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1 \wedge \theta_2}(E_1 \times E_2) = (\sigma_{\theta_1}(E_1)) \bowtie_{\theta_2} E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">×</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><br>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 只涉及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是连接条件或涉及两个关系的条件。</li><li><strong>含义与作用</strong>：优化器应<strong>始终避免显式生成笛卡尔积</strong>。任何计划中如果出现笛卡尔积后接选择，都应转换为等价的连接操作。连接算法（如嵌套循环、哈希、归并）的效率远高于计算完整的笛卡尔积。</li><li><strong>示例</strong>：查询Music系的教师及其授课信息。<ul><li>低效原式（理论上，优化器应避免生成）：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>∧</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi mathvariant="normal">.</mi><mi>I</mi><mi>D</mi><mo>=</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mi mathvariant="normal">.</mi><mi>I</mi><mi>D</mi></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>×</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{instructor.dept\_name=&#x27;Music&#x27; \wedge instructor.ID=teaches.ID}(instructor \times teaches)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm">.</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mrel">=</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">×</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span></li><li>优化后：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><msub><mo>⋈</mo><mrow><mi>I</mi><mi>D</mi></mrow></msub><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">\sigma_{dept\_name=&#x27;Music&#x27;}(instructor) \bowtie_{ID} teaches</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span></span></span></span></li></ul></li></ul><h4 id="规则5：连接操作的交换律-Commutativity-of-Theta-Joins"><strong>规则5：连接操作的交换律 (Commutativity of Theta Joins)</strong></h4><ul><li><strong>公式</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mi>θ</mi></msub><msub><mi>E</mi><mn>2</mn></msub><mo>=</mo><msub><mi>E</mi><mn>2</mn></msub><msub><mo>⋈</mo><mi>θ</mi></msub><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1 \bowtie_\theta E_2 = E_2 \bowtie_\theta E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><strong>含义</strong>：连接操作的左右操作数可以交换。</li><li><strong>作用</strong>：这对于选择连接顺序至关重要。它允许优化器将<strong>尺寸较小的关系</strong>作为连接操作的<strong>外关系</strong>。</li><li><strong>性能分析</strong>：<ul><li>考虑嵌套循环连接：外层关系<code>r</code>有<code>m</code>个元组，内层关系<code>s</code>有<code>n</code>个元组。</li><li>如果<code>s</code>有基于连接属性<code>A</code>的B+树索引，则连接代价约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>m</mi><mo>+</mo><mi>m</mi><msub><mi>log</mi><mi>d</mi></msub><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(m + m \log_d n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="vlist"><span style="top:0.24444em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">d</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span>，其中<code>d</code>是B+树的度。</li><li>如果<code>r</code>有索引，则代价约为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>+</mo><mi>n</mi><msub><mi>log</mi><mi>d</mi></msub><mi>m</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n + n \log_d m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="vlist"><span style="top:0.24444em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">d</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">m</span><span class="mclose">)</span></span></span></span>。</li><li><strong>结论</strong>：应将<strong>元组数少的关系作为外关系</strong>。因为<code>m</code>或<code>n</code>的系数是1，而乘以对数项的系数是另一个关系的大小。通常让较小的关系驱动循环更优。</li><li><strong>形式化推导</strong>：设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.5391em;"></span><span class="strut bottom" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="base textstyle uncramped"><span class="mord mathit">m</span><span class="mrel">&lt;</span><span class="mord mathit">n</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>=</mo><mi>k</mi><mo>∗</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n = k * m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit">n</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">∗</span><span class="mord mathit">m</span></span></span></span> (k&gt;1)。比较两种顺序的代价差：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>n</mi><mo>+</mo><mi>n</mi><mi>lg</mi><mi>m</mi><mo>)</mo><mo>−</mo><mo>(</mo><mi>m</mi><mo>+</mo><mi>m</mi><mi>lg</mi><mi>n</mi><mo>)</mo><mo>=</mo><mo>(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi>m</mi><mi>lg</mi><mi>m</mi><mo>−</mo><mi>m</mi><mi>lg</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">(n + n \lg m) - (m + m \lg n) = (k-1)m \lg m - m \lg k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord mathit">n</span><span class="mbin">+</span><span class="mord mathit">n</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">m</span><span class="mclose">)</span><span class="mbin">−</span><span class="mopen">(</span><span class="mord mathit">m</span><span class="mbin">+</span><span class="mord mathit">m</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">n</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.03148em;">k</span><span class="mbin">−</span><span class="mord mathrm">1</span><span class="mclose">)</span><span class="mord mathit">m</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit">m</span><span class="mbin">−</span><span class="mord mathit">m</span><span class="mop">l<span style="margin-right:0.01389em;">g</span></span><span class="mord mathit" style="margin-right:0.03148em;">k</span></span></span></span><br>当<code>m</code>和<code>k</code>不太小时，该值通常为正，说明 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>r</mi><mo>⋈</mo><mi>s</mi></mrow><annotation encoding="application/x-tex">r \bowtie s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.505em;"></span><span class="strut bottom" style="height:0.51em;vertical-align:-0.005em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">⋈</span><span class="mord mathit">s</span></span></span></span> (小⋈大) 的代价低于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mo>⋈</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">s \bowtie r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.505em;"></span><span class="strut bottom" style="height:0.51em;vertical-align:-0.005em;"></span><span class="base textstyle uncramped"><span class="mord mathit">s</span><span class="mrel">⋈</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span> (大⋈小)。</li></ul></li></ul><h4 id="规则6：连接操作的结合律-Associativity-of-Joins"><strong>规则6：连接操作的结合律 (Associativity of Joins)</strong></h4><ul><li><strong>公式6a（自然连接）</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>⋈</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>⋈</mo><msub><mi>E</mi><mn>3</mn></msub><mo>=</mo><msub><mi>E</mi><mn>1</mn></msub><mo>⋈</mo><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>⋈</mo><msub><mi>E</mi><mn>3</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(E_1 \bowtie E_2) \bowtie E_3 = E_1 \bowtie (E_2 \bowtie E_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>公式6b（θ连接）</strong>：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><msub><mo>⋈</mo><mrow><msub><mi>θ</mi><mn>2</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>3</mn></msub></mrow></msub><msub><mi>E</mi><mn>3</mn></msub><mo>=</mo><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>3</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><msub><mo>⋈</mo><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><msub><mi>E</mi><mn>3</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(E_1 \bowtie_{\theta_1} E_2) \bowtie_{\theta_2 \wedge \theta_3} E_3 = E_1 \bowtie_{\theta_1 \wedge \theta_3} (E_2 \bowtie_{\theta_2} E_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><ul><li>其中 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 只涉及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">E_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性。</li></ul></li><li><strong>含义与作用</strong>：多表连接的顺序可以改变。这是<strong>连接顺序优化</strong>的代数基础。通过改变结合顺序，可以优先连接产生较小中间结果的关系对，从而降低整个查询的代价。</li></ul><h4 id="规则7：选择操作对连接的分配律"><strong>规则7：选择操作对连接的分配律</strong></h4><p>这是&quot;尽早执行选择&quot;原则的代数依据。</p><ul><li><strong>公式7a</strong>：如果选择条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\theta_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> <strong>只涉及</strong> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性，则<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>⋈</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>0</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><mo>⋈</mo><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\sigma_{\theta_0}(E_1 \bowtie E_2) = (\sigma_{\theta_0}(E_1)) \bowtie E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">0</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><strong>公式7b</strong>：如果选择条件是合取式 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1 \wedge \theta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>，且 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\theta_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 只涉及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\theta_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 只涉及 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性，则<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>⋈</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1 \wedge \theta_2}(E_1 \bowtie E_2) = (\sigma_{\theta_1}(E_1)) \bowtie (\sigma_{\theta_2}(E_2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⋈</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>作用</strong>：将选择操作从连接之后&quot;下推&quot;到连接之前，甚至下推到单个关系上。这能<strong>显著减少参与连接操作的数据量</strong>，是降低连接代价最有效的手段之一。</li></ul><h4 id="规则8：投影操作对连接的分配律"><strong>规则8：投影操作对连接的分配律</strong></h4><p>这是&quot;尽早执行投影&quot;原则的代数依据。</p><ul><li><strong>公式8a（简单情况）</strong>：设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性子集，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 的属性子集。如果连接条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span></span> 涉及的所有属性都包含在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_1 \cup L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中，那么：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mi>θ</mi></msub><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><msub><mo>⋈</mo><mi>θ</mi></msub><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{L_1 \cup L_2}(E_1 \bowtie_\theta E_2) = (\Pi_{L_1}(E_1)) \bowtie_\theta (\Pi_{L_2}(E_2))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>公式8b（复杂情况）</strong>：如果连接条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span></span> 涉及一些不在最终投影列表 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_1 \cup L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中的属性，那么下推投影时，必须把这些属性也保留下来，否则无法进行连接。<ul><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">L_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中参与连接条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span></span> 但不在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">L_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中的属性。</li><li>设 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">L_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">E_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中参与连接条件 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.69444em;"></span><span class="strut bottom" style="height:0.69444em;vertical-align:0em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span></span> 但不在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 中的属性。</li><li>则：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><msub><mo>⋈</mo><mi>θ</mi></msub><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub></mrow></msub><mo>[</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>3</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>)</mo><msub><mo>⋈</mo><mi>θ</mi></msub><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><msub><mi>L</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>4</mn></msub></mrow></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>)</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">\Pi_{L_1 \cup L_2}(E_1 \bowtie_\theta E_2) = \Pi_{L_1 \cup L_2}[ (\Pi_{L_1 \cup L_3}(E_1)) \bowtie_\theta (\Pi_{L_2 \cup L_4}(E_2)) ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit">L</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">4</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span></li></ul></li><li><strong>作用</strong>：在连接前就剔除那些后续操作和最终结果都不需要的属性，减少每个元组的大小。这能降低数据在磁盘和内存之间传输的代价，并允许更多的元组装入同一个内存块或缓冲区。</li></ul><h4 id="规则9-12：集合操作的规则"><strong>规则9-12：集合操作的规则</strong></h4><ul><li><strong>规则9</strong>：并集(∪)和交集(∩)满足<strong>交换律</strong>；差集(−)不满足。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>2</mn></msub><mo>=</mo><msub><mi>E</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1 \cup E_2 = E_2 \cup E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>E</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>E</mi><mn>2</mn></msub><mo>=</mo><msub><mi>E</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>E</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">E_1 \cap E_2 = E_2 \cap E_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><strong>规则10</strong>：并集和交集满足<strong>结合律</strong>。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>∪</mo><msub><mi>E</mi><mn>3</mn></msub><mo>=</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∪</mo><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>3</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(E_1 \cup E_2) \cup E_3 = E_1 \cup (E_2 \cup E_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∩</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>∩</mo><msub><mi>E</mi><mn>3</mn></msub><mo>=</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∩</mo><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>∩</mo><msub><mi>E</mi><mn>3</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(E_1 \cap E_2) \cap E_3 = E_1 \cap (E_2 \cap E_3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∩</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∩</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>规则11</strong>：选择操作对并、交、差满足<strong>分配律</strong>。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mi>θ</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mi>σ</mi><mi>θ</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>∪</mo><msub><mi>σ</mi><mi>θ</mi></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_\theta(E_1 \cup E_2) = \sigma_\theta(E_1) \cup \sigma_\theta(E_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span><br>（交和差同理）</li><li><strong>规则12</strong>：投影操作对并集满足<strong>分配律</strong>。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>∪</mo><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_L(E_1 \cup E_2) = \Pi_L(E_1) \cup \Pi_L(E_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∪</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">∪</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></li><li><strong>注意</strong>：投影对交集和差集<strong>不满足</strong>分配律。例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>−</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo><mo>≠</mo><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>1</mn></msub><mo>)</mo><mo>−</mo><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub><mo>(</mo><msub><mi>E</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_L(E_1 - E_2) \neq \Pi_L(E_1) - \Pi_L(E_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">−</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">≠</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mbin">−</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.05764em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span>，因为可能有一些元组在投影后变得相同，在右边会被错误地消除。</li></ul><h3 id="2-3-综合转换示例">2.3 综合转换示例</h3><h4 id="示例一：选择下推-Pushing-Selections"><strong>示例一：选择下推 (Pushing Selections)</strong></h4><ul><li><strong>查询</strong>：找出Music系所有教师的姓名及其所授课程的名称。</li><li><strong>初始表达式</strong>（连接后进行选择和投影）：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>⋈</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>⋈</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}(\sigma_{dept\_name=&#x27;Music&#x27;}(instructor \bowtie teaches \bowtie \Pi_{course\_id, title}(course)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">⋈</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>应用规则7a</strong>：将选择操作下推到它只涉及的关系上。<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>⋈</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}( (\sigma_{dept\_name=&#x27;Music&#x27;}(instructor)) \bowtie teaches \bowtie \Pi_{course\_id, title}(course) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>效果</strong>：连接操作<code>instructor ⋈ teaches</code>现在只需处理<code>instructor</code>中属于Music系的一小部分元组，而不是全部，代价大大降低。</li></ul><h4 id="示例二：结合律与选择下推结合"><strong>示例二：结合律与选择下推结合</strong></h4><ul><li><strong>查询</strong>：找出在2019年授课的Music系教师的姓名及其课程名称。</li><li><strong>初始表达式</strong>：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>∧</mo><mi>y</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>=</mo><mn>2</mn><mn>0</mn><mn>1</mn><mn>9</mn></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>⋈</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>⋈</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}( \sigma_{dept\_name=&#x27;Music&#x27; \wedge year=2019}(instructor \bowtie teaches \bowtie \Pi_{course\_id, title}(course)) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">⋈</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>步骤1：应用结合律（规则6）</strong>，明确连接顺序。假设优化器决定先连接<code>instructor</code>和<code>teaches</code>。</li><li><strong>步骤2：应用选择分配律（规则7b）</strong>，将合取选择拆开并下推：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>y</mi><mi>e</mi><mi>a</mi><mi>r</mi><mo>=</mo><mn>2</mn><mn>0</mn><mn>1</mn><mn>9</mn></mrow></msub><mo>(</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}( (\sigma_{dept\_name=&#x27;Music&#x27;}(instructor)) \bowtie (\sigma_{year=2019}(teaches)) \bowtie \Pi_{course\_id, title}(course) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">y</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord mathrm">0</span><span class="mord mathrm">1</span><span class="mord mathrm">9</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li><strong>效果</strong>：两个连接操作<code>(σ_instructor) ⋈ (σ_teaches)</code>都在已经被大幅过滤的小关系上进行，效率极高。</li></ul><h4 id="示例三：投影下推"><strong>示例三：投影下推</strong></h4><p>继续<strong>示例一</strong>的优化后表达式：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>⋈</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}( (\sigma_{dept\_name=&#x27;Music&#x27;}(instructor)) \bowtie teaches \bowtie \Pi_{course\_id, title}(course) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mrel">⋈</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><ul><li><p><strong>分析中间结果模式</strong>：</p><ul><li><code>σ_{dept\_name='Music'}(instructor)</code> 的模式: <code>(ID, name, dept_name, salary)</code></li><li><code>teaches</code> 的模式: <code>(ID, course_id, sec_id, semester, year)</code></li><li>它们连接后的模式包含所有属性，但最终我们只需要<code>name</code>和<code>title</code>。<code>title</code>来自<code>course</code>表，通过<code>course_id</code>连接。</li></ul></li><li><p><strong>应用投影下推（规则8）</strong>：</p><ul><li>对<code>instructor</code>分支：最终需要<code>name</code>，连接需要<code>ID</code>。因此投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>I</mi><mi>D</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{name, ID}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。</li><li>对<code>teaches</code>分支：连接需要<code>ID</code>和<code>course_id</code>，最终结果需要<code>course_id</code>（用于连接<code>course</code>表）。因此投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><msub><mi>e</mi><mi>i</mi></msub><mi>d</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{ID, course_id}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord"><span class="mord mathit">e</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。</li><li>对<code>course</code>分支：已投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{course\_id, title}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。</li></ul></li><li><p><strong>最终优化表达式</strong>：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>I</mi><mi>D</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><mi>M</mi><mi>u</mi><mi>s</mi><mi>i</mi><msup><mi>c</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>i</mi><mi>n</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>I</mi><mi>D</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi></mrow></msub><mo>(</mo><mi>t</mi><mi>e</mi><mi>a</mi><mi>c</mi><mi>h</mi><mi>e</mi><mi>s</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>t</mi><mi>i</mi><mi>t</mi><mi>l</mi><mi>e</mi></mrow></msub><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>e</mi><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{name, title}( (\Pi_{name, ID}(\sigma_{dept\_name=&#x27;Music&#x27;}(instructor))) \bowtie (\Pi_{ID, course\_id}(teaches)) \bowtie (\Pi_{course\_id, title}(course)) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.117em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">i</span><span class="mord"><span class="mord mathit">c</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">u</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.07847em;">I</span><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">t</span><span class="mord mathit">e</span><span class="mord mathit">a</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mord mathit">e</span><span class="mord mathit">s</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">t</span><span class="mord mathit">i</span><span class="mord mathit">t</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit">c</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p></li><li><p><strong>效果</strong>：每个中间关系都只包含最少的必要属性，数据体积最小化，I/O和内存开销显著降低。</p></li></ul><h2 id="第三章：连接顺序优化">第三章：连接顺序优化</h2><h3 id="3-1-问题的重要性">3.1 问题的重要性</h3><p>对于涉及多个关系（例如3个以上）的连接查询，可能的连接顺序数量随着关系数增长而呈指数级增长（是卡特兰数）。不同的连接顺序会产生大小差异巨大的中间结果，从而导致总执行代价的天壤之别。</p><h3 id="3-2-核心原则">3.2 核心原则</h3><p>连接顺序优化的基本原则是：<strong>使执行过程中产生的临时关系最小化</strong>。</p><ul><li>更小的中间结果意味着：更少的磁盘写入/读取、更少的内存占用、更快的后续处理速度。</li><li>实现这一原则的策略是：<strong>优先连接产生最小结果集的关系对</strong>。</li></ul><h3 id="3-3-基于启发式的连接排序">3.3 基于启发式的连接排序</h3><p>虽然没有统计信息时无法精确判断，但一些启发式规则很有用：</p><ol><li><strong>进行有选择操作的关系优先连接</strong>：如果某个关系上有能大幅过滤元组的选择条件（如<code>dept_name='Music'</code>），那么先对这个关系进行选择，再与其他关系连接。因为选择后关系变小了。</li><li><strong>小关系优先连接</strong>：如果已知某些关系本身很小（元组数少），让它们先连接。</li><li><strong>使用有索引的外键关系优先连接</strong>：如果一个关系可以通过索引快速连接到另一个关系，这种连接方式成本较低，可以优先考虑。</li></ol><h3 id="3-4-结合统计信息的动态规划算法（简述）">3.4 结合统计信息的动态规划算法（简述）</h3><p>在实际的基于代价的优化器中（如System R的优化器），常使用动态规划算法来选择多表连接顺序：</p><ol><li><strong>基础</strong>：对于单个关系，最佳计划就是访问它的最佳方式（全表扫描或索引扫描）。</li><li><strong>递推</strong>：对于关系集合S，其最佳连接计划可以通过考察所有将S划分为两个非空子集S1和S2的方式，计算 <code>最佳计划(S1) ⋈ 最佳计划(S2)</code> 的代价，并取最小值。</li><li><strong>代价估算</strong>：每一步的代价估算都需要利用数据库的统计信息，如：<ul><li>每个关系R的元组数 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∣</mi><mi>R</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|R|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathrm">∣</span></span></span></span></li><li>每个属性A的不同值数量 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi><mo>(</mo><mi>A</mi><mo separator="true">,</mo><mi>R</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">V(A, R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathit">A</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></li><li>属性的最小值/最大值</li><li>索引的深度、叶节点数等</li></ul></li><li><strong>剪枝</strong>：搜索空间巨大，需要利用代价上界等进行剪枝。</li></ol><h2 id="第四章：评估计划的选择与启发式优化">第四章：评估计划的选择与启发式优化</h2><h3 id="4-1-查询优化的最终任务">4.1 查询优化的最终任务</h3><p>为给定的关系代数表达式生成一个<strong>物理执行计划</strong>，该计划：</p><ol><li><strong>逻辑正确</strong>：能产生与原表达式完全相同的结果。</li><li><strong>代价较低</strong>：相较于其他候选计划，其预估执行代价较小。</li><li><strong>可执行</strong>：明确了每个操作的算法和资源使用方式。</li></ol><h3 id="4-2-启发式优化：基于经验的快速优化">4.2 启发式优化：基于经验的快速优化</h3><p>由于基于代价的优化搜索空间大、统计信息可能不准或缺失，<strong>启发式优化</strong>是一种实用且高效的替代方案。它不追求数学上的最优解，而是应用一套经验证明有效的规则，快速得到一个&quot;足够好&quot;的计划。</p><h4 id="4-2-1-核心启发式规则"><strong>4.2.1 核心启发式规则</strong></h4><ol><li><p><strong>尽早执行选择操作 (Perform selection early)</strong>：</p><ul><li>理由：选择操作通常能大幅减少元组数量。元组越少，后续所有操作（投影、连接、集合操作）的代价都越低。</li><li>实现：利用规则1, 2, 7，将σ操作尽可能下推到查询树的叶节点。</li></ul></li><li><p><strong>尽早执行投影操作 (Perform projection early)</strong>：</p><ul><li>理由：投影操作减少每个元组的宽度（属性数）。更窄的元组意味着在磁盘和内存间传输时，每个块能容纳更多元组，减少I/O次数；同样大小的内存缓冲区能容纳更多元组。</li><li>实现：利用规则3, 8，在保证连接条件属性不丢失的前提下，将Π操作下推。</li></ul></li><li><p><strong>用连接操作替代笛卡尔积 (Replace Cartesian product by join)</strong>：</p><ul><li>理由：笛卡尔积的代价是乘积级的 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>R</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|R|*|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathrm">∣</span><span class="mbin">∗</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span>，而等值连接的代价可以低很多（如有索引可到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi mathvariant="normal">∣</mi><mi>R</mi><mi mathvariant="normal">∣</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi mathvariant="normal">∣</mi><mi>S</mi><mi mathvariant="normal">∣</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(|R| * log|S|)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.00773em;">R</span><span class="mord mathrm">∣</span><span class="mbin">∗</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathrm">∣</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">∣</span><span class="mclose">)</span></span></span></span> 级别）。</li><li>实现：利用规则4，优化器在生成计划时应避免任何显式的笛卡尔积，总是直接生成连接。</li></ul></li><li><p><strong>先执行最严格的操作 (Perform the most restrictive operation first)</strong>：</p><ul><li>理由：&quot;最严格&quot;的操作指能产生最小输出结果的操作。先执行它们能为后续操作创造更小的输入。</li><li>实现：结合统计信息或简单启发式（如等值条件通常比范围条件严格，小表上的选择比大表上的选择严格），对操作排序。</li></ul></li></ol><h4 id="4-2-2-启发式优化的系统化步骤"><strong>4.2.2 启发式优化的系统化步骤</strong></h4><p>可以将启发式规则整合为一个系统化的查询树转换流程：</p><p><strong>步骤1：分解合取选择</strong></p><ul><li>应用规则1，将形如 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>∧</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow></msub><mo>(</mo><mi>E</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1 \wedge \theta_2 \wedge ...}(E)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span></span></span></span> 的表达式分解为一系列单个选择 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>1</mn></msub></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><msub><mi>θ</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>(</mo><mi>E</mi><mo>)</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{\theta_1}(\sigma_{\theta_2}(... (E)...))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.005em;vertical-align:-0.255em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15000000000000002em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">θ</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mclose">)</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mord mathrm">.</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</li><li><strong>目的</strong>：为每个独立的选择条件下推创造条件。</li></ul><p><strong>步骤2：选择操作下推</strong></p><ul><li>对查询树从根到叶进行遍历。</li><li>对于每一个选择操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mi>θ</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：<ul><li>应用规则2（交换律）和规则7（分配律），尝试将其下推穿过其子操作（如连接、笛卡尔积、并集等）。</li><li>目标是让每个 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mi>θ</mi></msub></mrow><annotation encoding="application/x-tex">\sigma_\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">θ</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 都尽可能靠近叶节点，最终作用在单个基关系上。</li></ul></li><li><strong>目的</strong>：实现&quot;尽早选择&quot;。</li></ul><p><strong>步骤3：重新安排叶节点（连接顺序）</strong></p><ul><li>应用规则5（交换律）和规则6（结合律），对查询树中的叶节点（基关系）进行重新排序。</li><li><strong>启发式</strong>：将具有<strong>最严格选择条件</strong>（即能产生最小结果集）的关系，安排在连接顺序中尽可能早的位置。</li><li><strong>目的</strong>：让连接操作从一开始就在小关系上进行。</li></ul><p><strong>步骤4：用连接替代笛卡尔积和选择</strong></p><ul><li>查找查询树中任何&quot;笛卡尔积(×)后接选择(σ)&quot;的模式。</li><li>应用规则4，将其直接替换为一个θ连接操作(⋈)。</li><li><strong>目的</strong>：消除代价极高的笛卡尔积。</li></ul><p><strong>步骤5：投影操作下推</strong></p><ul><li>对查询树从根到叶进行遍历。</li><li>对于每一个投影操作 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>L</mi></msub></mrow><annotation encoding="application/x-tex">\Pi_L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">L</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>：<ul><li>应用规则3（串接律消除冗余投影）和规则8（分配律），尝试将其下推。</li><li>下推时需特别注意保留连接条件所需的属性（规则8b的复杂情况）。</li></ul></li><li><strong>目的</strong>：实现&quot;尽早投影&quot;，减少数据体积。</li></ul><h3 id="4-3-综合示例分析">4.3 综合示例分析</h3><h4 id="示例一：查询成绩-90的男生姓名"><strong>示例一：查询成绩&gt;90的男生姓名</strong></h4><p><strong>1. 数据库模式：</strong></p><ul><li><code>S(S#, sname, age, sex)</code></li><li><code>SC(S#, C#, grade)</code></li></ul><p><strong>2. SQL查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> sname</span><br><span class="line"><span class="keyword">FROM</span> S, SC</span><br><span class="line"><span class="keyword">WHERE</span> S.s# <span class="operator">=</span> SC.s# <span class="keyword">AND</span> sex<span class="operator">=</span><span class="string">&#x27;M&#x27;</span> <span class="keyword">AND</span> grade <span class="operator">&gt;</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 初始关系代数表达式（可能由解析器生成）：</strong><br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mn>1</mn><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>S</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi><mo>=</mo><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi><mo>∧</mo><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>∧</mo><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mo>×</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">E1 = \Pi_{sname}(\sigma_{S.s\#=SC.s\# \wedge sex=&#x27;M&#x27; \wedge grade&gt;90}(S \times SC))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">1</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span><span class="mbin">∧</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mbin">×</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p><p><em>注意：这里出现了笛卡尔积，是优化器需要消除的低效形式。</em></p><p><strong>4. 启发式优化过程：</strong></p><ul><li><p><strong>Step 0 (假设更优的初始表达式)</strong>：实际优化器可能直接生成带连接的表达式：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><msup><mn>1</mn><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>∧</mo><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><msub><mo>⋈</mo><mrow><mi>S</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi><mo>=</mo><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">E1&#x27; = \Pi_{sname}(\sigma_{sex=&#x27;M&#x27; \wedge grade&gt;90}(S \bowtie_{S.s\#=SC.s\#} SC))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.751892em;"></span><span class="strut bottom" style="height:1.038em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord"><span class="mord mathrm">1</span><span class="vlist"><span style="top:-0.363em;margin-right:0.05em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle uncramped"><span class="mord scriptstyle uncramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br>我们从这个更合理的起点开始优化。</p></li><li><p><strong>Step 1 &amp; 2: 选择下推</strong></p><ul><li>应用规则7b：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup><mo>∧</mo><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mo>⋈</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>S</mi><mo>)</mo><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{sex=&#x27;M&#x27; \wedge grade&gt;90}(S \bowtie SC) = (\sigma_{sex=&#x27;M&#x27;}(S)) \bowtie (\sigma_{grade&gt;90}(SC))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mbin">∧</span><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mrel">⋈</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li><li>得到：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mn>2</mn><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>S</mi><mo>)</mo><mo>)</mo><msub><mo>⋈</mo><mrow><mi>S</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi><mo>=</mo><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">E2 = \Pi_{sname}( (\sigma_{sex=&#x27;M&#x27;}(S)) \bowtie_{S.s\#=SC.s\#} (\sigma_{grade&gt;90}(SC)) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">2</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul></li><li><p><strong>Step 5: 投影下推</strong></p><ul><li>分析：最终需要<code>sname</code>。连接条件是<code>S.s#=SC.s#</code>。因此：<ul><li>对S分支：需要<code>sname</code>和<code>s#</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{sname, s\#}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li>对SC分支：连接需要<code>s#</code>。最终结果不需要SC的任何属性，但连接需要<code>s#</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{s\#}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（但注意<code>grade&gt;90</code>的选择条件需要<code>grade</code>属性，所以投影必须在选择之后进行，且选择条件需要<code>grade</code>，所以投影无法完全下推到选择之前。这里我们先做选择，再做投影）。</li></ul></li><li>更精确的转换：利用规则8b。<ul><li>设最终投影列表 L = {sname}。</li><li>对于左子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>S</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{sex=&#x27;M&#x27;}(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>：需要保留属性 L1 = {sname}，以及连接属性 L3 = {s#}。所以先投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{sname, s\#}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（但选择条件<code>sex='M'</code>不需要额外属性，所以顺序可以是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>S</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{sname, s\#}(\sigma_{sex=&#x27;M&#x27;}(S))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>）。</li><li>对于右子树 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mi>C</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{grade&gt;90}(SC)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span></span></span></span>：最终结果不需要它的属性，连接属性 L4 = {s#}。所以先投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{s\#}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（但选择条件<code>grade&gt;90</code>需要<code>grade</code>，所以实际是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{s\#}(\sigma_{grade&gt;90}(SC))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>）。</li></ul></li><li>最终优化表达式：<br><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>E</mi><mn>4</mn><mo>=</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub><mo>(</mo><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>s</mi><mi>e</mi><mi>x</mi><msup><mo>=</mo><mrow><mi mathvariant="normal">′</mi></mrow></msup><msup><mi>M</mi><mrow><mi mathvariant="normal">′</mi></mrow></msup></mrow></msub><mo>(</mo><mi>S</mi><mo>)</mo><mo>)</mo><mo>)</mo><msub><mo>⋈</mo><mrow><mi>S</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi><mo>=</mo><mi>S</mi><mi>C</mi><mi mathvariant="normal">.</mi><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi mathvariant="normal">Π</mi><mrow><mi>s</mi><mi mathvariant="normal">#</mi></mrow></msub><mo>(</mo><msub><mi>σ</mi><mrow><mi>g</mi><mi>r</mi><mi>a</mi><mi>d</mi><mi>e</mi><mo>&gt;</mo><mn>9</mn><mn>0</mn></mrow></msub><mo>(</mo><mi>S</mi><mi>C</mi><mo>)</mo><mo>)</mo><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">E4 = \Pi_{sname}( (\Pi_{sname, s\#}(\sigma_{sex=&#x27;M&#x27;}(S))) \bowtie_{S.s\#=SC.s\#} (\Pi_{s\#}(\sigma_{grade&gt;90}(SC))) )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord mathit" style="margin-right:0.05764em;">E</span><span class="mord mathrm">4</span><span class="mrel">=</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">x</span><span class="mrel"><span class="mrel">=</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord"><span class="mord mathit" style="margin-right:0.10903em;">M</span><span class="vlist"><span style="top:-0.289em;margin-right:0.07142857142857144em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord scriptscriptstyle cramped"><span class="mord mathrm">′</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mrel"><span class="mrel">⋈</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span><span class="mrel">=</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mord mathrm">.</span><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">s</span><span class="mord mathrm">#</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.03588em;">g</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">d</span><span class="mord mathit">e</span><span class="mrel">&gt;</span><span class="mord mathrm">9</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.05764em;">S</span><span class="mord mathit" style="margin-right:0.07153em;">C</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li></ul></li></ul><p><strong>5. 最终优化的查询树：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">          Π_&#123;sname&#125;</span><br><span class="line">              |</span><br><span class="line">          ⋈_&#123;S.s#=SC.s#&#125;</span><br><span class="line">         /            \</span><br><span class="line">        /              \</span><br><span class="line">Π_&#123;sname, s#&#125;         Π_&#123;s#&#125;</span><br><span class="line">       |                  |</span><br><span class="line">σ_&#123;sex=&#x27;M&#x27;&#125;           σ_&#123;grade&gt;90&#125;</span><br><span class="line">       |                  |</span><br><span class="line">       S                  SC</span><br></pre></td></tr></table></figure><h4 id="示例二：保险数据库查询"><strong>示例二：保险数据库查询</strong></h4><p><strong>1. 数据库模式：</strong></p><ul><li><code>Person(driver-id, name, address)</code></li><li><code>Participated(driver-id, license, report-number, damage-amount)</code></li><li><code>Accident(report-number, date, location)</code></li><li><code>Car(...)</code> <em>（本查询未使用）</em></li></ul><p><strong>2. SQL查询：</strong> 找出2024年5月3日前在北京发生的交通事故的驾驶员姓名、车牌号和事故报告编号。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, license, Accident.report<span class="operator">-</span>number</span><br><span class="line"><span class="keyword">FROM</span> Person, Participated, Accident</span><br><span class="line"><span class="keyword">WHERE</span> Person.driver_id <span class="operator">=</span> Participated.driver_id</span><br><span class="line">  <span class="keyword">AND</span> Accident.report_number <span class="operator">=</span> Participated.report_number</span><br><span class="line">  <span class="keyword">AND</span> location<span class="operator">=</span><span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> <span class="type">date</span> <span class="operator">&lt;</span> <span class="string">&#x27;2024-05-03&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 优化过程与最终查询树：</strong></p><ul><li><strong>选择下推</strong>：将 <code>location='Beijing' AND date&lt;'2024-05-03'</code> 下推到 <code>Accident</code> 表。</li><li><strong>投影下推</strong>（在连接前仅保留必要属性）：<ul><li><code>Person</code> 表：最终需要<code>name</code>，连接需要<code>driver_id</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>d</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{driver\_id, name}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><code>Participated</code> 表：连接需要<code>driver_id</code>和<code>report_number</code>，最终需要<code>license</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>d</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">_</mi><mi>i</mi><mi>d</mi><mo separator="true">,</mo><mi>l</mi><mi>i</mi><mi>c</mi><mi>e</mi><mi>n</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><mi>r</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{driver\_id, license, report\_number}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">d</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">i</span><span class="mord mathit" style="margin-right:0.03588em;">v</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">i</span><span class="mord mathit">d</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">i</span><span class="mord mathit">c</span><span class="mord mathit">e</span><span class="mord mathit">n</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></li><li><code>Accident</code> 表：连接需要<code>report_number</code>，选择需要<code>location</code>和<code>date</code>，最终需要<code>report_number</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>r</mi><mi>e</mi><mi>p</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{report\_number}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:1.05033em;vertical-align:-0.367em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">e</span><span class="mord mathit">p</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">t</span><span class="mord mathrm" style="margin-right:0.02778em;">_</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（但选择条件需要<code>location, date</code>，所以先选择，再投影：\Pi_{report\_number}(\sigma_{location='Beijing' ∧ date<...}(Accident))）</li></ul></li><li><strong>连接顺序</strong>：由于<code>Accident</code>经过严格选择后可能变得很小，可以优先与<code>Participated</code>连接。</li><li><strong>最终优化查询树</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          Π_&#123;name, license, report-number&#125;</span><br><span class="line">                       |</span><br><span class="line">             ⋈_&#123;A.report# = P.report#&#125;</span><br><span class="line">            /                           \</span><br><span class="line">           /                             \</span><br><span class="line">Π_&#123;driver-id, name&#125;               ⋈_&#123;P.driver-id = Per.driver-id&#125;</span><br><span class="line">       |                                  |</span><br><span class="line">     Person                         --------------</span><br><span class="line">                                     /             \</span><br><span class="line">                                    /               \</span><br><span class="line">                      Π_&#123;driver-id, license, report#&#125;   Π_&#123;report#&#125;</span><br><span class="line">                               |                             |</span><br><span class="line">                         Participated               σ_&#123;loc=&#x27;Beijing&#x27;∧date&lt;...&#125;</span><br><span class="line">                                                          |</span><br><span class="line">                                                      Accident</span><br></pre></td></tr></table></figure><h4 id="示例四：银行数据库复杂查询"><strong>示例四：银行数据库复杂查询</strong></h4><p><strong>1. 数据库模式：</strong></p><ul><li><code>branch(branch-name, branch-city, assets)</code></li><li><code>loan(loan-number, branch-name, amount)</code></li><li><code>borrower(customer-name, loan-number, borrow-date)</code></li></ul><p><strong>2. SQL查询：</strong> 找出在Brooklyn市、资产超过10万美元的分行中，办理了贷款金额小于1000美元的客户姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer<span class="operator">-</span>name</span><br><span class="line"><span class="keyword">FROM</span> borrower, loan, branch</span><br><span class="line"><span class="keyword">WHERE</span> loan.loan<span class="operator">-</span>number <span class="operator">=</span> borrower.loan<span class="operator">-</span>number</span><br><span class="line">  <span class="keyword">AND</span> branch.branch<span class="operator">-</span>name <span class="operator">=</span> loan.branch<span class="operator">-</span>name</span><br><span class="line">  <span class="keyword">AND</span> branch<span class="operator">-</span>city<span class="operator">=</span><span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line">  <span class="keyword">AND</span> assets <span class="operator">&gt;</span> <span class="number">100000</span></span><br><span class="line">  <span class="keyword">AND</span> amount <span class="operator">&lt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p><strong>3. 两种视角的优化方案：</strong></p><ul><li><p><strong>方案一：逻辑优化（关系代数层面）</strong></p><ul><li><strong>选择下推</strong>：<ul><li>\sigma_{branch-city='Brooklyn' ∧ assets>100000} 下推到 <code>branch</code> 表。</li><li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>a</mi><mi>m</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mn>1</mn><mn>0</mn><mn>0</mn><mn>0</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\sigma_{amount&lt;1000}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.43056em;"></span><span class="strut bottom" style="height:0.60793em;vertical-align:-0.17737em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">o</span><span class="mord mathit">u</span><span class="mord mathit">n</span><span class="mord mathit">t</span><span class="mrel">&lt;</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span><span class="mord mathrm">0</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span> 下推到 <code>loan</code> 表。</li></ul></li><li><strong>投影下推</strong>：<ul><li><code>branch</code> 表：连接需要<code>branch-name</code>，最终结果不需要它的属性。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>b</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>h</mi><mo>−</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{branch-name}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（选择条件需要<code>branch-city, assets</code>，所以先选择再投影）。</li><li><code>loan</code> 表：连接需要<code>loan-number</code>和<code>branch-name</code>，最终结果不需要它的属性。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>l</mi><mi>o</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mo separator="true">,</mo><mi>b</mi><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>h</mi><mo>−</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{loan-number, branch-name}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mpunct">,</span><span class="mord mathit">b</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>（选择条件需要<code>amount</code>）。</li><li><code>borrower</code> 表：连接需要<code>loan-number</code>，最终需要<code>customer-name</code>。投影为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mrow><mi>c</mi><mi>u</mi><mi>s</mi><mi>t</mi><mi>o</mi><mi>m</mi><mi>e</mi><mi>r</mi><mo>−</mo><mi>n</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo separator="true">,</mo><mi>l</mi><mi>o</mi><mi>a</mi><mi>n</mi><mo>−</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\Pi_{customer-name, loan-number}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.68333em;"></span><span class="strut bottom" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="base textstyle uncramped"><span class="mord"><span class="mord mathrm">Π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit">c</span><span class="mord mathit">u</span><span class="mord mathit">s</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mord mathit">a</span><span class="mord mathit">m</span><span class="mord mathit">e</span><span class="mpunct">,</span><span class="mord mathit" style="margin-right:0.01968em;">l</span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mbin">−</span><span class="mord mathit">n</span><span class="mord mathit">u</span><span class="mord mathit">m</span><span class="mord mathit">b</span><span class="mord mathit">e</span><span class="mord mathit" style="margin-right:0.02778em;">r</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span>。</li></ul></li><li><strong>连接顺序</strong>：可以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>σ</mi><mi>b</mi></msub><mi>r</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>h</mi><mo>)</mo><mo>⋈</mo><mo>(</mo><msub><mi>σ</mi><mi>l</mi></msub><mi>o</mi><mi>a</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">(\sigma_branch) \bowtie (\sigma_loan)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">b</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mord mathit">c</span><span class="mord mathit">h</span><span class="mclose">)</span><span class="mrel">⋈</span><span class="mopen">(</span><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit" style="margin-right:0.01968em;">l</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mord mathit">o</span><span class="mord mathit">a</span><span class="mord mathit">n</span><span class="mclose">)</span></span></span></span> 先连接（产生在特定分行的、小额贷款的列表），再与 <code>borrower</code> 连接获取客户名。</li><li><strong>优化查询树（逻辑）</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          Π_&#123;customer-name&#125;</span><br><span class="line">                  |</span><br><span class="line">          ⋈_&#123;loan.loan# = borrower.loan#&#125;</span><br><span class="line">         /                                  \</span><br><span class="line">        /                                    \</span><br><span class="line">Π_&#123;customer-name, loan#&#125;              ⋈_&#123;branch.branch-name = loan.branch-name&#125;</span><br><span class="line">      |                                      |</span><br><span class="line">  borrower                            --------------</span><br><span class="line">                                       /             \</span><br><span class="line">                                      /               \</span><br><span class="line">                          Π_&#123;loan#, branch-name&#125;        Π_&#123;branch-name&#125;</span><br><span class="line">                                  |                            |</span><br><span class="line">                          σ_&#123;amount&lt;1000&#125;              σ_&#123;branch-city=&#x27;Brooklyn&#x27; ∧ assets&gt;100000&#125;</span><br><span class="line">                                  |                            |</span><br><span class="line">                                loan                          branch</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>方案二：物理优化（结合存储和索引）</strong><br>假设有以下物理结构：</p><ul><li><code>branch</code> 表：在 <code>(branch-city, assets)</code> 上有复合B+树索引。访问方式：<strong>索引查找(Index Seek)</strong> 找到满足条件的<code>branch-name</code>列表。</li><li><code>loan</code> 表：在 <code>amount</code> 上有B+树索引，在 <code>branch-name</code> 上有索引。访问方式：对 <code>amount&lt;1000</code> 进行<strong>索引扫描(Index Scan)</strong>，再与来自<code>branch</code>的<code>branch-name</code>列表进行过滤（可能用嵌套循环连接）。</li><li><code>borrower</code> 表：堆文件，在 <code>loan-number</code> 上有非聚簇索引。</li><li><strong>物理执行计划可能描述为</strong>：<ol><li>对 <code>branch</code> 使用索引查找，得到结果集B（<code>branch-name</code>列表）。</li><li>对 <code>loan</code> 使用在 <code>amount</code> 上的索引扫描，对每个扫描到的元组，检查其 <code>branch-name</code> 是否在集合B中（<strong>嵌套循环内连接</strong>），并通过 <code>loan-number</code> 上的索引查找 <code>borrower</code> 表（<strong>索引嵌套循环连接</strong>）。</li><li>从找到的 <code>borrower</code> 元组中提取 <code>customer-name</code>。</li></ol></li><li><strong>这个计划充分利用了现有索引，避免了全表扫描，尽管连接算法是嵌套循环，但由于内层有索引支持，效率依然很高。</strong></li></ul></li></ul><h2 id="第五章：总结与范畴">第五章：总结与范畴</h2><h3 id="5-1-为什么需要查询优化？">5.1 为什么需要查询优化？</h3><ul><li><strong>性能差异巨大</strong>：同一查询的不同执行计划，其代价可能相差数个数量级。</li><li><strong>用户透明性</strong>：让用户专注于声明&quot;要什么&quot;（SQL），而无需操心&quot;怎么要&quot;（执行细节）。</li><li><strong>系统资源高效利用</strong>：自动选择最佳计划，节省CPU、I/O和内存资源。</li></ul><h3 id="5-2-查询优化的三大支柱">5.2 查询优化的三大支柱</h3><ol><li><strong>关系表达式的等价转换（第16.2章）</strong>：代数基础。通过等价规则生成多个逻辑上等价的候选表达式。</li><li><strong>表达式结果的统计信息估算（第16.3章）</strong>：代价估算的基础。需要估算中间结果的大小（基数）、不同值数量、数据分布等。例如：<ul><li>选择操作的结果大小估算：依赖于选择条件的选择率。</li><li>连接操作的结果大小估算：依赖于连接属性的域大小和值的分布。</li></ul></li><li><strong>查询执行计划的选择（第16.4章）</strong>：综合应用前两者，从候选计划中选出代价最低的。</li></ol><h3 id="5-3-优化方法分类">5.3 优化方法分类</h3><ul><li><strong>基于代价的优化</strong>：<ul><li>优点：理论上能找到最优解。</li><li>缺点：搜索空间大，依赖准确的统计信息，优化过程本身有开销。</li><li>适用于：对性能要求极高、数据分布稳定的OLAP场景。</li></ul></li><li><strong>启发式优化</strong>：<ul><li>优点：简单、快速、开销小，不依赖精确统计信息。</li><li>缺点：可能错过最优计划，得到的是&quot;较好&quot;而非&quot;最好&quot;的计划。</li><li>适用于：OLTP场景或统计信息缺失时。</li></ul></li><li><strong>现代优化器</strong>：通常结合两者，先使用启发式规则大幅缩小搜索空间，再在剩余空间内进行基于代价的精细选择。</li></ul><h3 id="5-4-相关高级主题">5.4 相关高级主题</h3><ul><li><strong>物化视图（第16.5章）</strong>：将某些常用查询（尤其是包含聚集、连接的复杂查询）的结果预先计算并存储为真实的表。查询优化器可以重写用户查询，使其直接访问物化视图，从而避免昂贵的连接和计算开销。</li><li><strong>嵌套子查询优化</strong>：<ul><li>问题：SQL中的嵌套子查询（如<code>IN</code>, <code>EXISTS</code>, <code>&gt; ALL</code>等）通常以低效的&quot;逐行处理&quot;方式执行。</li><li>优化：将嵌套子查询&quot;去相关化&quot;，转换为等价的连接操作，从而可以利用连接优化技术。</li><li>例如：<code>SELECT * FROM r WHERE r.A IN (SELECT s.A FROM s)</code> 可以转换为 <code>SELECT DISTINCT r.* FROM r JOIN s ON r.A = s.A</code>。</li></ul></li></ul><p>通过学习本章内容，读者应能深入理解数据库查询优化器的工作原理，从而能够：</p><ol><li>编写更能被优化器高效处理的SQL语句。</li><li>理解数据库给出的执行计划，并据此进行性能调优。</li><li>在设计数据库模式（如索引、物化视图）时，考虑其对查询优化的影响。</li></ol><p><strong>—— 讲义结束 ——</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§15 Query Processing 简读</title>
      <link href="/2025/12/28/DB_QueryProcessing/"/>
      <url>/2025/12/28/DB_QueryProcessing/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库查询处理">数据库查询处理</h3><h2 id="一、查询处理概述">一、查询处理概述</h2><h3 id="1-1-查询处理的定义与目标">1.1 查询处理的定义与目标</h3><ul><li><strong>定义</strong>：查询处理是指DBMS从数据库中提取数据的一系列活动，包括：<ol><li>将<strong>高级查询语言</strong>（如SQL）<strong>翻译</strong>成可在物理层使用的表达式（如关系代数表达式）。</li><li>进行<strong>查询优化变换</strong>，寻找高效执行方案。</li><li><strong>实际执行</strong>查询并返回结果。</li></ol></li></ul><h3 id="1-2-查询处理的三个阶段">1.2 查询处理的三个阶段</h3><ol><li><p><strong>语法解析与翻译</strong></p><ul><li>检查SQL语句的<strong>语法正确性</strong>，验证关系/视图的存在性。</li><li>将<strong>视图</strong>替换为其定义的基础关系。</li><li>生成<strong>解析树</strong>，并翻译成<strong>关系代数表达式</strong>。</li></ul></li><li><p><strong>查询优化</strong></p><ul><li>从多个<strong>等价</strong>的关系代数表达式中，选择<strong>代价最低</strong>的查询执行计划。</li><li>代价估算基于数据字典中的统计信息（如元组数、元组大小等）。</li><li>优化后的执行计划会<strong>注解</strong>具体的评估策略，如使用哪个索引、采用哪种连接算法等。</li></ul></li><li><p><strong>执行</strong></p><ul><li><strong>查询执行引擎</strong>接收优化后的计划，执行它并将结果返回给用户。</li><li>在SQL Server等系统中，可查看查询执行计划及预估代价。</li></ul></li></ol><h2 id="二、查询代价的度量">二、查询代价的度量</h2><h3 id="2-1-代价的主要构成">2.1 代价的主要构成</h3><ul><li>总代价通常用<strong>总耗时</strong>来衡量，主要受以下因素影响：<ol><li><strong>磁盘访问</strong>（主导因素）</li><li>网络通信（分布式环境下）</li></ol></li></ul><h3 id="2-2-磁盘访问代价的细分">2.2 磁盘访问代价的细分</h3><p>代价 = <strong>磁盘块传输次数</strong> × <strong>平均传输时间</strong> + <strong>寻道次数</strong> × <strong>平均寻道时间</strong></p><ul><li><strong>平均寻道时间 (t_S)</strong>：包括寻道时间和旋转延迟。</li><li><strong>平均块传输时间 (t_T)</strong>：取决于磁盘内部传输速率。</li></ul><p><strong>简记</strong>：Cost = &lt;b, s&gt; = b * t_T + s * t_S</p><h3 id="2-3-现实考虑与缓冲">2.3 现实考虑与缓冲</h3><ul><li>算法可通过使用额外的<strong>缓冲区内存</strong>来减少磁盘I/O。</li><li>可用内存大小取决于并发查询和进程，优化时通常按<strong>最坏情况</strong>（最小可用内存）估算。</li><li>所需数据可能已缓存在内存中，避免磁盘I/O，但这一点在代价估算中难以准确考虑。</li></ul><h3 id="2-4-数据库系统内部I-O流程">2.4 数据库系统内部I/O流程</h3><ul><li><strong>逻辑读写</strong>：由事务发起（如<code>read(x)</code>, <code>write(y)</code>）。</li><li><strong>物理读写</strong>：<ul><li><code>input(X)</code>：将包含数据项X的磁盘页读入缓冲区。</li><li><code>output(Y)</code>：将修改后的缓冲区页写回磁盘。</li></ul></li><li><strong>缓冲区管理</strong>：采用LRU等策略进行页替换。</li></ul><h2 id="三、选择操作（Selection）的实现算法">三、选择操作（Selection）的实现算法</h2><h3 id="3-1-基本概念与查询条件类型">3.1 基本概念与查询条件类型</h3><ul><li><strong>选择操作</strong>：从关系<code>r</code>中检索满足条件的记录。</li><li><strong>查询条件类型</strong>：<ol><li><strong>等值条件</strong>（如<code>salary = 100</code>）</li><li><strong>范围条件</strong>（如<code>salary BETWEEN 50 AND 400</code>）</li><li><strong>比较条件</strong>（如<code>salary &gt; 300</code>），可视为范围查询的特例。</li></ol></li></ul><h3 id="3-2-算法分类">3.2 算法分类</h3><ul><li><strong>A1：线性扫描（文件扫描）</strong></li><li><strong>A2-A4：使用索引的选择</strong>（等值条件）</li><li><strong>A5-A6：涉及比较的选择</strong>（范围条件）</li><li><strong>A7-A10：复杂选择</strong>（合取、析取、否定）</li></ul><h3 id="3-3-各算法详解">3.3 各算法详解</h3><h4 id="A1：线性扫描"><strong>A1：线性扫描</strong></h4><ul><li>扫描关系的每一个块，测试所有记录。</li><li><strong>代价</strong>：<code>b_r</code>次块传输 + 1次寻道。<ul><li>若选择基于<strong>主键属性</strong>的等值条件，找到即可停止，平均代价为<code>(b_r/2)</code>次块传输 + 1次寻道。</li></ul></li><li><strong>适用性</strong>：适用于任何条件，无论记录顺序、有无索引。特别适合<strong>堆文件</strong>或对非索引属性的扫描。</li></ul><h4 id="A2：使用主索引（聚簇索引）的等值查询（针对键属性）"><strong>A2：使用主索引（聚簇索引）的等值查询（针对键属性）</strong></h4><ul><li>利用B+树主索引检索<strong>单个记录</strong>（如<code>ID=45565</code>）。</li><li><strong>代价</strong>：<code>(h_i + 1) * (t_T + t_S)</code>，其中<code>h_i</code>为树高。</li></ul><h4 id="A3：使用主索引的等值查询（针对非键属性）"><strong>A3：使用主索引的等值查询（针对非键属性）</strong></h4><ul><li>检索<strong>多个记录</strong>（如<code>branch_name='Perryridge'</code>），这些记录物理上连续存储。</li><li><strong>代价</strong>：<code>h_i * (t_T + t_S) + t_S + t_T * b</code>，其中<code>b</code>为包含匹配记录的块数。</li></ul><h4 id="A4：使用辅助索引的等值查询"><strong>A4：使用辅助索引的等值查询</strong></h4><ol><li><strong>针对键属性</strong>：检索单个记录，代价同A2。</li><li><strong>针对非键属性</strong>：检索<code>n</code>个记录，每个记录可能位于不同块。<ul><li><strong>代价</strong>：<code>(h_i + n) * (t_T + t_S)</code>，最坏情况下每个记录需一次I/O。</li></ul></li></ol><h4 id="A5：使用主索引的比较查询（范围查询）"><strong>A5：使用主索引的比较查询（范围查询）</strong></h4><ul><li>关系已按属性A排序（聚簇索引）。</li><li>对于<code>σ_A ≥ V(r)</code>：用索引找到第一个≥V的元组，然后顺序扫描。</li><li>对于<code>σ_A ≤ V(r)</code>：直接顺序扫描至第一个&gt;V的元组，不使用索引。</li><li><strong>代价</strong>：<code>h_i * (t_T + t_S) + t_S + t_T * b</code>，b为匹配记录所占块数。</li></ul><h4 id="A6：使用辅助索引的比较查询"><strong>A6：使用辅助索引的比较查询</strong></h4><ul><li>对于<code>σ_A ≥ V(r)</code>：用索引找到第一个≥V的索引项，然后顺序扫描索引叶节点获取记录指针。</li><li>对于<code>σ_A ≤ V(r)</code>：扫描索引叶节点直至第一个&gt;V的项，获取指针。</li><li><strong>代价</strong>：<code>(h_i + n) * (t_T + t_S)</code>，每个匹配记录可能需一次I/O。</li><li><strong>注意</strong>：当<code>n</code>较大时，线性扫描可能更便宜。</li></ul><h3 id="3-4-复杂选择的实现">3.4 复杂选择的实现</h3><h4 id="合取选择（AND条件）"><strong>合取选择（AND条件）</strong></h4><ul><li><strong>A7：使用一个索引</strong><ol><li>选择一个代价最低的条件<code>θ_i</code>，用索引检索满足该条件的元组。</li><li>在内存缓冲区中检查这些元组是否满足其余条件。</li></ol></li><li><strong>A8：使用复合索引</strong><ul><li>若有合适的多属性索引，直接使用。</li></ul></li><li><strong>A9：标识符交集法</strong><ul><li>对每个有条件索引的条件，分别获取记录指针集，然后取交集。</li><li>对无索引的条件，在内存中测试。</li></ul></li></ul><h4 id="析取选择（OR条件）"><strong>析取选择（OR条件）</strong></h4><ul><li><strong>A10：标识符并集法</strong><ul><li>若所有条件都有可用索引，分别获取指针集后取并集。</li><li>否则，退化为线性扫描。</li></ul></li></ul><h4 id="否定选择（NOT条件）"><strong>否定选择（NOT条件）</strong></h4><ul><li>通常使用线性扫描。</li><li>若满足否定的记录很少，且原条件<code>θ</code>有索引，可先通过索引找到满足<code>θ</code>的记录，再从文件中排除它们。</li></ul><h2 id="四、排序">四、排序</h2><h3 id="4-1-排序的重要性">4.1 排序的重要性</h3><ul><li>用于<code>ORDER BY</code>、<code>DISTINCT</code>、<code>GROUP BY</code>等子句。</li><li>连接操作前对关系排序可大幅提升效率（如归并连接）。</li><li>物理排序后可以建立有序索引（如B+树）。</li></ul><h3 id="4-2-外部排序算法（当数据量大于内存）">4.2 外部排序算法（当数据量大于内存）</h3><ol><li><p><strong>生成初始有序段</strong></p><ul><li>重复将M个块读入内存，排序后写回磁盘，形成有序段（Run）<code>R_i</code>。</li><li>设最终生成N个有序段。</li></ul></li><li><p><strong>归并有序段</strong></p><ul><li>使用多路归并，将多个有序段合并为更大的有序段，直至整个关系有序。</li><li>归并的趟数约为<code>⌈log_{M-1}(N)⌉</code>。</li></ul></li></ol><h2 id="五、表达式求值">五、表达式求值</h2><h3 id="5-1-两种基本策略">5.1 两种基本策略</h3><ul><li><p><strong>物化</strong>：</p><ul><li>逐步计算子表达式，将<strong>中间结果临时存储到磁盘</strong>，再作为输入进行下一步计算。</li><li>优点：实现简单。</li><li>缺点：产生额外的I/O开销。</li></ul></li><li><p><strong>流水线</strong>：</p><ul><li>多个操作<strong>同时执行</strong>，一个操作产生的元组<strong>立即传递</strong>给下一个操作，无需物化中间结果。</li><li>优点：极大减少I/O，提升效率。</li><li>示例：对于<code>Π_salary(σ_salary&lt;2500(instructor))</code>，选择操作一边输出元组，投影操作一边处理，无需等待全部选择完成。</li></ul></li></ul><h3 id="5-2-流水线执行的原理">5.2 流水线执行的原理</h3><ul><li>在内存中设立缓冲区，操作之间通过缓冲区传递数据。</li><li>可实现一定程度的并行，充分利用CPU和I/O资源。</li></ul><h2 id="六、总结">六、总结</h2><ul><li>查询处理是将高级查询转换为高效物理执行计划的过程。</li><li><strong>代价估算</strong>的核心是磁盘I/O（块传输和寻道）。</li><li><strong>选择操作</strong>的实现算法多样，需根据索引、条件类型和数据分布选择最优策略。</li><li><strong>排序</strong>是许多操作的基础，外部排序算法用于处理大数据集。</li><li><strong>表达式求值</strong>可采用物化或流水线策略，流水线能显著减少中间I/O。</li></ul><p>通过深入理解这些原理和算法，数据库系统设计者和开发者能够编写更高效的查询，并更好地进行系统调优。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§14 Indexing 解读</title>
      <link href="/2025/12/27/DB_Indexing/"/>
      <url>/2025/12/27/DB_Indexing/</url>
      
        <content type="html"><![CDATA[<h3 id="数据库索引原理与实现">数据库索引原理与实现</h3><h2 id="一、索引的基本概念与作用">一、索引的基本概念与作用</h2><h3 id="1-1-索引的定义与目的">1.1 索引的定义与目的</h3><ul><li><strong>索引</strong>是一种数据库结构，用于<strong>加速对表中数据的访问速度</strong>。</li><li>核心机制：建立从<strong>搜索键</strong>到记录<strong>物理存储位置</strong>的映射关系。</li><li><strong>示例</strong>：在<code>instructor(ID, name, dept_name, salary)</code>表的<code>dept_name</code>属性上建立索引，可实现<code>dept_name</code>→记录物理地址的快速映射。</li></ul><h3 id="1-2-核心术语">1.2 核心术语</h3><ul><li><strong>搜索键</strong>：用于查找记录的一个或多个属性（如<code>dept_name</code>）。</li><li><strong>索引文件</strong>：存储索引项的文件，结构为<code>(search-key, pointer)</code>。</li><li><strong>被索引文件</strong>：存储实际数据记录的文件。</li></ul><h3 id="1-3-物理存储说明">1.3 物理存储说明</h3><ul><li>被索引文件在<strong>逻辑上</strong>可以是顺序的，但<strong>物理上</strong>可能非连续或无序存储。</li><li>索引文件通常远小于原始数据文件。</li></ul><h2 id="二、索引的分类体系">二、索引的分类体系</h2><h3 id="2-1-按组织方式分类">2.1 按组织方式分类</h3><ol><li><p><strong>有序索引</strong></p><ul><li>索引项按搜索键值<strong>排序存储</strong>。</li><li>支持高效的范围查询和排序操作。</li></ul></li><li><p><strong>哈希索引</strong></p><ul><li>使用<strong>哈希函数</strong>将搜索键映射到存储位置（桶地址）。</li><li>记录存储在桶中，每个桶对应一个磁盘块。</li></ul></li></ol><h3 id="2-2-按与数据组织关系分类">2.2 按与数据组织关系分类</h3><ol><li><p><strong>主索引 / 聚簇索引</strong></p><ul><li><strong>定义</strong>：索引的搜索键顺序与被索引文件的物理记录顺序<strong>一致</strong>。</li><li><strong>特性</strong>：<ul><li>被索引文件必须是顺序文件。</li><li>一个表<strong>只能有一个</strong>聚簇索引。</li><li>当表定义了主键，DBMS通常会自动在主键上创建聚簇索引（此时该索引也是主索引）。</li></ul></li><li><strong>重要关系</strong>：<ul><li>主索引一定是聚簇索引。</li><li>聚簇索引不一定是主索引（可建立在非主键上）。</li><li>没有主键的表可以有聚簇索引，但没有主索引。</li></ul></li></ul></li><li><p><strong>辅助索引 / 非聚簇索引</strong></p><ul><li><strong>定义</strong>：索引的搜索键顺序与文件物理顺序<strong>不一致</strong>。</li><li><strong>特性</strong>：<ul><li>必须是<strong>稠密索引</strong>（每个搜索键值都有对应索引项）。</li><li>索引项指向一个<strong>桶</strong>，桶内包含指向具有该搜索键值的所有实际记录的指针。</li></ul></li></ul></li></ol><h3 id="2-3-按索引项覆盖度分类">2.3 按索引项覆盖度分类</h3><ol><li><p><strong>稠密索引</strong></p><ul><li>为被索引文件中<strong>每一个</strong>搜索键值都创建一个索引项。</li><li><strong>查找方式</strong>：直接通过索引项定位记录。</li></ul></li><li><p><strong>稀疏索引</strong></p><ul><li>只为<strong>部分</strong>搜索键值创建索引项。</li><li><strong>查找方式</strong>（针对搜索键值K）：<ol><li>找到索引项中搜索键值 ≤ K 的最大项。</li><li>从该索引项指向的记录开始，在数据文件中顺序扫描，直至找到目标记录。</li></ol></li></ul></li></ol><h3 id="2-4-多级索引">2.4 多级索引</h3><ul><li><strong>背景问题</strong>：当索引文件太大无法全部装入内存时，访问代价高。</li><li><strong>解决方案</strong>：将主索引视为顺序文件，并为其建立稀疏索引（称为<strong>外层索引</strong>）。</li><li><strong>可递归应用</strong>：若外层索引仍太大，可继续创建更高级别的索引。</li><li><strong>B+树和B树</strong>是高效、自动平衡的多级索引结构。</li></ul><h2 id="三、树形索引结构详解">三、树形索引结构详解</h2><h3 id="3-1-B-树索引">3.1 B+树索引</h3><ul><li><p><strong>本质</strong>：一种平衡的多路搜索树，广泛用作数据库索引。</p></li><li><p><strong>节点结构</strong>（以度<code>n</code>为例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| P1 | K1 | P2 | K2 | ... | P_&#123;n-1&#125; | K_&#123;n-1&#125; | Pn |</span><br></pre></td></tr></table></figure><ul><li><code>Ki</code>：搜索键值，且<code>K1 &lt; K2 &lt; ... &lt; K_{n-1}</code>。</li><li><code>Pi</code>：指针。在非叶节点中指向子节点；在叶节点中指向记录或记录桶。</li></ul></li><li><p><strong>核心性质</strong>：</p><ol><li><strong>平衡性</strong>：从根到所有叶节点的路径长度相同。</li><li><strong>节点容量</strong>（对于度<code>n</code>）：<ul><li><strong>内部节点（非根）</strong>：子节点数在 <code>⌈n/2⌉</code> 到 <code>n</code> 之间。</li><li><strong>叶节点</strong>：搜索键值数量在 <code>⌈(n-1)/2⌉</code> 到 <code>n-1</code> 之间。</li><li><strong>根节点</strong>：<ul><li>若非叶节点，至少有2个子节点。</li><li>若为叶节点，有0到<code>n-1</code>个值。</li></ul></li></ul></li><li><strong>叶节点连接</strong>：所有叶节点通过指针顺序链接，支持高效顺序扫描。</li></ol></li><li><p><strong>聚簇索引 vs 非聚簇索引在B+树中的体现</strong>：</p><ul><li><strong>聚簇索引</strong>：叶节点<strong>直接存储数据记录</strong>（或记录的主键块）。</li><li><strong>非聚簇索引</strong>：叶节点存储<code>(search-key, primary-key)</code>对，需要通过主键二次查找获取记录。</li></ul></li><li><p><strong>性能优势</strong>：</p><ul><li>逻辑上相邻的块物理上无需紧邻，通过指针连接。</li><li>树高为<code>O(log_{⌈n/2⌉}(K))</code>，其中K为不同搜索键数量，查询高效。</li><li><strong>注意</strong>：在如MySQL的实践中，为控制树深和内存占用，单表数据行数通常建议不超过2000万。</li></ul></li></ul><h3 id="3-2-B树索引">3.2 B树索引</h3><ul><li><strong>与B+树的核心区别</strong>：搜索键值在非叶节点中<strong>不重复出现</strong>在叶节点。</li><li><strong>节点结构变化</strong>：非叶节点中每个搜索键<code>Ki</code>需附带一个指向对应记录的指针<code>Bi</code>。</li><li><strong>优点</strong>：可能减少树节点总数，有时可在非叶节点直接找到记录。</li><li><strong>缺点</strong>：<ul><li>非叶节点体积更大，导致扇出降低。</li><li>插入和删除操作更复杂。</li><li>实践中不如B+树常用。</li></ul></li></ul><h3 id="3-3-非唯一键的索引处理">3.3 非唯一键的索引处理</h3><ul><li><strong>问题</strong>：当搜索键值不唯一时，如何建立索引？</li><li><strong>解决方案</strong>：建立<strong>复合索引</strong>，将非唯一键与一个唯一标识符（如主键）组合作为搜索键。</li><li><strong>查询方式</strong>：对复合键进行范围查询来查找特定非唯一键值。</li><li><strong>性能影响</strong>：<ul><li>若为聚簇索引，记录顺序存储，访问效率较高。</li><li>若为非聚簇索引，每个记录访问可能都需要一次I/O。</li></ul></li></ul><h2 id="四、哈希索引">四、哈希索引</h2><h3 id="4-1-基本机制">4.1 基本机制</h3><ul><li><strong>哈希函数h</strong>：将搜索键<code>K</code>映射到桶地址：<code>h(K) -&gt; bucket address</code>。</li><li><strong>桶</strong>：存储单元（通常为一个磁盘块），存放具有相同哈希值的记录或记录指针。</li><li><strong>两种形式</strong>：<ol><li><strong>哈希索引</strong>：桶中存储指向记录的指针。</li><li><strong>哈希文件组织</strong>：桶中直接存储记录。</li></ol></li></ul><h3 id="4-2-静态哈希-vs-动态哈希">4.2 静态哈希 vs 动态哈希</h3><ul><li><strong>静态哈希</strong>：哈希函数固定，桶数量不变。</li><li><strong>动态哈希</strong>：哈希函数可动态调整以适应数据增长（如可扩展哈希、线性哈希）。</li></ul><h3 id="4-3-桶溢出处理">4.3 桶溢出处理</h3><ul><li><strong>原因</strong>：<ol><li>桶数量不足。</li><li>数据分布不均（大量记录具有相同搜索键值或哈希函数不均匀）。</li></ol></li><li><strong>解决方法</strong>：<strong>溢出链法</strong><ul><li>为每个桶链接一个溢出桶链表。</li><li>当主桶满时，新记录存入溢出桶。</li></ul></li></ul><h3 id="4-4-哈希索引的适用场景">4.4 哈希索引的适用场景</h3><ul><li><strong>高效</strong>：<strong>等值查询</strong>（如<code>ID=10121</code>）。</li><li><strong>不适用</strong>：<strong>范围查询</strong>（如<code>age BETWEEN 17 AND 25</code>），此类查询应使用有序索引。</li></ul><h2 id="五、多键访问与复合索引">五、多键访问与复合索引</h2><h3 id="5-1-多条件查询策略">5.1 多条件查询策略</h3><p>对于查询：<code>SELECT ... WHERE dept_name='Finance' AND salary=80000</code></p><ol><li>使用<code>dept_name</code>索引找到记录，再筛选<code>salary</code>。</li><li>使用<code>salary</code>索引找到记录，再筛选<code>dept_name</code>。</li><li>分别使用两个索引获取指针集，再取交集。</li></ol><h3 id="5-2-复合索引">5.2 复合索引</h3><ul><li><strong>定义</strong>：搜索键包含多个属性，如<code>(dept_name, salary)</code>。</li><li><strong>排序规则</strong>：<strong>字典序</strong>。<ul><li><code>(a1, a2) &lt; (b1, b2)</code> 当且仅当 <code>a1 &lt; b1</code> 或 (<code>a1 = b1</code> 且 <code>a2 &lt; b2</code>)。</li></ul></li></ul><h3 id="5-3-左前缀原则">5.3 左前缀原则</h3><ul><li><strong>核心规则</strong>：复合索引<code>(A, B, C)</code>仅在查询条件使用了索引列的<strong>最左前缀</strong>时才最有效。</li><li><strong>示例</strong>（索引为<code>(dept_name, salary)</code>）：<ul><li><strong>高效</strong>：<ul><li><code>WHERE dept_name='Finance' AND salary=80000</code></li><li><code>WHERE dept_name='Finance' AND salary&lt;80000</code></li><li><code>WHERE dept_name='Finance'</code></li></ul></li><li><strong>低效或无法利用索引</strong>：<ul><li><code>WHERE dept_name&lt;'Finance' AND salary=80000</code>（范围查询打断了左前缀连续性）</li><li><code>WHERE salary=80000</code>（未使用最左列<code>dept_name</code>）</li></ul></li></ul></li></ul><h2 id="六、索引的定义、使用与维护">六、索引的定义、使用与维护</h2><h3 id="6-1-SQL中的索引定义">6.1 SQL中的索引定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> <span class="keyword">ON</span> <span class="operator">&lt;</span>relation_name<span class="operator">&gt;</span> (<span class="operator">&lt;</span>attribute_list<span class="operator">&gt;</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span> ...; <span class="comment">-- 隐式指定候选键</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">&lt;</span>index_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX b_idx <span class="keyword">ON</span> branch(branch_name);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX takes_pk <span class="keyword">ON</span> takes(ID, course_id, semester, <span class="keyword">year</span>, section);</span><br></pre></td></tr></table></figure><h3 id="6-2-强制使用-禁用索引（SQL-Server示例）">6.2 强制使用/禁用索引（SQL Server示例）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 强制使用特定索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbMROData <span class="keyword">WITH</span> (INDEX<span class="operator">=</span>timeidx) <span class="keyword">WHERE</span> <span class="type">TimeStamp</span><span class="operator">=</span><span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 禁用索引</span></span><br><span class="line"><span class="keyword">ALTER</span> INDEX timeidx <span class="keyword">ON</span> tbMRODatanew DISABLE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tbMRODatanew <span class="keyword">WHERE</span> <span class="type">TimeStamp</span><span class="operator">=</span><span class="string">&#x27;...&#x27;</span>; <span class="comment">-- 将不使用该索引</span></span><br></pre></td></tr></table></figure><h3 id="6-3-索引对各类操作的影响">6.3 索引对各类操作的影响</h3><table><thead><tr><th style="text-align:left">操作类型</th><th style="text-align:left">索引的潜在影响</th><th style="text-align:left">说明与示例</th></tr></thead><tbody><tr><td style="text-align:left"><strong>SELECT</strong></td><td style="text-align:left"><strong>通常加速</strong></td><td style="text-align:left">在WHERE、JOIN、GROUP BY、ORDER BY涉及的属性上建立索引可大幅提高速度。</td></tr><tr><td style="text-align:left"><strong>INSERT</strong></td><td style="text-align:left"><strong>通常减速</strong></td><td style="text-align:left">插入新记录后，DBMS需要更新所有相关索引，带来额外开销。</td></tr><tr><td style="text-align:left"><strong>DELETE</strong></td><td style="text-align:left"><strong>影响不一</strong></td><td style="text-align:left">- <strong>加速</strong>：如果WHERE条件能利用索引快速定位要删除的记录。<br>- <strong>减速</strong>：删除记录后，DBMS需要重组索引，带来开销。</td></tr><tr><td style="text-align:left"><strong>UPDATE</strong></td><td style="text-align:left"><strong>影响不一</strong></td><td style="text-align:left">- <strong>加速</strong>：如果WHERE条件能利用索引。<br>- <strong>减速</strong>：如果UPDATE修改了索引键的值，引发索引重组。<br><strong>示例</strong>：对<code>Student(ID, name)</code>在<code>ID</code>上建索引，<code>UPDATE ... SET ID=ID+1 WHERE ID&gt;20</code>会变慢，因为修改了索引键本身。</td></tr></tbody></table><h3 id="6-4-适宜建立索引的属性">6.4 适宜建立索引的属性</h3><ul><li><strong>WHERE子句</strong>中的查询条件属性（尤其是等值或范围条件）。</li><li><strong>连接操作</strong>（JOIN）中使用的属性。</li><li><strong>GROUP BY</strong>子句中的分组属性。</li><li><strong>ORDER BY</strong>子句中的排序属性。</li></ul><h2 id="七、综合例题解析">七、综合例题解析</h2><h3 id="7-1-索引选择与影响分析">7.1 索引选择与影响分析</h3><p><strong>给定表</strong>：</p><ul><li><code>factory(factoryID, name, manager, account)</code></li><li><code>employee(employeeID, name, age, factoryID)</code></li><li><code>airconditioner(serialID, date, model, price, factoryID)</code></li></ul><p><strong>问题1（加速SELECT）</strong>：</p><ul><li><strong>查询</strong>：涉及<code>factory</code>与<code>employee</code>连接，条件<code>age&gt;20</code>和<code>account&gt;30000</code>，按<code>factoryID</code>分组。</li><li><strong>推荐索引</strong>：<ol><li><code>employee.factoryID</code>：加速连接和GROUP BY。</li><li><code>employee.age</code>：加速筛选年龄&gt;20的记录。</li><li><code>factory.account</code>：加速筛选账户&gt;30000的记录。</li></ol></li></ul><p><strong>问题2（UPDATE影响）</strong>：</p><ul><li><strong>操作</strong>：<code>UPDATE airconditioner SET price=price+100 WHERE model='GL2020'</code></li><li><strong>索引</strong>：在<code>model</code>上有非聚簇索引。</li><li><strong>结论</strong>：<strong>加速</strong>。索引可快速定位<code>model='GL2020'</code>的记录，且未修改索引键<code>model</code>，无需重组索引。</li></ul><p><strong>问题3（DELETE影响）</strong>：</p><ul><li><strong>操作</strong>：<code>DELETE FROM airconditioner WHERE model='HX8302' AND price&gt;1500</code></li><li><strong>索引</strong>：在<code>serialID</code>上有主（聚簇）索引。</li><li><strong>结论</strong>：<strong>减速</strong>。WHERE条件无法利用<code>serialID</code>索引定位记录。删除后，DBMS需要重组主索引，增加开销。</li></ul><h3 id="7-2-复合索引左前缀原则应用">7.2 复合索引左前缀原则应用</h3><ul><li><strong>索引</strong>：<code>CREATE INDEX DMFIndex ON airconditioner(date, model, factoryID)</code></li><li><strong>查询分析</strong>：<ol><li><code>WHERE date='2021-11-30' AND model='Haier'</code>：<strong>有效</strong>，使用了最左两列。</li><li><code>WHERE date='2021-11-30' AND price&gt;2000</code>：<strong>部分有效</strong>，仅使用了最左列<code>date</code>，<code>price</code>无效。</li><li><code>WHERE date='2021-11-30' AND factoryID=1040</code>：<strong>部分有效</strong>，仅使用了最左列<code>date</code>，跳过了<code>model</code>，<code>factoryID</code>无法被索引高效利用。</li><li><code>WHERE model='Haier' AND factoryID=1040</code>：<strong>无效</strong>，未使用最左列<code>date</code>，索引无法用于加速查询。</li></ol></li></ul><h2 id="八、总结与前沿">八、总结与前沿</h2><ul><li><strong>索引是“空间换时间”的典型策略</strong>，通过额外存储开销换取查询速度提升。</li><li><strong>选择与设计索引需权衡</strong>：考虑查询模式、更新频率、数据分布和存储成本。</li><li><strong>自治数据库趋势</strong>：利用AI与机器学习技术实现索引的自动选择、创建与调优。</li><li><strong>核心原则</strong>：没有适用于所有场景的“最佳”索引，必须根据具体工作负载进行设计和优化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§13 Data Storage Structures 简读</title>
      <link href="/2025/12/27/DB_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2025/12/27/DB_%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h3 id="数据存储结构-—-第13章">数据存储结构 — 第13章</h3><h2 id="13-1-引言">13.1 引言</h2><p>物理数据库设计中的两个核心问题：</p><ol><li><strong>数据组织</strong>：即数据的物理存储结构 — 本章重点。</li><li><strong>数据访问</strong>：例如索引 — 第14章重点。</li></ol><p><strong>解决方案</strong>：</p><ol><li>选择合适的数据库<strong>物理结构</strong>。</li><li>设置合理的数据库表<strong>索引</strong>，提高数据查询速度。</li></ol><p><strong>本章大纲</strong>：</p><ul><li>文件组织（File Organization）</li><li>记录的组织方式（Organization of Records）</li><li>数据字典存储（Data-Dictionary Storage）</li><li>数据缓冲区（Data Buffer）</li><li>列式存储（Column-oriented Storage）</li></ul><hr><h2 id="13-2-文件组织">13.2 文件组织</h2><p><strong>文件组织/结构</strong>：</p><ul><li><strong>逻辑组织/结构</strong>：流式文件、记录文件、索引文件。</li><li><strong>物理组织/结构</strong>：以块（block）为单位，存储在二级存储（如磁盘）上。<br>特征包括：连续分配（contiguous）、链式分配（linked）、索引分配（indexed）。</li></ul><p><strong>数据库中的文件组织</strong>：</p><ul><li>数据库存储为一系列<strong>数据库文件</strong>（主文件、辅助文件、日志文件等）。</li><li>每个文件是<strong>记录</strong>的序列。</li><li>每个记录由一系列<strong>字段</strong>组成。</li></ul><p><strong>一种常见方法</strong>：</p><ul><li>记录<strong>长度固定</strong>。</li><li>每个文件仅存储<strong>一种特定类型</strong>的记录。</li><li>不同的关系（表）使用不同的文件。</li></ul><p><strong>关系表与文件的对应</strong>：</p><ul><li>每个关系表是一组元组（tuple）。</li><li>每个文件是记录的序列。</li><li>一个<strong>元组</strong>在数据库中存储为一个<strong>记录</strong>。</li><li>记录可以是<strong>定长</strong>或<strong>变长</strong>（例如 <code>VARCHAR(20)</code>）。</li></ul><h3 id="1-定长记录">1. 定长记录</h3><p><strong>简单方法</strong>：</p><ul><li>一个块包含多个记录。</li><li>记录 <em>i</em> 从字节 <code>n × (i - 1)</code> 开始存储，其中 <em>n</em> 为每个记录的大小。</li><li><strong>记录访问简单</strong>，但记录<strong>可能跨越块边界</strong>。</li></ul><p><strong>修改方案</strong>：不允许记录跨越块边界。</p><p><strong>示例</strong>：<br><code>instructor(ID, name, dept, salary)</code><br>所有记录存储在一个连续的空间中（连续分配）。</p><p><strong>记录的删除</strong>：</p><ol><li><strong>紧凑法</strong>：将记录 i+1, …, n 移动到 i, …, n-1。</li><li><strong>末尾移动法</strong>：将最后一个记录 n 移动到位置 i。</li><li><strong>空闲链表法</strong>：不移动记录，而是将所有空闲记录链接成一个<strong>空闲链表</strong>。</li></ol><p><strong>空闲链表</strong>：</p><ul><li>在文件头中存储<strong>第一个被删除记录的地址</strong>。</li><li>利用该记录存储第二个被删除记录的地址，依此类推。</li><li>这些地址可视为<strong>指针</strong>，指向记录位置。</li><li>记录可以存储在<strong>非连续空间</strong>中（链式分配）。</li></ul><h3 id="2-变长记录">2. 变长记录</h3><p><strong>变长记录的来源</strong>：</p><ul><li>记录类型允许变长字段（如字符串 <code>VARCHAR</code>）。</li><li>一个文件中包含<strong>多种记录类型</strong>（例如多表聚类文件）。</li></ul><p><strong>存储方法</strong>：</p><ol><li>属性按顺序存储。</li><li><strong>定长属性</strong>先存储。</li><li><strong>变长属性</strong>用固定大小的（偏移量，长度）表示，实际数据存储在所有定长属性之后。</li><li>空值用<strong>空值位图</strong>表示。</li></ol><p><strong>示例</strong>：<br><code>instructor: ID(5 varchar), name(10 varchar), dept(10 varchar), salary(8 int)</code><br>记录0存储在连续的46个字节（0-45）中，其中变长属性用 <code>&lt;偏移量, 长度&gt;</code> 表示。</p><h3 id="分槽页结构">分槽页结构</h3><ul><li>存储空间划分为<strong>固定大小的分槽页</strong>（如4KB或8KB）。</li><li>记录被分配到分槽页中。</li></ul><p><strong>分槽页头包含</strong>：</p><ul><li>记录条目数量（例如4）。</li><li>块中空闲空间的末尾位置。</li><li>每个记录的位置和大小。</li></ul><p><strong>特点</strong>：</p><ul><li>记录可以在页内移动以保持连续性。</li><li>删除记录 <em>rᵢ</em> 后，后续记录 <em>rᵢ₊₁, rᵢ₊₂, rᵢ₊₃</em> 可移动到删除释放的空间中。</li><li>页头中的条目需要更新（例如设置为-1）。</li><li><strong>指针不应直接指向记录</strong>，而应指向页头中该记录的<strong>条目</strong>。</li></ul><hr><h2 id="13-3-文件中记录的组织方式">13.3 文件中记录的组织方式</h2><ul><li>在逻辑层面，数据库文件可视为<strong>记录的集合</strong>。</li><li>记录的<strong>逻辑组织方式</strong>决定了<strong>访问方法</strong>（存取方法）。</li></ul><p><strong>四种逻辑组织方式</strong>：</p><ol><li><strong>堆文件</strong>（Heap）</li><li><strong>顺序文件</strong>（Sequential）</li><li><strong>聚类文件</strong>（Clustering）</li><li><strong>哈希文件</strong>（Hashing）</li></ol><h3 id="1-堆文件组织">1. 堆文件组织</h3><ul><li>记录可以放在文件中有空间的<strong>任何位置</strong>。</li><li>数据<strong>没有主键</strong>，<strong>没有索引</strong>。</li><li>记录一旦分配通常不移动。</li><li><strong>一个关系对应一个文件</strong>。</li></ul><p><strong>特点</strong>：</p><ul><li>记录按输入顺序存储，与主键无关。</li><li>例如：创建 <code>student(ID, name, total-credits)</code> 且不定义任何键或索引。</li></ul><p><strong>空闲空间映射</strong>：</p><ul><li>每个块一个条目，记录该块中<strong>空闲空间的比例</strong>。</li><li>示例：每块3位（0–7），值除以8表示空闲比例。</li><li>可设计<strong>二级空闲空间映射</strong>，例如每条目存储一级映射中最多4个条目的最大值。</li></ul><h3 id="2-顺序文件组织">2. 顺序文件组织</h3><ul><li>记录按<strong>搜索键</strong>（search-key）<strong>逻辑排序</strong>。</li><li>记录尽可能按搜索键顺序<strong>物理存储</strong>，以最小化顺序处理时的块访问次数。</li><li>通过<strong>指针链</strong>将记录按搜索键顺序链接起来。</li></ul><p><strong>适用场景</strong>：适合整个文件的顺序处理。</p><p><strong>插入与删除</strong>：</p><ul><li><strong>删除</strong>：使用指针链调整。</li><li><strong>插入</strong>：<ul><li>若有空闲空间，直接插入。</li><li>若无空闲空间，插入到<strong>溢出块</strong>中。</li><li>需更新指针链。</li></ul></li><li><strong>需要定期重组文件</strong>以恢复顺序性。</li></ul><h3 id="3-聚类文件组织">3. 聚类文件组织</h3><ul><li>使用<strong>多表聚类文件组织</strong>，将多个关系的记录存储在<strong>同一个文件</strong>中。</li><li><strong>动机</strong>：将相关的记录（如 <code>instructor</code> 和 <code>department</code>）存储在同一块中，以最小化I/O。</li></ul><p><strong>优点</strong>：对于涉及多表连接的查询（如 <code>department</code> ⨝ <code>instructor</code>）效率高。<br><strong>缺点</strong>：对于只涉及单个关系的查询，会导致变长记录问题。<br><strong>改进</strong>：可为特定关系的记录添加指针链。</p><h3 id="4-哈希文件组织">4. 哈希文件组织</h3><ul><li>文件记录存储在<strong>桶</strong>（bucket）中，桶号即记录地址。</li><li>基于某些属性（搜索键）的<strong>哈希函数</strong>决定记录的存储桶。</li><li>哈希函数 <code>h: {search-key} → {物理地址（桶号）}</code>。</li></ul><p><strong>示例</strong>：<br><code>account(ID, branch-name, balance)</code>，以 <code>branch-name</code> 为搜索键进行哈希组织。</p><hr><h2 id="13-4-数据字典存储">13.4 数据字典存储</h2><p><strong>数据字典（目录）存储元数据</strong>，包括：</p><ul><li>关系名称。</li><li>属性的名称、类型和长度。</li><li>视图的名称和定义。</li><li>完整性约束。</li><li>用户和账户信息、密码。</li><li>统计和描述性数据（如每个关系的元组数）。</li><li>物理文件组织信息（如存储方式、物理位置）。</li><li>索引信息。</li></ul><p><strong>表示方式</strong>：</p><ul><li>关系表示。</li><li>为高效内存访问设计的专用数据结构。</li></ul><hr><h2 id="13-5-数据缓冲区">13.5 数据缓冲区</h2><p><strong>定义</strong>：</p><ul><li><strong>块</strong>：数据库文件划分为固定长度的存储单元，是存储分配和数据传输的基本单位。</li><li><strong>缓冲区</strong>：主内存中用于存储<strong>磁盘块副本</strong>的部分。</li><li><strong>缓冲区管理器</strong>：负责在主内存中分配缓冲区空间。</li></ul><p><strong>目标</strong>：最小化磁盘与主内存之间的<strong>块传输次数</strong>。</p><p><strong>缓冲区管理器的工作流程</strong>：</p><ol><li>程序（请求者）需要磁盘块时，调用缓冲区管理器。</li><li>若块<strong>已在缓冲区</strong>，返回其在主内存中的地址。</li><li>若块<strong>不在缓冲区</strong>：<ol><li>在缓冲区中为块分配空间（必要时替换其他块）。</li><li>若被替换的块自上次写入后已被修改，则写回磁盘。</li><li>从磁盘读取块到缓冲区，并返回其主内存地址。</li></ol></li></ol><p><strong>关键概念</strong>：</p><ul><li><strong>钉住块</strong>：不允许写回磁盘的内存块。在读写数据前需 <code>pin</code>，完成后需 <code>unpin</code>。</li><li><strong>共享锁与排他锁</strong>：<ul><li>读操作需要<strong>共享锁</strong>。</li><li>更新操作需要<strong>排他锁</strong>。</li><li>锁定规则：<ul><li>一次只能有一个进程获得排他锁。</li><li>共享锁不能与排他锁并发。</li><li>多个进程可同时持有共享锁。</li></ul></li></ul></li></ul><p><strong>缓冲区替换策略</strong>：</p><ol><li><strong>最近最少使用</strong>：替换最久未使用的块。但某些访问模式（如嵌套循环连接）可能导致性能不佳。</li><li><strong>立即丢弃</strong>：块中最后一个元组处理完后立即释放其空间。</li><li><strong>最近最多使用</strong>：钉住当前正在处理的块，处理完后取消钉住，使其成为最近最多使用的块。</li></ol><p><strong>启发式策略</strong>：</p><ul><li>利用统计信息（如数据字典访问频繁）将常用块保留在缓冲区。</li><li>谨慎排序写操作，避免磁盘上数据结构损坏。</li></ul><hr><h2 id="13-6-列式存储">13.6 列式存储</h2><ul><li>也称为<strong>列式表示</strong>。</li><li>将关系的<strong>每个属性单独存储</strong>。</li></ul><p><strong>示例</strong>：<br><code>instructor(ID, Name, dept_name, salary)</code><br>更新操作仅需访问 <code>salary</code> 列。</p><p><strong>优点</strong>：</p><ul><li>若只访问部分属性，可减少I/O。</li><li>提高CPU缓存性能。</li><li>改进压缩效率。</li></ul><p><strong>缺点</strong>：</p><ul><li>从列式表示重构元组的成本较高。</li><li>元组删除和更新的成本较高。</li></ul><p><strong>适用场景</strong>：</p><ul><li>列式表示更适用于<strong>决策支持系统</strong>。</li><li>行式表示更适用于<strong>事务处理系统</strong>。</li></ul><hr><h2 id="附录13-1-数据组织与访问">附录13-1 数据组织与访问</h2><h3 id="数据组织">数据组织</h3><ul><li>对用户而言，数据组织为<strong>关系表、元组和属性</strong>（用户导向的逻辑组织）。</li><li>对操作系统而言，数据存储为<strong>操作系统文件</strong>（即数据库文件）。</li><li>数据库文件在逻辑上组织为<strong>记录的序列</strong>。</li><li>数据库文件驻留在二级存储（磁盘）上，以<strong>块</strong>为单位。</li></ul><p><strong>对应关系</strong>：</p><ul><li>1个元组 对应于 1个文件逻辑记录（定长或变长）。</li><li>1个关系表 对应于 1个OS文件（或1个文件存储多个关系表的数据）。</li><li>1个块 包含 多个文件逻辑记录。</li></ul><h3 id="数据访问">数据访问</h3><h4 id="小型数据库系统（如dBASE、FoxBASE）">小型数据库系统（如dBASE、FoxBASE）</h4><ul><li>关系表存储在单独文件中。</li><li>DBMS利用OS文件系统作为物理层基础。</li><li>用户通过OS文件系统访问数据，依赖度高，不利于移植。</li></ul><p><strong>地址映射过程</strong>：</p><ol><li>元组 → 逻辑地址（文件名，记录号）。</li><li>逻辑地址 → 物理地址（物理块号，具体地址）。</li></ol><h4 id="现代大型数据库系统（如SQL-Server、Oracle）">现代大型数据库系统（如SQL Server、Oracle）</h4><ul><li>DBMS向OS一次性申请外存空间（数据库文件）。</li><li>DBMS独立设计存储和访问结构，管理文件，提供访问机制。</li><li>支持动态扩容和压缩。</li></ul><p><strong>SQL Server案例</strong>：</p><ul><li>数据库由存储表和索引的磁盘空间构成，分配在一个或多个OS文件上。</li><li>数据库划分为逻辑<strong>页</strong>（每页8KB）。</li><li>页划分为<strong>槽</strong>，每槽存储一个数据行。</li><li>数据行的逻辑地址：<code>&lt;文件ID, 页ID, 槽ID&gt;</code>。</li><li>以<strong>盘区</strong>（64KB，连续8页）为单位分配物理空间。</li><li>使用全局分配映射（GAM）、共享全局分配映射（SGAM）和索引分配映射（IAM）管理空间和映射。</li><li>通过<strong>索引</strong>实现快速访问：<code>search-key → &lt;文件ID, 页ID, 槽ID&gt;</code>。</li></ul><h3 id="openGauss段页式存储管理">openGauss段页式存储管理</h3><ul><li>采用<strong>段—区—页/块</strong>的逻辑组织方式。</li><li>逻辑地址：<code>segment-extent-page/block</code>。</li></ul><p><strong>关键设计</strong>：</p><ol><li>每个数据库在一个表空间中有一个<strong>段空间</strong>，可跨多个物理文件。</li><li>每张表有一个逻辑<strong>段</strong>，所有数据存储在该段上。</li><li>每个段挂载多个<strong>区</strong>，每个区是外存上连续的物理页，但段内各区可不连续。</li><li>区大小可调（64KB、1MB、8MB、64MB），避免碎片。</li><li>支持<strong>自动扩容</strong>，但不自动回收空间（需手动回收）。</li></ol><p><strong>段扩展规则</strong>：</p><ul><li>前16个区：64KB</li><li>第17–143个区：1MB</li><li>后续区大小依规则递增</li></ul><hr><h2 id="附录13-2-Oracle与openGauss中的文件组织">附录13-2 Oracle与openGauss中的文件组织</h2><h3 id="Oracle数据库中的表类型">Oracle数据库中的表类型</h3><ol><li><strong>堆表</strong>（默认）：无序存储，写入快，读取慢。</li><li><strong>索引组织表</strong>：按主键顺序存储，读取快，但更新主键成本高，表宽度有限。</li><li><strong>簇表</strong>：多个表按连接键存储在同一个段中，提高连接查询效率（openGauss不兼容）。</li><li>临时表、压缩表、分区表、嵌套表等。</li></ol><h3 id="适用场景建议">适用场景建议</h3><ul><li><strong>堆表</strong>：适合写入频繁、读取顺序无关的场景。</li><li><strong>索引组织表</strong>：适合主键稳定、以查询为主的场景。</li><li><strong>簇表</strong>：适合频繁进行特定连接查询的场景。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§6 E-R Model 解读</title>
      <link href="/2025/12/26/DB_E-R%20Model/"/>
      <url>/2025/12/26/DB_E-R%20Model/</url>
      
        <content type="html"><![CDATA[<h2 id="目录"><strong>目录</strong></h2><ol><li><strong>数据库设计过程概述</strong></li><li><strong>实体-关系（E-R）模型（概念设计）</strong></li><li><strong>将E-R图转化为关系模式（逻辑设计）</strong></li></ol><hr><h2 id="第1章：设计过程概述"><strong>第1章：设计过程概述</strong></h2><h3 id="6-1-设计过程概览"><strong>6.1 设计过程概览</strong></h3><p>数据库设计包含两个主要阶段：</p><ol><li><p><strong>需求分析</strong></p><ul><li>确定应存储哪些数据。</li><li>确定需执行哪些操作/事务，如插入、删除、更新。</li></ul></li><li><p><strong>数据库模式设计（采用三级抽象）</strong></p><ul><li><strong>概念设计</strong>：使用高级概念模型（如E-R模型）描述数据及其关系，独立于任何特定的数据库管理系统。</li><li><strong>逻辑设计</strong>：将概念模式转化为特定数据库管理系统（如关系模型）所支持的数据模型。</li><li><strong>物理设计</strong>：描述数据的物理存储结构、文件组织、索引等，以优化性能。</li></ul></li></ol><h3 id="现实世界中的应用问题与设计阶段"><strong>现实世界中的应用问题与设计阶段</strong></h3><ul><li><strong>需求分析</strong>：产出用户需求规格说明。</li><li><strong>概念数据库设计</strong>：产出数据库概念模式，即<strong>E-R图</strong>。</li><li><strong>逻辑数据库设计</strong>：产出数据库逻辑模式，即<strong>关系数据模式</strong>。</li><li><strong>物理数据库设计</strong>：产出数据库物理模式，例如物理存储结构。</li></ul><h3 id="数据库应用系统（DBAS）设计"><strong>数据库应用系统（DBAS）设计</strong></h3><ol><li><p><strong>生命周期</strong>：包含五个阶段：</p><ul><li>项目规划、需求分析、系统设计、实现与部署、运行管理与维护。</li></ul></li><li><p><strong>三条设计主线</strong>（根据软件组成和功能划分）：</p><ul><li><strong>数据组织与存储设计</strong>：用于设计数据库。</li><li><strong>数据访问与处理设计</strong>：用于设计数据库事务。</li><li><strong>应用设计</strong>：用于设计应用程序。</li></ul></li><li><p><strong>三个设计步骤</strong>（根据数据库系统三级模式结构）：</p><ul><li>概念设计、逻辑设计、物理设计。</li></ul></li></ol><h3 id="DBAS生命周期模型（图示总结）"><strong>DBAS生命周期模型（图示总结）</strong></h3><p>该模型整合了从<strong>项目规划</strong>到<strong>运行维护</strong>的完整流程，涵盖了<strong>需求分析</strong>（数据项、数据流与事务、程序）、<strong>系统设计</strong>（概念、逻辑、物理模式设计；事务概要/详细设计；程序概要/详细设计）、<strong>系统实现和部署</strong>（构造原型、数据转换与加载、测试、部署），以及三条设计主线（数据组织与存储、数据访问与处理、应用程序）的贯穿。</p><hr><h2 id="第2章：实体-关系模型"><strong>第2章：实体-关系模型</strong></h2><h3 id="6-2-实体-关系模型"><strong>6.2 实体-关系模型</strong></h3><ul><li><strong>定义</strong>：E-R模型通过实体、属性和关系这些基本概念，将现实世界企业的含义和交互映射到概念模式上，从而促进数据库设计，表示数据库的整体逻辑结构。</li><li><strong>三个核心概念</strong>：<ol><li>实体集</li><li>关系集</li><li>属性</li></ol></li><li><strong>E-R图</strong>：E-R模型的图形化表示。</li></ul><h3 id="6-2-1-实体集"><strong>6.2.1 实体集</strong></h3><ul><li><strong>实体定义</strong>：一个<strong>实体</strong>是存在于现实世界中、可与其他对象相区别的“对象”。例如：一个具体的人、一家公司。</li><li><strong>实体集定义</strong>：一个<strong>实体集</strong>是具有相同类型（共享相同属性）的实体的集合。例如：所有人的集合、所有公司的集合。</li><li><strong>注意</strong>：<ul><li>实体由一组<strong>属性</strong>表示，这些属性是实体集的描述性性质。</li><li>示例：<ul><li><code>instructor</code> = {<code>ID</code>, <code>name</code>, <code>street</code>, <code>city</code>, <code>salary</code>}</li><li><code>course</code> = {<code>course_id</code>, <code>title</code>, <code>credits</code>}</li></ul></li></ul></li><li><strong>主键定义</strong>：属性中的一个子集构成<strong>主键</strong>，用于唯一标识实体集中的每个成员。</li><li><strong>实体集的数学表示</strong>：一个实体由所有属性的所有值构成。实体集是这些属性值域的笛卡尔积的一个子集。<ul><li>示例：<code>instructor</code> 实体集可表示为 {(<code>instructor_ID</code>, <code>instructor_name</code>) : <code>instructor_ID</code> ∈ D₁, <code>instructor_name</code> ∈ D₂} ⊆ D₁ × D₂</li></ul></li></ul><h3 id="6-2-2-关系集"><strong>6.2.2 关系集</strong></h3><ul><li><strong>关系定义</strong>：一个<strong>关系</strong>是多个实体之间的关联。<ul><li>示例：学生Peltier (<code>ID: 44553</code>) 与 教授Einstein (<code>ID: 22222</code>) 通过 <code>advisor</code>（指导）关系相关联。</li></ul></li><li><strong>关系集定义</strong>：一个<strong>关系集</strong>是来自n个（n≥2）实体集的实体之间的数学关系。<ul><li>形式化：{ (e₁, e₂, …, eₙ) | e₁ ∈ E₁, e₂ ∈ E₂, …, eₙ ∈ Eₙ }，其中 (e₁, e₂, …, eₙ) 是一个关系。</li><li>示例：(<code>44553</code>, <code>22222</code>) ∈ <code>advisor</code></li></ul></li><li><strong>注意</strong>：相同的实体集之间可以存在多个不同的关系集。</li></ul><h3 id="关系集的参与与角色"><strong>关系集的参与与角色</strong></h3><ul><li><strong>参与</strong>：实体集 E₁, E₂, …, Eₙ <strong>参与</strong>关系集 R。</li><li><strong>关系实例</strong>：表示现实世界中具体命名的实体之间的一次关联。<ul><li>例如：Crick 和 Tanaka 之间的一个关系实例。</li></ul></li><li><strong>角色</strong>：在关系中，一个实体的每次出现都扮演一个<strong>角色</strong>。角色指实体在关系中发挥的功能。<ul><li>当关系中的实体集相同时，角色用于区分。例如：在 <code>teaching</code>（授课）关系中，<code>student</code> 实体集扮演“听课者”角色，<code>instructor</code> 实体集扮演“讲授者”角色。</li></ul></li></ul><h3 id="关系的度与非二元关系"><strong>关系的度与非二元关系</strong></h3><ul><li><strong>二元关系</strong>：涉及两个实体集（度为2）。大多数关系集是二元的。</li><li><strong>三元关系</strong>：涉及三个实体集。<ul><li>示例：<code>proj_guide</code>（项目指导）关系是 <code>instructor</code>、<code>student</code> 和 <code>project</code> 之间的<strong>三元</strong>关系，表示学生在教师指导下进行研究项目。</li></ul></li></ul><h3 id="关系集的属性"><strong>关系集的属性</strong></h3><ul><li><strong>定义</strong>：属性可以与关系集相关联。</li><li><strong>示例</strong>：<code>instructor</code> 和 <code>student</code> 之间的 <code>advisor</code> 关系集可以有一个属性 <code>date</code>，表示学生成为教师指导对象的日期。</li></ul><h3 id="6-3-复杂属性"><strong>6.3 复杂属性</strong></h3><ul><li><strong>域（值集）</strong>：属性的<strong>域</strong>是其允许取值的集合。</li><li><strong>属性类型</strong>：<ol><li><strong>简单属性</strong>与<strong>复合属性</strong><ul><li>复合属性可以划分为更小的子部分（组件属性）。例如：<code>name</code> 可分解为 <code>first_name</code>, <code>middle_initial</code>, <code>last_name</code>；<code>address</code> 可分解为 <code>street_number</code>, <code>street_name</code> 等。</li></ul></li><li><strong>单值属性</strong>与<strong>多值属性</strong><ul><li>例如：<code>phone_numbers</code>（电话号码），一个人可能有多个。</li></ul></li><li><strong>派生属性</strong><ul><li>可以从其他属性计算得出。例如：<code>age</code>（年龄）可以从 <code>date_of_birth</code>（出生日期）派生。</li></ul></li></ol></li><li><strong>空值（Null）</strong>：属性的空值意味着：<ul><li>该属性不适用于该实体（不存在）。</li><li>该属性的值存在，但“未知”。</li></ul></li></ul><h3 id="冗余属性"><strong>冗余属性</strong></h3><ul><li><strong>场景</strong>：假设有实体集 <code>instructor</code>（属性：<code>ID</code>, <code>name</code>, <code>dept_name</code>, <code>salary</code>）和 <code>department</code>（属性：<code>dept_name</code>, <code>building</code>, <code>budget</code>）。</li><li><strong>建模</strong>：使用关系集 <code>inst_dept</code> 表示每位教师属于一个部门。</li><li><strong>问题</strong>：<code>dept_name</code> 属性同时出现在两个实体集中。由于它是 <code>department</code> 实体集的主键，该信息在关系中已隐含。因此，在 <code>instructor</code> 实体集中，<code>dept_name</code> 是<strong>冗余</strong>的。</li></ul><hr><h2 id="第3章：映射基数约束与参与约束"><strong>第3章：映射基数约束与参与约束</strong></h2><h3 id="6-4-映射基数约束"><strong>6.4 映射基数约束</strong></h3><ul><li><strong>目的</strong>：作为完整性约束，以保持数据库的一致性。</li><li><strong>E-R模型中的约束类型</strong>：映射基数、参与约束、基数界限、键。</li></ul><h3 id="映射基数"><strong>映射基数</strong></h3><ul><li><strong>定义</strong>：表示通过一个关系集，一个实体可以与另一个实体集中的多少个实体相关联。</li><li><strong>对于二元关系集 R（从 A 到 B），映射基数必须是以下之一</strong>：<ol><li><strong>一对一（1:1）</strong>：A中的一个实体最多与B中的一个实体关联，反之亦然。</li><li><strong>一对多（1:N）</strong>：A中的一个实体可以与B中的多个实体关联，但B中的一个实体最多与A中的一个实体关联。</li><li><strong>多对一（N:1）</strong>：A中的多个实体可以与B中的一个实体关联，但B中的一个实体最多与A中的一个实体关联。</li><li><strong>多对多（M:N）</strong>：A中的一个实体可以与B中的多个实体关联，B中的一个实体也可以与A中的多个实体关联。</li></ol></li><li><strong>注意</strong>：<code>many-to-one</code> 和 <code>one-to-many</code> 的定义与方向有关。图中可能存在某些实体未映射到另一实体集中的任何元素。</li></ul><h3 id="E-R图中的基数约束表示"><strong>E-R图中的基数约束表示</strong></h3><ul><li>在关系集和实体集之间，用一条<strong>有向线（→）</strong> 表示“一”，用一条<strong>无向线（—）</strong> 表示“多”。</li><li><strong>示例</strong>：<ul><li><strong>一对一</strong>：学生最多通过 <code>advisor</code> 关系与一位教师关联。</li><li><strong>一对多</strong>：一位教师可以通过 <code>advisor</code> 与多个（包括0个）学生关联；一个学生最多与一位教师关联。</li><li><strong>多对一</strong>：一位教师最多通过 <code>inst_dept</code> 与一个部门关联；一个部门通过 <code>inst_dept</code> 与多位（至少一位）教师关联。</li><li><strong>多对多</strong>：一个 <code>section</code>（课程班）通过 <code>sec_time_slot</code> 与多个（至少一个）<code>timeslot</code>（时间段）关联；一个 <code>timeslot</code> 通过 <code>sec_time_slot</code> 与多个（可能为0个）<code>section</code> 关联。</li></ul></li></ul><h3 id="参与约束"><strong>参与约束</strong></h3><ul><li><strong>全参与定义</strong>：如果实体集 <strong>E</strong> 中的<strong>每一个</strong>实体都至少参与关系 <strong>R</strong> 中的一个关系，则 E 对 R 的参与是<strong>全参与</strong>。<ul><li>示例：<code>instructor</code> 对 <code>inst_dept</code> 的参与是全参与的，每位教师必须通过 <code>inst_dept</code> 关联到一个部门。</li><li><strong>图示</strong>：用<strong>双线（====）</strong> 连接实体集和关系集。</li></ul></li><li><strong>部分参与定义</strong>：如果实体集 <strong>E</strong> 中的<strong>一些</strong>实体可能不参与关系 <strong>R</strong> 中的任何关系，则 E 对 R 的参与是<strong>部分参与</strong>。<ul><li>示例：<code>student</code> 对 <code>advisor</code> 的参与是部分参与的，因为有些学生可能没有指导老师。</li><li><strong>图示</strong>：用<strong>单线（——）</strong> 连接实体集和关系集。</li></ul></li></ul><h3 id="参与的基数界限"><strong>参与的基数界限</strong></h3><ul><li><strong>定义</strong>：<strong>基数界限</strong>用于定量描述参与约束。对于关联实体集 A 和 B 的关系 R，定义 A 参与 R 的<strong>下界 l_A</strong> 和<strong>上界 h_A</strong>。<ul><li>A 中的每个实体 a，通过 R 最少关联 <strong>l_A</strong> 个、最多关联 <strong>h_A</strong> 个 B 中的实体 b。</li><li>l_A = 0 表示 A 对 R 是<strong>部分参与</strong>。</li><li>l_A &gt; 0 表示 A 对 R 是<strong>全参与</strong>（等价于双线表示）。</li><li>最大值 * 表示“无限制”。</li></ul></li><li><strong>基数界限与映射基数的关联</strong><ul><li>对于关联 A 和 B 的关系 R，可以利用基数界限 <code>&lt;l_A, h_A&gt;</code> 和 <code>&lt;l_B, h_B&gt;</code> 来推导映射基数 <code>&lt;h_B, h_A&gt;</code>（从 A 到 B 的视角）。</li><li><strong>示例</strong>：<ul><li><strong>一对一（1:1）</strong>：<code>&lt;l_A, h_A&gt; = &lt;1, 1&gt;</code>, <code>&lt;l_B, h_B&gt; = &lt;0, 1&gt;</code></li><li><strong>一对多（1:N）</strong>：<code>&lt;l_A, h_A&gt; = &lt;0, N&gt;</code>, <code>&lt;l_B, h_B&gt; = &lt;1, 1&gt;</code></li><li><strong>多对一（N:1）</strong>：<code>&lt;l_A, h_A&gt; = &lt;1, 1&gt;</code>, <code>&lt;l_B, h_B&gt; = &lt;1, N&gt;</code></li><li><strong>多对多（M:N）</strong>：<code>&lt;l_A, h_A&gt; = &lt;1, M&gt;</code>, <code>&lt;l_B, h_B&gt; = &lt;1, N&gt;</code></li></ul></li></ul></li></ul><hr><h2 id="第4章：键与弱实体集"><strong>第4章：键与弱实体集</strong></h2><h3 id="6-5-键"><strong>6.5 键</strong></h3><ul><li><strong>定义</strong>：<strong>键</strong>是一组属性（对于实体集或关系集），其值能唯一区分一个实体（或关系）与集合中的其他实体（或关系）。</li><li><strong>键的类型</strong>：超键、候选键、主键。</li><li><strong>应用对象</strong>：实体集、关系集、弱实体集。</li></ul><h3 id="实体集的键"><strong>实体集的键</strong></h3><ul><li><strong>超键</strong>：是一个或多个属性的集合，其值能<strong>唯一</strong>确定实体集中的每个实体。可能包含无关属性。<ul><li>示例：<code>{instructor_id, instructor_name}</code>。</li></ul></li><li><strong>候选键</strong>：是<strong>极小</strong>的超键，即不含冗余属性的超键。<ul><li>示例：<code>instructor_id</code> 是 <code>instructor</code> 的候选键。</li></ul></li><li><strong>主键</strong>：被选为在实体集中标识实体的<strong>主要</strong>手段的候选键。一个实体集可能有多个候选键，但只选一个作为主键。</li></ul><h3 id="关系集的键"><strong>关系集的键</strong></h3><ul><li><strong>背景</strong>：关系集 R 是实体 E₁, E₂, …, Eₙ 的笛卡尔积的子集，即 R ⊆ E₁ × E₂ × … × Eₙ。</li><li><strong>识别关系实例</strong>：每个参与实体集 E_i 可以通过其主键 <code>primary_key(E_i)</code> 唯一区分。因此，所有参与实体集主键的属性的组合可以用来唯一识别关系实例 <code>(e₁, e₂, …, eₙ)</code>。</li><li><strong>超键</strong>：<code>primary_key(E₁) ∪ primary_key(E₂) ∪ … ∪ primary_key(Eₙ)</code>。<ul><li>示例：<code>(InstructorID, StudentID)</code> 是 <code>advisor</code> 的超键。</li><li><strong>注意</strong>：如果主键属性名不唯一，需要进行重命名。</li></ul></li><li><strong>候选键/主键</strong>：是极小、非冗余的超键。</li><li><strong>二元关系主键的选择（基于映射基数）</strong>：<ul><li><strong>多对多</strong>：<code>primary_key(R) = primary_key(A) ∪ primary_key(B)</code></li><li><strong>从A到B多对一</strong>：<code>primary_key(R) = primary_key(A)</code></li><li><strong>一对多</strong>：<code>primary_key(R) = primary_key(B)</code></li><li><strong>一对一</strong>：<code>primary_key(R) = primary_key(A)</code> <strong>或</strong> <code>primary_key(B)</code></li></ul></li></ul><h3 id="6-5-3-弱实体集"><strong>6.5.3 弱实体集</strong></h3><ul><li><strong>定义</strong>：<strong>弱实体集</strong>是指没有足够属性构成主键的实体集。其存在依赖于另一个称为<strong>标识实体集</strong>的实体集。</li><li><strong>动机</strong>：避免冗余或隐含关系。<ul><li><strong>示例</strong>：<code>section</code> 实体集（<code>course_id</code>, <code>sec_id</code>, <code>semester</code>, <code>year</code>）与 <code>course</code> 实体集相关。<code>section</code> 的 <code>course_id</code> 属性引用了 <code>course</code>。如果移除 <code>course_id</code> 属性，<code>section</code> 就缺少唯一标识符，成为弱实体集。</li></ul></li><li><strong>标识关系</strong>：连接弱实体集与其标识实体集的关系。用<strong>双菱形</strong>表示。</li><li><strong>分辨符（部分键）</strong>：弱实体集中用于区分依赖于同一个标识实体的所有弱实体的属性集。<ul><li>示例：对于依赖于特定 <code>course</code> 的 <code>section</code>，其 <code>sec_id</code>, <code>semester</code>, <code>year</code> 构成分辨符。在E-R图中用<strong>虚线</strong>下划线标出。</li></ul></li><li><strong>弱实体集的主键</strong>：由<strong>标识实体集的主键</strong> + <strong>弱实体集的分辨符</strong> 构成。<ul><li>示例：<code>section</code> 的主键 = <code>course_id</code> + <code>sec_id</code> + <code>semester</code> + <code>year</code>。</li></ul></li><li><strong>E-R图表示</strong>：<ul><li>弱实体集：<strong>双矩形</strong></li><li>标识关系：<strong>双菱形</strong></li><li>分辨符：<strong>虚线</strong>下划线</li></ul></li></ul><h3 id="6-6-移除冗余属性"><strong>6.6 移除冗余属性</strong></h3><ul><li><strong>场景</strong>：实体集 <code>student</code>（<code>ID</code>, <code>name</code>, <code>tot_cred</code>, <code>dept_name</code>）和 <code>department</code>（<code>dept_name</code>, <code>building</code>, <code>budget</code>）通过关系集 <code>stud_dept</code> 关联。</li><li><strong>问题</strong>：<code>student</code> 中的 <code>dept_name</code> 属性复制了关系中隐含的信息，是冗余的，应当从 <code>student</code> 实体集中移除。</li><li><strong>注意</strong>：在后续转化为关系表时，该属性可能需要被重新引入（作为外键）。</li></ul><hr><h2 id="第5章：将E-R图转化为关系模式"><strong>第5章：将E-R图转化为关系模式</strong></h2><h3 id="6-7-E-R图到关系模式的转化"><strong>6.7 E-R图到关系模式的转化</strong></h3><ul><li><strong>逻辑数据库设计的两步</strong>：<ol><li>从E-R图生成初始关系模式。</li><li>关系模式的规范化（第7章）。</li></ol></li><li><strong>原则</strong>：符合E-R图的数据库可以由一组模式/表来表示。每个实体集或关系集都能被统一地表示为关系模式，且通常有唯一对应的模式。</li></ul><h3 id="实体集的表示"><strong>实体集的表示</strong></h3><ul><li><strong>强实体集</strong>：转化为一个具有相同属性的模式。<ul><li>示例：<code>student (ID, name, tot_cred)</code></li></ul></li><li><strong>弱实体集</strong>：转化为一个包含其标识强实体集主键列的表。<ul><li>示例：<code>section (course_id, sec_id, sem, year)</code>，其中 <code>course_id</code> 是引用 <code>course</code> 表的外键。</li></ul></li><li><strong>具有复合属性的实体集</strong>：复合属性被“扁平化”为其组件属性。<ul><li>示例：<code>instructor</code> 的复合属性 <code>name</code>（含 <code>first_name</code>, <code>middle_initial</code>, <code>last_name</code>）和 <code>address</code> 被展开。最终模式可能为：<code>instructor(ID, first_name, middle_initial, last_name, street_number, street_name, apt_number, city, state, zip_code, date_of_birth)</code>。忽略多值属性。</li></ul></li></ul><h3 id="关系集的表示（取决于映射基数和参与约束）"><strong>关系集的表示（取决于映射基数和参与约束）</strong></h3><ol><li><p><strong>多对多关系集</strong>：</p><ul><li>表示为一张独立的表，包含<strong>两个参与实体集的主键</strong>列，以及关系集的任何<strong>描述性属性</strong>。</li><li>示例：<code>advisor(instructor_ID, student_ID, date)</code></li></ul></li><li><p><strong>“多”端为全参与的多对一或一对多关系集</strong>：</p><ul><li>可以不为关系集单独建表，而是在**“多”端实体<strong>对应的表中添加一个额外属性（外键），该属性是</strong>“一”端实体**的主键。</li><li>示例：<code>inst_dept</code>（多对一，教师对部门全参与），可将 <code>dept_name</code> 加入 <code>instructor</code> 表：<code>instructor(ID, name, salary, dept_name)</code>。这避免了空值并简化了设计。</li><li><strong>优点</strong>：避免了单独的表和连接操作。</li></ul></li><li><p><strong>“多”端为部分参与的多对一关系集</strong>：</p><ul><li>如果“多”端是部分参与，将关系信息并入“多”端实体的表会导致该外键列出现<strong>空值</strong>（因为有些“多”端实体不参与关系）。</li><li><strong>方案</strong>：将关系集单独转为一张表。</li><li>示例：<code>advisor</code> 关系（从 <code>student</code> 到 <code>instructor</code> 是多对一，且 <code>student</code> 部分参与）。若将 <code>instructor_ID</code> 放入 <code>student</code> 表，则没有导师的学生该列为空。因此，更好的方法是创建独立表：<code>advisor(instructor_ID, student_ID)</code>。</li></ul></li><li><p><strong>一对一关系集</strong>：</p><ul><li>可以将额外属性（外键）添加到<strong>任意一方</strong>实体对应的表中。选择通常基于哪个方向的参与更接近“全参与”，或基于查询模式。</li></ul></li></ol><h3 id="6-8-扩展E-R特性"><strong>6.8 扩展E-R特性</strong></h3><ul><li><strong>面向对象的E-R模型</strong>引入了<strong>特化</strong>与<strong>泛化</strong>的概念，支持<strong>属性继承</strong>。</li></ul><h4 id="1-特化"><strong>1. 特化</strong></h4><ul><li><strong>定义</strong>：一种<strong>自顶向下</strong>的设计过程。在一个实体集（高层实体集）中，根据某些特征划分出区别于其他实体的子分组，这些子分组成为<strong>低层实体集</strong>。</li><li><strong>特点</strong>：<ul><li>低层实体集拥有高层实体集的所有属性（继承），并可能有自己特定的属性。</li><li>用标记为 <strong>ISA</strong>（“是一个”）的三角形组件表示。</li><li>示例：<code>instructor</code> 和 <code>secretary</code> 是 <code>employee</code> 的特化。</li><li><code>person</code> 可以特化为 <code>employee</code> 和 <code>student</code>，<code>employee</code> 可进一步特化为 <code>instructor</code> 和 <code>secretary</code>，<code>student</code> 可特化为 <code>undergraduate</code> 和 <code>graduate</code>。</li></ul></li></ul><h4 id="2-泛化"><strong>2. 泛化</strong></h4><ul><li><strong>定义</strong>：一种<strong>自底向上</strong>的设计过程。将多个共享共同特征的实体集合并为一个更高层的实体集。</li><li><strong>关系</strong>：特化与泛化是互逆过程，在E-R图中表示方式相同，常互换使用。</li></ul><h4 id="超类与子类"><strong>超类与子类</strong></h4><ul><li><strong>ISA</strong> 关系也被称为<strong>超类-子类</strong>关系。</li><li>如果 A 是 B 的泛化，则 A 是<strong>超类</strong>，B 是<strong>子类</strong>。</li><li>如果 B 是 A 的特化，则 B 是<strong>子类</strong>，A 是<strong>超类</strong>。</li></ul><h4 id="特化-泛化的约束"><strong>特化/泛化的约束</strong></h4><ul><li><strong>成员资格约束</strong>：决定低层实体的成员如何确定。<ul><li><strong>条件定义/属性定义</strong>：基于特定条件或属性值。例如：<code>student_type</code> 属性决定是 <code>graduate</code> 还是 <code>undergraduate</code>。</li><li><strong>用户定义</strong>：由用户指派，无明确属性区分。</li></ul></li><li><strong>完备性约束</strong>：高层实体是否<strong>必须</strong>属于至少一个低层实体集。<ul><li><strong>全完备</strong>：高层实体必须属于一个低层实体集。用关键词 <strong>total</strong> 和从该词指向空心箭头集合的虚线表示。<ul><li>示例：<code>student</code> 必须要么是 <code>graduate</code>，要么是 <code>undergraduate</code>。</li></ul></li><li><strong>部分完备</strong>：高层实体不一定属于任何低层实体集。<ul><li>示例：<code>person</code> 的特化，一个人可能既不是员工也不是学生。</li></ul></li></ul></li><li><strong>不相交性约束</strong>：一个高层实体是否可以属于多个低层实体集。<ul><li><strong>不相交</strong>：高层实体最多只能属于一个低层实体集。用关键词 <strong>disjoint</strong> 表示。<ul><li>示例：<code>instructor</code> 和 <code>secretary</code> 是不相交的。</li></ul></li><li><strong>重叠</strong>：高层实体可以属于多个低层实体集。用关键词 <strong>overlapping</strong> 表示。<ul><li>示例：<code>employee</code> 和 <code>student</code> 可以重叠（同一个人可以既是员工又是学生）。</li></ul></li></ul></li></ul><h4 id="特化的模式表示方法"><strong>特化的模式表示方法</strong></h4><ol><li><strong>方法1（为每个实体集建表）</strong>：<ul><li>为高层实体集创建一个模式。</li><li>为每个低层实体集创建一个模式，包含高层实体集的主键以及本地属性。</li><li><strong>缺点</strong>：查询一个低层实体（如员工）的信息需要访问两个表（高层表和低层表），涉及连接操作。</li></ul></li><li><strong>方法2（为每个实体集创建包含所有属性的表）</strong>：<ul><li>为每个低层实体集创建一个模式，包含其所有本地属性和继承自高层实体集的属性。</li><li><strong>缺点</strong>：如果存在重叠特化（如一个人既是学生又是员工），其公共属性（如姓名、地址）会被<strong>冗余存储</strong>。</li></ul></li><li><strong>方法3（针对不相交且全完备的特化）</strong>：<ul><li>不为高层实体集创建表。</li><li>仅为每个低层实体集创建表，表中包含低层实体集的所有属性（包括继承的和本地的）。</li><li><strong>条件</strong>：仅当特化是<strong>不相交</strong>且<strong>全完备</strong>时才有效。</li><li><strong>示例</strong>：<code>student</code> 特化为 <code>graduate</code> 和 <code>undergraduate</code>（假设不相交且全完备），则只创建 <code>graduate</code> 表和 <code>undergraduate</code> 表，不创建 <code>student</code> 表。</li></ul></li></ol><hr><h2 id="第6章：实体-关系设计中的问题"><strong>第6章：实体-关系设计中的问题</strong></h2><h3 id="6-9-实体-关系设计中的问题"><strong>6.9 实体-关系设计中的问题</strong></h3><h4 id="1-实体集与属性的使用"><strong>1. 实体集与属性的使用</strong></h4><ul><li><strong>问题</strong>：如何将现实世界的“事物/对象”映射为实体集或属性。</li><li><strong>示例</strong>：教师和电话。<ul><li><strong>模型1（作为属性）</strong>：<code>instructor(ID, name, salary, phone_number)</code>。这隐含每位教师只有一个电话号码，且难以表示电话的更多属性（如位置）。</li><li><strong>模型2（作为实体）</strong>：<code>instructor(ID, name, salary)</code> 和 <code>phone(phone_number, location)</code>，通过关系集 <code>inst_phone</code> 关联。这种方式更灵活，可以表示多个号码和电话的附加信息。</li></ul></li><li><strong>规则1</strong>：不要使用一个实体集的主键作为另一个实体集的属性。应使用关系集来明确显示这种关联。<ul><li>示例：不应在 <code>student</code> 实体中添加 <code>instructor_id</code> 属性，而应使用 <code>advisor</code> 关系集。</li></ul></li><li><strong>规则2</strong>：如果实体集 E 参与关系集 R，则不应将 E 的主键设计为 R 的属性，以避免信息冗余。<ul><li>示例：<code>advisor</code> 关系不应有 <code>inst_id</code> 和 <code>student_ID</code> 属性，因为关系本身已隐含此信息。冗余的建模可能导致数据不一致。</li></ul></li></ul><h4 id="2-实体集与关系集的使用"><strong>2. 实体集与关系集的使用</strong></h4><ul><li><strong>规则3</strong>：一个可能的指导原则是，使用<strong>关系集</strong>来描述实体之间发生的<strong>动作</strong>。</li><li><strong>示例</strong>：使用 <code>takes</code> 关系来建模“学生选修某个课程班”这一动作，并在关系中包含 <code>grade</code> 属性。</li></ul><h4 id="3-二元关系与非二元关系"><strong>3. 二元关系与非二元关系</strong></h4><ul><li><strong>规则4</strong>：尽可能使用二元关系集。可以用多个二元关系集来替代一个非二元（如三元）关系集。</li><li><strong>优势</strong>：二元关系更简单，且允许表示部分信息。</li><li><strong>示例</strong>：一个三元关系 <code>parents</code>（关联孩子、父亲、母亲）最好被两个二元关系 <code>father</code> 和 <code>mother</code> 替代。这样即使不知道父亲或母亲的信息，也可以记录部分关系。</li><li><strong>三元关系转化为二元关系的一般方法</strong>：<ul><li>创建一个新的实体集 E，其每个实体对应原三元关系 R 中的一个元组 <code>(a_i, b_i, c_i)</code>。</li><li>然后创建三个二元关系集 R_a, R_b, R_c，分别将 E 与实体集 A, B, C 关联起来。</li><li>新实体集 E 需要一个标识属性（候选键）。</li></ul></li></ul><h4 id="4-关系属性的放置"><strong>4. 关系属性的放置</strong></h4><ul><li><strong>问题</strong>：关系集的属性应该放在哪里？</li><li><strong>规则</strong>：取决于关系的映射基数。<ul><li><strong>一对一</strong>：关系属性可以放在<strong>任意一方</strong>参与实体集对应的表中。</li><li><strong>一对多</strong>（从 E1 到 E2）：关系属性<strong>只能</strong>放在“多”端（E2）实体集对应的表中。<ul><li>示例：<code>advisor</code> 关系（一对多）的属性 <code>date</code> 可以作为 <code>student</code> 表的一个属性。</li></ul></li><li><strong>多对多</strong>：关系属性<strong>必须</strong>放在<strong>关系集</strong>对应的独立表中，不能放在任何参与实体集对应的表中。<ul><li>示例：<code>depositor</code> 关系（多对多）的属性 <code>access-date</code> 必须放在 <code>depositor</code> 关系表中。</li></ul></li></ul></li></ul><hr><h2 id="第7章：关系模式图与总结"><strong>第7章：关系模式图与总结</strong></h2><h3 id="模式图（非E-R图）"><strong>模式图（非E-R图）</strong></h3><ul><li>展示了由数据库管理系统（如 SQL Server）生成的<strong>关系模式图</strong>，其中包含表（如 <code>time_slot</code>, <code>section</code>, <code>teaches</code>, <code>course</code>, <code>student</code>, <code>advisor</code> 等）及其之间的外键关联关系。</li><li><strong>重要区别</strong>：这是<strong>逻辑设计</strong>后的关系模式图，显示了表、列和参照完整性约束，<strong>不是</strong>概念设计阶段的E-R图。</li></ul><h3 id="结论"><strong>结论</strong></h3><p>在设计E-R模型时，需要仔细考虑以下关键决策：</p><ol><li>使用属性还是实体集来表示一个对象。</li><li>一个现实世界概念最好用实体集还是关系集来表达。</li><li>使用三元关系还是一对二元关系。</li><li>使用强实体集还是弱实体集。</li><li>是否使用特化/泛化。</li></ol><hr><h2 id="附录-6-1-例题1：订单数据库的E-R建模与表转化"><strong>附录 6-1 例题1：订单数据库的E-R建模与表转化</strong></h2><h3 id="问题描述"><strong>问题描述</strong></h3><p>设计一个用于订单系统的数据库，包含 <code>Customer</code>（客户）、<code>Product</code>（产品）和 <code>Order</code>（订单）信息。</p><p><strong>需求：</strong></p><ul><li><strong>Customer</strong>：<code>customer-number</code>, <code>ship-to-addresses</code>（多值）, <code>name</code>, <code>balance</code>, <code>discount</code>。</li><li><strong>Order</strong>：<code>order number</code>, <code>customer number</code>, <code>ship-to address</code>（单值）, <code>date of ordering</code>（复合属性：<code>year</code>, <code>month</code>, <code>day</code>）, 包含多种产品，每种产品的 <code>quantity</code>（订购数量）。</li><li><strong>Product</strong>：<code>product-number</code>, <code>name</code>, <code>manufacturing-plant</code>, <code>quantity on hand</code>（库存量）。</li></ul><p><strong>约束：</strong></p><ol><li>客户可以下多个订单，也可能不下单（部分参与）。</li><li>每个订单必须且仅属于一个客户（全参与）。</li><li>关系集 <code>make</code> 连接 <code>Customer</code> 和 <code>Order</code>，从 <code>Customer</code> 到 <code>Order</code> 是<strong>一对多</strong>。</li><li>每个订单必须包含至少一种产品。</li><li>一种产品可以出现在多个订单中，也可能不出现在任何订单中（部分参与）。</li><li>关系集 <code>contain</code> 连接 <code>Order</code> 和 <code>Product</code>，有描述性属性 <code>quantity of ordered</code>。</li><li>在 <code>contain</code> 关系中，从 <code>Order</code> 到 <code>Product</code> 是<strong>多对多</strong>。</li></ol><h3 id="E-R图设计（图示）"><strong>E-R图设计（图示）</strong></h3><p>实体集：<code>Customer</code>、<code>Order</code>、<code>Product</code>。<br>属性如图所示，注意多值属性 <code>address</code>（客户）、复合属性 <code>date</code>（订单）。<br>关系集：<code>make</code>（一对多，订单端全参与），<code>contain</code>（多对多）。</p><h3 id="转化为关系模式"><strong>转化为关系模式</strong></h3><ol><li><strong>Customer 及其多值属性</strong>：<ul><li><code>customer(C-number, c-name, discount, balance)</code></li><li><code>ship-to-addresses(C-number, ship-to-addresses)</code> （独立表处理多值属性）</li></ul></li><li><strong>Order 及其复合属性</strong>：<ul><li><code>order(O-number, C-number, ship-to-address, year, month, day)</code> （已将 <code>make</code> 关系通过外键 <code>C-number</code> 并入，因为订单端全参与且是一对多）</li></ul></li><li><strong>Product</strong>：<ul><li><code>product(P-number, p-name, plant, quantity-on-hand)</code></li></ul></li><li><strong>Contain 关系（多对多）</strong>：<ul><li><code>contain(O-number, P-number, quantity_of_ordered)</code></li></ul></li></ol><p><strong>最终得到的五个表：</strong></p><ul><li><code>customer(C-number, c-name, discount, balance)</code></li><li><code>ship-to-addresses(C-number, ship-to-addresses)</code></li><li><code>order(O-number, C-number, ship-to-address, year, month, day)</code></li><li><code>product(P-number, p-name, plant, quantity-on-hand)</code></li><li><code>contain(O-number, P-number, quantity_of_ordered)</code></li></ul><p><strong>注意</strong>：即使 <code>contain</code> 是“多”端部分参与的一对多关系，也应单独建表以避免在“多”端表（<code>product</code>）中引入空值。本例中由于是多对多，更必须单独建表。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§7 Schema Normalization-Relational Database Design 解读</title>
      <link href="/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/"/>
      <url>/2025/12/26/DB_Schema%20Normalization-Relational%20Database%20Design/</url>
      
        <content type="html"><![CDATA[<h3 id="关系数据库设计-模式规范化">关系数据库设计 模式规范化</h3><h2 id="数据库设计流程概述">数据库设计流程概述</h2><h3 id="独立于DBMS的步骤">独立于DBMS的步骤</h3><ol><li><strong>应用领域/现实世界问题</strong>：需求分析。</li><li><strong>功能需求规格说明</strong>：概念数据库设计。</li><li><strong>概念数据库模式</strong>：即E-R模式。</li></ol><h3 id="依赖于DBMS的步骤">依赖于DBMS的步骤</h3><ol><li><strong>逻辑数据库设计</strong>：<ul><li>初始关系模式生成。</li><li>关系模式。</li><li><strong>逻辑数据库模式</strong>：即关系数据模拟。</li></ul></li><li><strong>物理数据库设计</strong>：<ul><li><strong>物理数据库模式</strong>：关于物理存储结构和访问方法。</li></ul></li></ol><hr><h2 id="本章大纲">本章大纲</h2><ol><li>良好关系设计的特征</li><li>函数依赖理论</li><li>范式</li><li>使用函数依赖进行分解</li><li>分解算法</li></ol><hr><h2 id="7-1-良好的关系数据库设计">7.1 良好的关系数据库设计</h2><h3 id="困难与挑战">困难与挑战</h3><ul><li><strong>概念设计</strong>、E-R<strong>图转换</strong>、逻辑设计后得到初始关系模式。</li><li>初始关系模式存在关系模式属性间的数据依赖关系，主要是<strong>函数依赖</strong>。</li><li>直接根据初始关系模式及属性间数据依赖关系构造数据库系统，可能导致数据库完整性约束被违反，并引起性能下降，具体表现为以下问题：<ul><li><strong>冗余问题</strong></li><li><strong>插入问题</strong></li><li><strong>更新问题</strong></li><li><strong>删除问题</strong></li></ul></li></ul><h3 id="逻辑设计步骤">逻辑设计步骤</h3><ol><li><strong>生成</strong>：初始关系模式。</li><li><strong>规范化</strong>：关系模式。</li></ol><ul><li>不良设计会导致问题：<ul><li>信息重复。</li><li>无法表示某些信息。</li></ul></li></ul><h3 id="示例：合并模式带来的问题">示例：合并模式带来的问题</h3><ul><li>假设将两个具有多对一映射的表合并：<ul><li><code>instructor (ID, name, salary, dept_name)</code></li><li><code>department (dept_name, building, budget)</code></li></ul></li><li>合并为：<ul><li><code>ins_dept (ID, name, salary, dept_name, building, budget)</code></li></ul></li><li><strong>问题</strong>：<strong>department</strong>的信息可能重复。<ul><li>从<code>instructor</code>到<code>department</code>是<strong>多对一</strong>的映射基数。</li><li>对于ID=45565, 10101, 83821的教师，其所属系的<strong>building</strong>和<strong>budget</strong>属性值将重复。</li></ul></li></ul><table><thead><tr><th style="text-align:left">ID</th><th style="text-align:left">name</th><th style="text-align:left">salary</th><th style="text-align:left">dept_name</th><th style="text-align:left">building</th><th style="text-align:left">budget</th></tr></thead><tbody><tr><td style="text-align:left">22222</td><td style="text-align:left">Einstein</td><td style="text-align:left">95000</td><td style="text-align:left">Physics</td><td style="text-align:left">Watson</td><td style="text-align:left">70000</td></tr><tr><td style="text-align:left">12121</td><td style="text-align:left">Wu</td><td style="text-align:left">90000</td><td style="text-align:left">Finance</td><td style="text-align:left">Painter</td><td style="text-align:left">120000</td></tr><tr><td style="text-align:left">32343</td><td style="text-align:left">El Said</td><td style="text-align:left">60000</td><td style="text-align:left">History</td><td style="text-align:left">Painter</td><td style="text-align:left">50000</td></tr><tr><td style="text-align:left">45565</td><td style="text-align:left">Katz</td><td style="text-align:left">75000</td><td style="text-align:left">Comp.Sci.</td><td style="text-align:left">Taylor</td><td style="text-align:left">100000</td></tr><tr><td style="text-align:left">98345</td><td style="text-align:left">Kim</td><td style="text-align:left">80000</td><td style="text-align:left">Elec.Eng.</td><td style="text-align:left">Taylor</td><td style="text-align:left">85000</td></tr><tr><td style="text-align:left">76766</td><td style="text-align:left">Crick</td><td style="text-align:left">72000</td><td style="text-align:left">Biology</td><td style="text-align:left">Watson</td><td style="text-align:left">90000</td></tr><tr><td style="text-align:left">10101</td><td style="text-align:left">Srinivasan</td><td style="text-align:left">65000</td><td style="text-align:left">Comp.Sci.</td><td style="text-align:left">Taylor</td><td style="text-align:left">100000</td></tr><tr><td style="text-align:left">58583</td><td style="text-align:left">Califieri</td><td style="text-align:left">62000</td><td style="text-align:left">History</td><td style="text-align:left">Painter</td><td style="text-align:left">50000</td></tr><tr><td style="text-align:left">83821</td><td style="text-align:left">Brandt</td><td style="text-align:left">92000</td><td style="text-align:left">Comp.Sci.</td><td style="text-align:left">Taylor</td><td style="text-align:left">100000</td></tr><tr><td style="text-align:left">15151</td><td style="text-align:left">Mozart</td><td style="text-align:left">40000</td><td style="text-align:left">Music</td><td style="text-align:left">Packard</td><td style="text-align:left">80000</td></tr><tr><td style="text-align:left">33456</td><td style="text-align:left">Gold</td><td style="text-align:left">87000</td><td style="text-align:left">Physics</td><td style="text-align:left">Watson</td><td style="text-align:left">70000</td></tr><tr><td style="text-align:left">76543</td><td style="text-align:left">Singh</td><td style="text-align:left">80000</td><td style="text-align:left">Finance</td><td style="text-align:left">Painter</td><td style="text-align:left">120000</td></tr><tr><td style="text-align:left">(t₁)</td><td style="text-align:left">(201081, null)</td><td style="text-align:left">(Zhang, null)</td><td style="text-align:left">(60000, null)</td><td style="text-align:left">(Comp.Sci, Soft.Eng.)</td><td style="text-align:left">(Taylor, Taylor)</td></tr></tbody></table><p><strong>具体问题</strong>：</p><ol><li><strong>插入问题（信息冗余）</strong>：<ul><li>添加一个新教师<code>t₁ = (201081, Zhang, 60000, Comp.Sci, Taylor, 100000)</code>时，其所在系的<code>dept_name</code>, <code>building</code>和<code>budget</code>信息会重复存储。</li></ul></li><li><strong>删除问题</strong>：<ul><li>如果取消<code>Comp.Sci</code>系，需要删除所有属于该系的教师元组。每次删除系信息都会级联删除教师信息。</li></ul></li><li><strong>更新问题（信息冗余）</strong>：<ul><li>信息冗余使更新复杂化，可能导致预算值不一致。例如，将<code>Comp.Sci</code>系的预算从100000改为120000时，所有属于该系的教师元组都必须更新。</li></ul></li><li><strong>信息表示问题</strong>：<ul><li>要表示一个<strong>新开设</strong>的、尚无教师的系，必须插入包含<code>null</code>值的元组，例如<code>t₂ = (null, null, null, Soft.Eng., Taylor, 100000)</code>。数据库中的<code>null</code>值使数据处理复杂化。</li></ul></li></ol><h3 id="问题解决：规范化原则">问题解决：规范化原则</h3><ul><li><strong>等价变换</strong>：对初始关系模式集进行模式分解，保证关系模式满足：<ol><li><strong>函数无损连接性</strong></li><li><strong>函数依赖保持性</strong></li></ol></li><li><strong>动机</strong>：关系模式集需要规范化。</li></ul><hr><h2 id="7-2-使用函数依赖进行分解">7.2 使用函数依赖进行分解</h2><h3 id="内容概览">内容概览</h3><ol><li>键和函数依赖</li><li>三类特殊函数依赖：平凡、部分、传递</li><li>无损分解</li></ol><h3 id="示例对比">示例对比</h3><ol><li><strong>合并模式无重复（一对一映射）</strong>：<ul><li>将<code>section (sec_id, building, room_number)</code>和<code>class (course_id, sec_id, semester, year)</code>合并为<code>sec_class (course_id, sec_id, semester, year, building, room_number)</code>。</li><li>由于从<code>section</code>到<code>class</code>的映射基数是<strong>一对一</strong>的，因此无信息重复。</li></ul></li><li><strong>分解为较小模式（正确的分解）</strong>：<ul><li>从<code>ins_dept (ID, name, salary, dept_name, building, budget)</code>开始。</li><li>将其分解为<code>instructor</code>和<code>department</code>。</li><li>假设有一个模式<code>(dept_name, building, budget)</code>，那么<code>dept_name</code>将是一个候选键。</li><li>记为一个函数依赖：<code>dept_name → building, budget</code>。</li><li>注意：在<code>ins_dept</code>中，因为<code>dept_name</code>不是候选键，所以系的<code>dept_name</code>、<code>building</code>和<code>budget</code>信息不得不重复。</li></ul></li><li><strong>并非所有分解都是好的（有损分解）</strong>：<ul><li><strong>示例</strong>：将<code>employee (ID, name, street, city, salary)</code>分解为<code>employee1 (ID, name)</code>和<code>employee2 (name, street, city, salary)</code>。</li><li><strong>问题</strong>：信息丢失。我们无法重构原始的<code>employee</code>关系（因为不同ID的人可能同名，自然连接会产生额外元组）。</li></ul></li><li><strong>无损连接分解示例</strong>：<ul><li>关系模式<code>R = (A, B, C)</code>分解为<code>R1 = (A, B)</code>和<code>R2 = (B, C)</code>。因为<code>R1 ∩ R2 = {B}</code>，且<code>B</code>是<code>R2</code>的键（<code>B → BC</code>），所以是无损分解。通过投影和自然连接可以恢复原关系。</li></ul></li></ol><h3 id="无损分解定义">无损分解定义</h3><ul><li><strong>定义1</strong>：设<code>R</code>是一个关系模式，<code>R1</code>和<code>R2</code>构成<code>R</code>的一个分解，即<code>R = R1 ∪ R2</code>。如果通过用<code>R1</code>和<code>R2</code>替换模式<code>R</code><strong>没有丢失</strong>信息，则该分解是<strong>无损分解</strong>。<ul><li>形式化：<code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li></ul></li><li><strong>定义2</strong>：如果<code>r ⊂ ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>，则该分解是<strong>有损分解</strong>。</li></ul><h3 id="规范化理论">规范化理论</h3><ul><li><strong>动机</strong>：假设初始关系<code>R</code>形式不佳，将<code>R</code>分解为关系<code>{R1, R2, ..., Rn}</code>，使得：<ul><li>每个关系<code>Ri</code>形式良好。</li><li>分解是无损连接分解。</li></ul></li><li><strong>分解</strong>基于：函数依赖。</li><li><strong>讨论</strong>：关系规范化理论是否有用，数据库设计是否需要？<ul><li>1）设计要求，存在的问题。</li><li>2）解决手段，权衡取舍。</li></ul></li></ul><hr><h2 id="函数依赖作为约束">函数依赖作为约束</h2><h3 id="函数依赖概述">函数依赖概述</h3><ul><li><strong>作为约束</strong>：通常存在关于数据的（完整性）<strong>约束</strong>（规则）。</li><li><strong>示例</strong>：期望成立的约束：<ul><li>学生和教师由其ID<strong>唯一标识</strong>。</li><li>每个学生和教师<strong>只有一个</strong>姓名。</li><li>每个教师和学生<strong>只关联于一个</strong>系。</li></ul></li></ul><h3 id="函数依赖定义">函数依赖定义</h3><ul><li><strong>定义</strong>：关系<code>R</code>的一个合法实例<code>r(R)</code>是满足所有此类现实世界约束的关系实例。</li><li><strong>函数</strong>：<code>f: X → Y, x ∈ X, y ∈ Y, y = f(x)</code>。对于<code>x1, x2 ∈ X</code>，如果<code>x1 = x2</code>，则<code>f(x1) = f(x2)</code>。</li><li><strong>函数依赖</strong>：关于合法关系的<strong>现实世界</strong>约束，即某个属性集的值<strong>唯一确定</strong>另一个属性集的值。</li><li><strong>注意</strong>：FD是键的推广。</li></ul><h3 id="关系实例满足函数依赖">关系实例满足函数依赖</h3><ul><li><strong>定义1</strong>：对于模式<code>R</code>，<code>α ⊆ R</code>，<code>β ⊆ R</code>，如果对于<code>r(R)</code>中的任意元组对<code>ti</code>和<code>tj</code>，满足<code>ti[α] = tj[α] → ti[β] = tj[β]</code>，则关系实例<code>r(R)</code>满足<code>FD α → β</code>，或者说<code>α → β</code>被<code>r(R)</code>满足。</li><li><strong>定义2</strong>：如果<code>α → β</code>被<code>r(R)</code>满足，则<code>r(R)</code>在<code>α → β</code>下是合法的。</li><li><strong>注意</strong>：某个属性集的值唯一确定了另一个属性集的值。</li></ul><h3 id="SQL语句判断函数依赖">SQL语句判断函数依赖</h3><ul><li><strong>给定关系模式</strong> <code>R(A, B, C)</code> 和关系<code>r(R)</code>，利用SQL语句判断关系<code>r(R)</code>是否满足函数依赖 <code>B → C</code>。</li><li><strong>要求</strong>：如果<code>r(R)</code>不满足该函数依赖，找出导致不满足的<code>r(R)</code>中的元组。</li><li><strong>方法</strong>：<ol><li><strong>使用元组变量（自连接）</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> r <span class="keyword">as</span> T, r <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.B <span class="operator">=</span> S.B <span class="keyword">and</span> T.C <span class="operator">&lt;&gt;</span> S.C</span><br></pre></td></tr></table></figure>如果查询结果非空，则函数依赖不成立，结果中的元组即为反例。</li><li><strong>使用GROUP BY</strong>：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> B <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> B</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> C) <span class="operator">&gt;</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>如果查询结果为<code>null</code>（即不存在这样的B），则函数依赖成立。</li></ol></li><li><strong>用断言维护FD</strong>：设计一个断言，以保证在<code>R(A, B, C)</code>上成立 <code>B → C</code>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion B_determines_C <span class="keyword">check</span></span><br><span class="line">  (<span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">      <span class="keyword">select</span> B</span><br><span class="line">      <span class="keyword">from</span> R</span><br><span class="line">      <span class="keyword">group</span> <span class="keyword">by</span> B</span><br><span class="line">      <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> C) <span class="operator">&gt;</span> <span class="number">1</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br></pre></td></tr></table></figure></li></ul><h3 id="示例：判断FD是否被满足">示例：判断FD是否被满足</h3><ul><li>给定关系<code>r(R)</code>如下，判断哪些FD被<code>r</code>满足？<ul><li>A. <code>A → B</code></li><li>B. <code>AC → B</code></li><li>C. <code>BC → A</code></li><li>D. <code>B → C</code></li></ul></li></ul><table><thead><tr><th style="text-align:left">元组</th><th style="text-align:left">A</th><th style="text-align:left">B</th><th style="text-align:left">C</th></tr></thead><tbody><tr><td style="text-align:left">t1</td><td style="text-align:left">1</td><td style="text-align:left">4</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">t2</td><td style="text-align:left">3</td><td style="text-align:left">5</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">t3</td><td style="text-align:left">3</td><td style="text-align:left">4</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">t4</td><td style="text-align:left">7</td><td style="text-align:left">3</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">t5</td><td style="text-align:left">9</td><td style="text-align:left">1</td><td style="text-align:left">0</td></tr></tbody></table><ul><li><strong>分析</strong>：<ul><li><code>t2[A] = t3[A] = 3</code>, 但 <code>t2[B] = 5 ≠ t3[B] = 4</code>，因此 <code>A → B</code> <strong>不满足</strong>。</li><li><code>t2[AC] = t3[AC] = 36</code> (假设连接表示)，但 <code>t2[B] = 5 ≠ t3[B] = 4</code>，因此 <code>AC → B</code> <strong>不满足</strong>。</li><li><code>BC → A</code> <strong>满足</strong>。检查所有BC值相同的元组，其A值也必须相同。元组中BC组合唯一，自然满足。</li><li><code>t1[B] = t3[B] = 4</code>, 但 <code>t1[C] = 2 ≠ t3[C] = 6</code>，因此 <code>B → C</code> <strong>不满足</strong>。</li></ul></li></ul><h3 id="函数依赖在模式R上成立-vs-函数依赖被r-R-满足">函数依赖在模式R上成立 vs 函数依赖被r(R)满足</h3><ul><li><p><strong>定义</strong>：设<code>R</code>为一个关系模式，<code>α ⊆ R</code>，<code>β ⊆ R</code>。如果每个合法实例<code>r(R)</code>都满足<code>α → β</code>，则FD <code>α → β</code>在<code>R</code>上<strong>成立</strong>。</p></li><li><p><strong>注意</strong>：只要<code>R</code>的两个元组在属性<code>α</code>上一致，它们也必须在属性<code>β</code>上一致：<code>t1[α] = t2[α] ⇒ t1[β] = t2[β]</code>。</p></li><li><p><strong>示例</strong>：考虑<code>r(A, B)</code>的以下实例：</p><table><thead><tr><th>A</th><th>B</th></tr></thead><tbody><tr><td>1</td><td>4</td></tr><tr><td>1</td><td>5</td></tr><tr><td>3</td><td>7</td></tr></tbody></table><ul><li>在这个实例上，<code>B → A</code><strong>成立</strong>（因为每个B值只对应一个A值：4-&gt;1, 5-&gt;1, 7-&gt;3）。</li><li><code>A → B</code><strong>不成立</strong>（因为A=1对应了两个不同的B值：4和5）。</li></ul></li><li><p><strong>区别与联系</strong>：</p><ul><li><strong>FD在R上成立</strong>：定义在<code>R</code>的属性间的语义约束，或<code>R</code>的属性间体现出的语义约束。从设计角度，是<code>R</code>应满足的约束。</li><li><strong>FD被r(R)满足</strong>：根据<code>R</code>构造的实际数据<code>r(R)</code>是否满足语义约束。</li><li>如果<code>α → β</code>在<code>R</code>上成立，那么<code>R</code>的每个合法实例<code>r(R)</code>都满足这个FD。</li><li>但是，对于模式<code>R</code>和<code>α → β</code>，如果只有某些<code>r(R)</code>满足<code>R</code>，<code>α → β</code>可能不在<code>R</code>上成立。</li><li>对于定义在模式<code>R</code>上的关系<code>r(R)</code>，如果<code>r</code>满足<code>FD = {α → β}</code>，那么<code>FD</code>在模式<code>R</code>上成立吗？<strong>可能不成立</strong>（因为其他合法实例可能违反该FD）。</li></ul></li></ul><h3 id="函数依赖示例建模">函数依赖示例建模</h3><ul><li>考虑 <code>R = {employee_ID, date, turnover per-day, department_name, manager}</code>。</li><li>假设：<ul><li>每个员工每天<strong>只有一条</strong>日营业额记录。</li><li>每个员工工作于<strong>只有一个</strong>部门。</li><li>每个部门<strong>只有一名</strong>经理。</li></ul></li><li><code>R</code>上的FD：<ul><li><code>F = {employee_ID, date → turnover per-day, employee_ID → department_name, department_name → manager}</code></li></ul></li></ul><h3 id="键和函数依赖">键和函数依赖</h3><ul><li><strong>定义</strong>：如果且仅如果<code>K → R</code>，则<code>K</code>是关系模式<code>R</code>的超键。</li><li><strong>定义</strong>：如果且仅如果：<ol><li><code>K → R</code>，且</li><li>对于任何<code>α ⊂ K</code>，<code>α → R</code>不成立，<br>则<code>K</code>是<code>R</code>的候选键。</li></ol></li><li><strong>示例</strong>：考虑模式<code>in_dep (ID, name, salary, dept_name, building, budget)</code>。<ul><li>我们期望成立的FD：<code>dept_name → building</code>；<code>ID → building</code>（？此处似乎有误，ID应能确定dept_name？更典型的是<code>ID → dept_name</code>）。</li><li>不期望成立的FD：<code>dept_name → salary</code>。</li></ul></li></ul><h3 id="函数依赖在数据库中的完整性约束">函数依赖在数据库中的完整性约束</h3><ul><li>E-R图描述对象及它们之间的关联，而FD则说明对象（即E-R图中的实体或联系）属性间的关系。</li><li><strong>如何在DBS中保证FD？</strong><ul><li>使用DBMS的完整性机制，例如：键、检查约束、触发器。</li></ul></li></ul><h3 id="函数依赖的用途">函数依赖的用途</h3><ul><li><strong>注意1</strong>：FD的用途：<ol><li><strong>测试</strong>关系是否合法。如果关系<code>R</code>在FD集合<code>F</code>下是合法的，则<code>R</code>满足<code>F</code>。</li><li><strong>指定</strong>合法关系集合上的约束。如果所有在<code>R</code>上的合法关系都满足FD集合<code>F</code>，则<code>F</code>在<code>R</code>上成立。</li></ol></li><li><strong>注意2</strong>：关系模式<code>R</code>的一个特定实例<code>r0(R)</code>可能满足<code>F</code>中的一个FD，即使该FD并非在所有合法实例<code>{ri(R)}</code>上都成立。</li></ul><hr><h2 id="特殊类型的函数依赖">特殊类型的函数依赖</h2><h3 id="1-平凡函数依赖">1. 平凡函数依赖</h3><ul><li><strong>定义1</strong>：如果一个FD被关系的所有实例满足，则它是平凡的。<ul><li><code>α → β</code>是平凡的，如果<code>β ⊆ α</code>。</li></ul></li><li><strong>示例</strong>：<ul><li><code>name → name</code></li><li><code>ID, name → ID</code></li></ul></li><li><strong>定义</strong>：<strong>主属性</strong>：出现在至少一个候选键中的属性。</li></ul><h3 id="2-传递依赖">2. 传递依赖</h3><ul><li><strong>定义2</strong>：一个函数依赖<code>α → γ</code>是<em>传递</em>的，如果：<ol><li><code>α → β</code>成立，但<code>β → α</code>不成立。</li><li><code>β → γ</code>成立。</li><li><code>γ</code>不在<code>α</code>中。</li></ol><ul><li>则称<code>γ</code>传递依赖于<code>α</code>。</li></ul></li><li><strong>示例</strong>：<code>Student (sno, sname, address, depart)</code><ul><li>对于两个FD：<code>sno → sname</code>和<code>sname → address</code>，存在传递依赖<code>sno → address</code>。</li></ul></li></ul><h3 id="3-部分依赖">3. 部分依赖</h3><ul><li><strong>定义3</strong>：一个FD <code>α → β</code>是<em>部分</em>的，如果存在<code>α</code>的一个子集<code>γ</code>（即<code>γ ⊂ α</code>），使得<code>γ → β</code>成立。<ul><li>部分函数依赖，表明<code>α</code>非最小化，存在冗余。</li><li><code>β</code>部分依赖于<code>α</code>。</li></ul></li><li><strong>示例</strong>：<code>Student (sno, sname, address, depart)</code><ul><li>对于部分依赖<code>(sno, sname) → address</code>，存在属性子集使得<code>sname → address</code>或<code>sno → address</code>成立。</li></ul></li></ul><h3 id="4-函数依赖集F的闭包-F">4. 函数依赖集F的闭包 F*</h3><ul><li><strong>定义4</strong>：用符号<code>F*</code>表示FD集合<code>F</code>的闭包。<ul><li>它是给定FD集合<code>F</code>可以推导出的所有FD的集合。</li><li><code>F*</code>包含<code>F</code>中的所有FD。</li></ul></li><li><strong>示例</strong>：<br><code>F* = {A → B, B → C}+ = {A → B, B → C, A → C, AB → B, AC → BC, ...}</code></li></ul><h3 id="5-无损分解">5. 无损分解</h3><ul><li><strong>定义1（无损分解）</strong>：对于<code>R = (R1, R2)</code>，要求对于模式<code>R</code>上所有可能的关系<code>r</code>，都有 <code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li><li><strong>定义2</strong>：将<code>R</code>分解为<code>R1</code>和<code>R2</code>是无损的，如果以下FD中至少有一个在<code>F*</code>中：<ul><li><code>R1 ∩ R2 → R1</code></li><li><code>R1 ∩ R2 → R2</code></li></ul></li><li><strong>结论</strong>：如果只有<code>R1 ∩ R2 → R1</code>成立，那么<code>R1 ∩ R2</code>是<code>R1</code>的主键，并且是<code>R2</code>的外键。这是一个充分条件。</li><li><strong>示例</strong>：<ul><li>考虑模式<code>in-dep (ID, name, salary, dept_name, building, budget)</code>。</li><li>分解为<code>instructor</code>和<code>department</code>模式：<ul><li><code>instructor (ID, name, dept_name, salary)</code> （包含外键<code>dept_name</code>）</li><li><code>department (dept_name, building, budget)</code></li></ul></li><li>考虑两个模式的交集，即<code>dept_name</code>。<ul><li>由于<code>dept_name → building, budget</code>，满足<strong>无损分解规则</strong>。</li></ul></li></ul></li><li><strong>示例</strong>：<ul><li><code>R = {A, B, C}</code>， <code>F = {A → B, B → C}</code>。</li><li><code>R1 = {A, B}</code>, <code>R2 = {B, C}</code>。<ul><li>无损分解：<code>R1 ∩ R2 = {B}</code> 且 <code>B → BC</code>。</li></ul></li><li><code>R1 = {A, B}</code>, <code>R2 = {A, C}</code>。<ul><li>无损分解：<code>R1 ∩ R2 = {A}</code> 且 <code>A → AB</code>。</li></ul></li><li><strong>注意</strong>：<code>BC</code>是<code>{B, C}</code>的简写。</li></ul></li></ul><hr><h2 id="7-3-范式">7.3 范式</h2><h3 id="范式种类">范式种类</h3><ol><li><strong>1NF</strong>：第一范式</li><li><strong>2NF</strong>：第二范式</li><li><strong>BCNF</strong>：Boyce-Codd范式</li><li><strong>3NF</strong>：第三范式</li></ol><h3 id="规范化原则">规范化原则</h3><ul><li>关系模式规范化处理的基本要求为：<ul><li>静态关系具有第一范式形式。</li><li>动态关系最好具有3NF或BCNF形式。</li></ul></li><li>范式1NF、2NF、3NF、BCNF可以看作由符合范式要求的各种关系模式组成的关系模式的集合。<ul><li>例如：<code>1NF = { R | R 满足第一范式的定义 }</code>。</li></ul></li><li>范式间的关系：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1NF ⊃ 2NF ⊃ 3NF ⊃ BCNF</span><br></pre></td></tr></table></figure>（更准确地说，满足BCNF则一定满足3NF，满足3NF则一定满足2NF，满足2NF则一定满足1NF）。</li></ul><h3 id="原子域和第一范式">原子域和第一范式</h3><ul><li><strong>定义</strong>：一个关系模式<code>R</code>属于<strong>第一范式</strong>，如果<code>R</code>的所有属性的域都是<strong>原子的</strong>。</li><li><strong>域是原子的</strong>：如果它的元素是<strong>不可分割</strong>的单位。</li><li><strong>非原子域示例</strong>：<ul><li>集合，例如<code>student_names = {Henry, Codd, ...}</code>（一个属性值包含多个学生姓名）。</li><li>复合属性，例如<code>[last_name, middle_name, first_name]</code>。</li></ul></li><li><strong>定义</strong>：原子性是域元素如何使用的一个属性。</li><li><strong>示例</strong>：字符串通常被认为是不可分割的。但是，如果给学生分配像<code>CS0012</code>或<code>EE1127</code>这样的学号，并且提取前两个字符来查找系别，那么学号的域就不是原子的。<strong>这样做是一个坏主意</strong>。</li><li><strong>示例</strong>：<table><thead><tr><th>ID</th><th>name</th><th>age</th><th>origin</th><th>department</th><th>grade</th></tr></thead><tbody><tr><td>2020 211 3xx</td><td>Li</td><td>20</td><td>Beijing</td><td>CS</td><td>2019</td></tr><tr><td>2019 211 4xx</td><td>Wang</td><td>21</td><td>SD</td><td>CS</td><td>2018</td></tr></tbody></table><ul><li>这里的ID似乎是一个复合值（可能包含入学年份、班级、序号），违反了原子性。</li></ul></li></ul><h3 id="第二范式">第二范式</h3><ul><li><strong>定义</strong>：一个关系模式<code>R</code>关于一个FD集合<code>F</code>属于<strong>2NF</strong>，如果：<ol><li><code>R</code>属于1NF，且</li><li>每个属性<code>A</code>满足以下条件之一：<ul><li>它出现在一个候选键中（是主属性）。</li><li>它不是主属性，并且<strong>完全依赖</strong>于某个候选键（即不存在部分依赖）。</li></ul></li></ol></li><li><strong>2NF特点</strong>：<ul><li>不存在非主属性对候选键的<strong>部分依赖</strong>。</li><li>非主属性<strong>完全依赖</strong>于候选键。</li></ul></li></ul><h4 id="2NF示例">2NF示例</h4><ul><li><strong>示例1</strong>：<code>SLC (S#, SDpt, SLocation, C#, Grade)</code><ul><li>FD: <code>(S#, C#) → Grade</code>, <code>SDpt → SLocation</code>, <code>S# → SDpt</code>, <code>(S#, C#) → SDpt</code>, <code>S# → SLocation</code>, <code>(S#, C#) → SLocation</code></li><li><code>SLC</code> <strong>不属于2NF</strong>，因为：<ul><li>对于非主属性<code>SDpt</code>，存在<code>S# → SDpt</code>，所以<code>SDpt</code>部分依赖于键<code>(S#, C#)</code>。</li><li>对于非主属性<code>SLocation</code>，存在<code>S# → SLocation</code>，所以<code>SLocation</code>部分依赖于键<code>(S#, C#)</code>。</li></ul></li></ul></li><li><strong>示例2</strong>：<code>R (Sno, Sname, Status, City, Pno, Qty)</code><ul><li>FD: <code>Sno → Sname</code>, <code>Sno → Status</code>, <code>Status → City</code>, <code>(Sno, Pno) → Qty</code></li><li><code>R</code> <strong>不属于2NF</strong>，因为：<ul><li>对于非主属性<code>Sname</code>和<code>Status</code>，它们部分依赖于键<code>(Sno, Pno)</code>。</li></ul></li><li><strong>注意</strong>：<code>R</code>可以被分解为两个2NF模式：<ul><li><code>R1(Sno, Sname, Status, City)</code></li><li><code>R2(Sno, Pno, Qty)</code></li></ul></li></ul></li></ul><h3 id="Boyce-Codd范式">Boyce-Codd范式</h3><ul><li><strong>定义3</strong>：一个关系模式<code>R</code>关于一个FD集合<code>F</code>属于<strong>BCNF</strong>，如果对于<code>F*</code>中所有形式为<code>α → β</code>（其中<code>α ⊆ R</code>且<code>β ⊆ R</code>）的FD，至少满足以下条件之一：<ol><li><code>α → β</code>是平凡的（即<code>β ⊆ α</code>）。</li><li><code>α</code>是<code>R</code>的一个超键。</li></ol></li></ul><h4 id="BCNF示例">BCNF示例</h4><ul><li><strong>示例</strong>：不属于<strong>BCNF</strong>的模式：<code>in_dep (ID, name, salary, dept_name, building, budget)</code><ul><li><strong>两个FD</strong>：<code>ID → name, salary</code>；<code>dept_name → building, budget</code></li><li><strong>因为</strong>：<code>dept_name → building, budget</code>在<code>in_dep</code>上成立，但<code>dept_name</code><strong>不是</strong>一个<strong>超键</strong>。</li></ul></li><li><strong>注意</strong>：将<code>in_dept</code>分解为<code>instructor</code>和<code>department</code>：<ul><li><code>instructor (ID, name, salary, dept_name)</code> 属于BCNF。</li><li><code>department (dept_name, building, budget)</code> 属于BCNF。</li></ul></li></ul><h4 id="将模式分解为BCNF">将模式分解为BCNF</h4><ul><li>设<code>R</code>是一个不属于BCNF的模式。设<code>α → β</code>是导致违反BCNF的FD。</li><li>将<code>R</code>分解为：<ol><li><code>(α ∪ β)</code> （<code>α → β</code>组成单独模式）</li><li><code>(R - (β - α))</code> （从<code>R</code>中去掉只出现在<code>α → β</code>的右部<code>β</code>，而没有出现在左部<code>α</code>的属性）</li></ol></li><li><code>(α ∪ β)</code> 和 <code>(R - (β - α))</code> 之间存在外键关联。</li><li><strong>示例</strong>：<code>in-dep (ID, name, salary, dept_name, building, budget)</code><ul><li><code>α = dept_name</code>, <code>β = building, budget</code></li><li><code>in_dep</code>被替换为：<ul><li><code>(α ∪ β) = (dept_name, building, budget)</code> （对应<code>department</code>）</li><li><code>(R - (β - α)) = (ID, name, dept_name, salary)</code> （对应<code>instructor</code>）</li></ul></li></ul></li></ul><h4 id="BCNF与依赖保持">BCNF与依赖保持</h4><ul><li><p><strong>并非总是可能同时实现BCNF和依赖保持</strong>。</p></li><li><p><strong>示例</strong>：考虑模式<code>dept_advisor (s_ID, i_ID, dept_name)</code>。</p><ul><li>具有FD：<code>i_ID → dept_name</code>；<code>s_ID, dept_name → i_ID</code>。</li><li>两个候选键：<code>{s_ID, dept_name}</code> 和 <code>{s_ID, i_ID}</code>。</li><li><code>dept_advisor</code>不属于BCNF，因为<code>i_ID</code>不是一个超键。</li></ul></li><li><p>我们需要将<code>dept_advisor</code>分解为两个BCNF模式：</p><ul><li><code>(s_ID, i_ID)</code></li><li><code>(i_ID, dept_name)</code></li></ul></li><li><p>任何这样的分解都<strong>不会</strong>包含<code>s_ID, dept_name → i_ID</code>中的所有属性。</p></li><li><p>因此，该分解<strong>不是</strong>依赖保持的。函数依赖<code>s_ID, dept_name → i_ID</code>只能通过分解后的关系的连接来检查。</p></li><li><p><strong>示例</strong>：</p><ul><li><code>R = {A, B, C}</code>， <code>F = {A → B, B → C}</code>。</li><li><code>R1 = {A, B}</code>, <code>R2 = {B, C}</code>。<ul><li>无损连接分解：<code>R1 ∩ R2 = {B}</code> 且 <code>B → BC</code>。</li><li>依赖保持。</li></ul></li><li><code>R1 = {A, B}</code>, <code>R2 = {A, C}</code>。<ul><li>无损连接分解：<code>R1 ∩ R2 = {A}</code> 且 <code>A → AB</code>。</li><li><strong>不是</strong>依赖保持的（不计算<code>R1</code>和<code>R2</code>的连接就无法检查<code>B → C</code>）。</li></ul></li></ul></li><li><p><strong>注意</strong>：对FD的约束，在实践中检查成本很高，除非它们只<strong>涉及一个</strong>关系。</p></li><li><p>如果只需测试分解中每个单独关系上的FD就能确保<strong>所有</strong>FD都成立，那么该分解就是<strong>依赖保持的</strong>。</p></li><li><p><strong>注意</strong>：因为<strong>并非总是</strong>可能同时实现BCNF和依赖保持，我们考虑一个较弱的范式，称为<strong>第三范式</strong>。</p></li></ul><h3 id="第三范式">第三范式</h3><ul><li><strong>定义</strong>：一个关系模式<code>R</code>属于<strong>第三范式</strong>，如果对于<code>F*</code>中所有的<code>α → β</code>，至少满足以下条件之一：<ol><li><code>α → β</code>是<strong>平凡的</strong>（即<code>β ⊆ α</code>）。</li><li><code>α</code>是<code>R</code>的一个<strong>超键</strong>。</li><li><code>β - α</code>中的每个属性都包含在<code>R</code>的某个候选键中。（即出现在右端但不出现在左端的属性）<ul><li>示例：<code>B → ABC</code>，<code>(ABC) - (B) = AC</code>。A和C可能分别出现在不同的候选键中。</li><li><strong>注意</strong>：每个属性可能在不同的候选键中。</li></ul></li></ol></li><li><strong>注意</strong>：如果一个关系属于BCNF，那么它也属于3NF。</li><li>如果<code>R</code>属于3NF，那么它也属于2NF。</li><li>3NF<strong>消除</strong>了非主属性对键的传递函数依赖。</li><li><strong>性质</strong>：<ul><li><code>R</code>也属于2NF。</li><li>不存在非主属性对候选键的部分和传递依赖。</li><li>每一个非主属性都不传递依赖于<code>R</code>的任何候选键。</li></ul></li></ul><h4 id="3NF示例">3NF示例</h4><ul><li>考虑模式<code>R</code>：<code>dept_advisor (s_ID, i_ID, dept_name)</code>。</li><li>具有FD：<code>i_ID → dept_name</code>；<code>s_ID, dept_name → i_ID</code>。</li><li>两个候选键：<code>{s_ID, dept_name}</code>， <code>{s_ID, i_ID}</code>。</li><li><code>dept_advisor</code>不属于BCNF。</li><li>但是，<code>dept_advisor</code><strong>属于3NF</strong>：<ul><li><code>s_ID, dept_name</code>是一个超键。</li><li><code>i_ID → dept_name</code>成立，而<code>i_ID</code><strong>不是</strong>一个超键，但是：<ul><li><code>{dept_name} - {i_ID} = {dept_name}</code>，并且</li><li><code>dept_name</code>包含在一个候选键<code>{s_ID, dept_name}</code>中。</li></ul></li></ul></li></ul><h4 id="3NF中的冗余">3NF中的冗余</h4><ul><li>考虑以下属于3NF的模式<code>R</code>：<ul><li><code>R = {J, K, L}</code></li><li><code>F = {JK → L, L → K}</code></li></ul></li><li><strong>问题</strong>：<ul><li><strong>信息重复</strong>：当某个<code>L</code>值（例如<code>l1</code>）指导多名学生（对应多个<code>J</code>值）时，其关联的<code>K</code>值会重复。</li><li><strong>需要使用空值</strong>：例如，为了表示关系<code>(l2, k2)</code>，其中没有对应的<code>J</code>值（即某个教师没有指导学生），则<code>J</code>列必须为<code>null</code>。</li></ul></li><li>映射到<code>dept_advisor</code>示例：<code>J</code>对应<code>s_ID</code>，<code>L</code>对应<code>i_ID</code>，<code>K</code>对应<code>dept_name</code>。</li></ul><table><thead><tr><th style="text-align:left">J (s_ID)</th><th style="text-align:left">L (i_ID)</th><th style="text-align:left">K (dept_name)</th></tr></thead><tbody><tr><td style="text-align:left">j1</td><td style="text-align:left">l1</td><td style="text-align:left">k1</td></tr><tr><td style="text-align:left">j2</td><td style="text-align:left">l1</td><td style="text-align:left">k1</td></tr><tr><td style="text-align:left">j3</td><td style="text-align:left">l1</td><td style="text-align:left">k1</td></tr><tr><td style="text-align:left">null</td><td style="text-align:left">l2</td><td style="text-align:left">k2</td></tr></tbody></table><h3 id="BCNF与3NF的比较">BCNF与3NF的比较</h3><ul><li><strong>3NF相对于BCNF的优点</strong>：总是可以在不牺牲无损连接性或依赖保持性的情况下获得一个3NF设计。<ul><li>3NF分解可以保证无损连接、函数依赖保持。</li><li>BCNF分解保证无损连接，但不保证函数依赖保持。</li></ul></li><li><strong>3NF的缺点</strong>：<ul><li>我们可能不得不使用空值来表示数据项之间一些可能的有意义的关系。</li><li>存在信息重复的问题。</li></ul></li></ul><h3 id="规范化的目标">规范化的目标</h3><ul><li>设<code>R</code>是一个具有FD集合<code>F</code>的关系模式。</li><li>决定一个关系模式<code>R</code>是否形式良好。</li><li>当一个关系模式<code>R</code>形式不佳时，将其分解为<code>{R1, R2, ..., Rn}</code>，使得：<ul><li>每个关系模式<strong>形式良好</strong>，例如属于2NF、3NF、BCNF。</li><li>该分解是<strong>无损分解</strong>。</li><li>该分解应该是<strong>依赖保持的</strong>。</li></ul></li></ul><h3 id="范式总结">范式总结</h3><ul><li><strong>1NF</strong>：属性原子。</li><li><strong>2NF</strong>：消除非主属性对键的<strong>部分函数依赖</strong>。</li><li><strong>3NF</strong>：消除非主属性对键的<strong>传递函数依赖</strong>。</li><li><strong>BCNF</strong>：消除<strong>所有属性</strong>（包括主属性和非主属性）对键的部分和传递依赖。更严格：所有非平凡的FD，其左部必须是超键。</li></ul><hr><h2 id="7-4-函数依赖理论">7.4 函数依赖理论</h2><h3 id="目标">目标</h3><ol><li>由给定FD集合逻辑蕴含的FD（Armstrong公理）。</li><li>开发算法，生成到BCNF和3NF的无损分解。</li><li>开发算法，测试分解是否是依赖保持的。</li></ol><h3 id="函数依赖间的逻辑蕴含">函数依赖间的逻辑蕴含</h3><ul><li>给定一个FD集合<code>F</code>，存在其他被<code>F</code>逻辑蕴含的FD <code>f</code>。</li><li><strong>示例</strong>：如果<code>A → B</code>且<code>B → C</code>，则可推断<code>A → C</code>。</li><li><strong>定义</strong>：给定模式<code>R</code>，一个FD <code>f</code>被FD集合<code>F</code><strong>逻辑蕴含</strong>，如果每个满足<code>F</code>的实例<code>r(R)</code>也都满足<code>f</code>。<ul><li><code>{f} = {A → B, B → C}* = {A → B, B → C, A → C, ...}</code></li></ul></li><li><strong>定义</strong>：被<code>F</code>逻辑蕴含的所有FD的集合称为<code>F</code>的闭包。用<code>F+</code>表示<code>F</code>的闭包。<ul><li><code>F+ = {f | f 被 F 逻辑蕴含}</code>。</li></ul></li></ul><h4 id="示例">示例</h4><p><code>F = {A → B, B → C}</code>;<br><code>f: A → C</code> 被<code>F</code>逻辑蕴含。</p><h3 id="函数依赖集的闭包">函数依赖集的闭包</h3><ul><li>通过重复应用Armstrong公理计算<code>F</code>的闭包<code>F+</code>：<ol><li><strong>自反律</strong>：如果<code>β ⊆ α</code>，则<code>α → β</code>。</li><li><strong>增广律</strong>：如果<code>α → β</code>，则<code>γα → γβ</code>。</li><li><strong>传递律</strong>：如果<code>α → β</code>，且<code>β → γ</code>，则<code>α → γ</code>。</li></ol></li><li>这些规则是：<ul><li><strong>健全的</strong>：只生成实际成立的FD。</li><li><strong>完备的</strong>：生成所有成立的FD。</li></ul></li><li><strong>附加规则</strong>（可从上述公理推导）：<ul><li><strong>合并律</strong>：如果<code>α → β</code>成立且<code>α → γ</code>成立，则<code>α → βγ</code>成立。</li><li><strong>分解律</strong>：如果<code>α → βγ</code>成立，则<code>α → β</code>成立且<code>α → γ</code>成立。</li><li><strong>伪传递律</strong>：如果<code>α → β</code>成立且<code>γβ → δ</code>成立，则<code>αγ → δ</code>成立。</li></ul></li></ul><h4 id="示例-2">示例</h4><ul><li><code>R = {A, B, C, G, H, I}</code></li><li><code>F = {A → B, A → C, CG → H, CG → I, B → H}</code></li><li><strong>F+中的一些成员</strong>：<ul><li><code>A → H</code>：根据<code>A → B</code>和<code>B → H</code>的传递性。</li><li><code>AG → I</code>：用<code>G</code>增广<code>A → C</code>得到<code>AG → CG</code>，然后与<code>CG → I</code>传递得到。</li><li><code>CG → HI</code>：增广<code>CG → I</code>推导出<code>CG → CGI</code>，增广<code>CG → H</code>推导出<code>CGI → HI</code>，然后传递。</li></ul></li></ul><h3 id="属性集的闭包">属性集的闭包</h3><ul><li><strong>定义</strong>：在<code>F</code>下，如果<code>α → B</code>在<code>F</code>下成立，则属性<code>B</code>被<code>α</code><strong>函数确定</strong>。记作 <code>α |-F-&gt; B</code>。</li><li><strong>定义</strong>：给定一个属性集<code>α</code>，<code>α</code>在<code>F</code>下的闭包（记作<code>α+</code>）是被<code>α</code>在<code>F</code>下函数确定的属性集合。<ul><li><code>α+ = {β | β 被 α 在 F 下函数确定} = {β | α |-F-&gt; β}</code></li></ul></li></ul><h4 id="属性集闭包算法">属性集闭包算法</h4><ul><li><strong>输入</strong>：<code>α</code>， <code>F</code></li><li><strong>输出</strong>：<code>α+</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result := α;</span><br><span class="line">while (result 发生改变) do</span><br><span class="line">    for each β → γ in F do</span><br><span class="line">        if β ⊆ result then result := result ∪ γ</span><br></pre></td></tr></table></figure><h4 id="属性集闭包示例">属性集闭包示例</h4><ul><li><code>R = {A, B, C, G, H, I}</code></li><li><code>F = {A → B, A → C, CG → H, CG → I, B → H}</code></li><li>计算<code>(AG)+</code>：<ol><li><code>result = AG</code></li><li><code>result = ABCG</code> （<code>A → C</code> 和 <code>A → B</code>）</li><li><code>result = ABCGH</code> （<code>CG → H</code> 且 <code>CG ⊆ AGBCH</code>）</li><li><code>result = ABCGHI</code> （<code>CG → I</code> 且 <code>CG ⊆ AGBCH</code>）</li></ol></li><li><code>(AG)+ = R</code>，所以<code>AG</code>是<code>R</code>的一个<strong>超键</strong>。</li><li><strong>问题</strong>：<code>AG</code>是候选键吗？<ol><li><code>AG</code>是超键吗？是。</li><li><code>AG</code>的任何子集是超键吗？<ul><li>计算<code>(A)+</code>：<code>(A)+ = {A, B, C, H}</code> ≠ <code>R</code>，所以<code>A</code>不是超键。</li><li>计算<code>(G)+</code>：<code>(G)+ = {G}</code> ≠ <code>R</code>，所以<code>G</code>不是超键。</li></ul></li><li>因此，<code>AG</code>是一个候选键。</li></ol></li></ul><h4 id="属性闭包算法的用途">属性闭包算法的用途</h4><ol><li><strong>测试超键</strong>：要测试<code>α</code>是否是超键，计算<code>α+</code>并检查<code>α+</code>是否包含<code>R</code>的所有属性。</li><li><strong>测试FD</strong>：要检查FD <code>α → β</code>是否成立（即是否在<code>F+</code>中），只需检查<code>β ⊆ α+</code>。<ul><li><strong>注意</strong>：通过属性闭包计算<code>α+</code>，然后检查它是否包含<code>β</code>。</li></ul></li></ol><h3 id="FD集合的等价">FD集合的等价</h3><ul><li><strong>定义</strong>：对于两个FD集合<code>F</code>和<code>G</code>，如果<code>F+ = G+</code>，则<code>F</code>和<code>G</code>是<strong>等价的</strong>。</li><li><strong>示例</strong>：<code>F = {A → B, B → C}</code> 等价于 <code>G = {A → B, B → C, A → C}</code>。</li></ul><h3 id="正则覆盖">正则覆盖</h3><ul><li><strong>动机</strong>：当用户对<code>R</code>执行<strong>更新</strong>时，DBS必须确保该更新不会<strong>违反</strong>任何FD。所有在<code>F</code>中的FD都必须被DBS满足，通常通过执行检查约束、断言、触发器或更复杂的SQL语句来实现，成本很高。<ul><li>例如，更新<code>Student_grade</code>， <code>set grade = grade + 10</code>，要求<code>grade</code>在0到100之间。如果更新前的值为60,70,80,90,100，更新后70,80,90,100,110，最后一条记录违反了约束。</li></ul></li><li>检查<code>R</code>上所有<code>α → β</code>是否成立是耗时的。<ul><li><code>F</code>中可能有<strong>冗余</strong>的依赖，可以从其他依赖推导出来。</li><li>例如，在<code>{A → B, B → C, A → C}</code>中，<code>A → C</code>是冗余的。</li></ul></li><li><strong>正则覆盖</strong>：简化后的集合称为<strong>正则覆盖</strong>。我们希望测试一个与<code>F</code>等价的<strong>最小</strong>FD集合。</li><li><strong>定义1</strong>：<code>F</code>的一个<strong>正则覆盖</strong> <code>Fc</code> 是一个与<code>F</code>等价的<strong>最小</strong>FD集合，没有冗余的FD或属性。<ul><li><code>F+ = Fc+</code></li></ul></li><li><strong>定义2：冗余FD</strong>：冗余FD可以从<code>F</code>中的其他FD推断出来。</li></ul><h4 id="无关属性和无关FD">无关属性和无关FD</h4><ul><li><strong>定义3：无关属性</strong>：如果我们可以删除FD中的一个属性而不改变<code>F+</code>，则该属性是<strong>无关的</strong>。</li><li><strong>动机</strong>：FD左边或右边的属性可能是无关的。</li><li><strong>性质1</strong>：从FD的左边移除一个属性可能会使它成为一个<strong>更强的</strong>约束。<ul><li>例如，如果我们有<code>AB → C</code>并移除<code>B</code>，我们得到可能更强的结果<code>A → C</code>。因为<code>AB → BC</code>逻辑蕴含<code>AB → C</code>，但<code>AB → C</code>不逻辑蕴含<code>A → C</code>。</li><li>但是，根据FD集合<code>F</code>的具体情况，我们可能可以安全地从<code>AB → C</code>中移除<code>B</code>。假设<code>F = {AB → C, A → D, D → C}</code>。证明<code>F</code>逻辑蕴含<code>A → C</code>，使得<code>B</code>在<code>AB → C</code>中是无关的。</li></ul></li><li><strong>性质2</strong>：从FD的右边移除一个属性可能会使它成为一个<strong>更弱的</strong>约束。<ul><li>例如，如果我们有<code>AB → CD</code>并移除<code>C</code>，我们得到可能更弱的结果<code>AB → D</code>。</li><li>但是，根据FD集合<code>F</code>的具体情况，我们可能可以安全地从<code>AB → CD</code>中移除<code>C</code>。</li><li>例如，假设<code>F = {AB → CD, A → C} = {AB → CD, AB → BC}</code>。在用<code>AB → D</code>替换<code>AB → CD</code>后，我们仍然可以推断出<code>AB → C</code>，从而<code>AB → CD</code>。</li></ul></li></ul><h4 id="测试一个属性是否无关">测试一个属性是否无关</h4><ul><li>考虑FD <code>α → β</code>中的属性<code>B ∈ β</code>。<ul><li><strong>测试<code>B</code>在<code>β</code>中是否无关</strong>：<ul><li>考虑集合 <code>F' = (F - {α → β}) ∪ {α → (β - B)}</code>。</li><li>检查在<code>F'</code>下<code>α+</code>是否包含<code>B</code>（即<code>B ∈ α+</code>）。</li><li>如果是，则<code>B</code>在<code>β</code>中是无关的。</li></ul></li></ul></li><li>考虑FD <code>α → β</code>中的属性<code>A ∈ α</code>。<ul><li><strong>测试<code>A</code>在<code>α</code>中是否无关</strong>：<ul><li>令 <code>γ = α - {A}</code>。检查<code>γ → β</code>是否可以从<code>F</code>推断出来。</li><li>使用<code>F</code>中的DF计算<code>γ+</code>。</li><li>如果<code>γ+</code>包含<code>β</code>中的所有属性（即<code>β ⊆ γ+</code>），那么<code>A</code>在<code>α</code>中是无关的。</li></ul></li></ul></li></ul><h4 id="无关属性示例">无关属性示例</h4><ul><li><strong>例1</strong>：给定<code>F = {A → C, AB → C}</code>。<code>B</code>在<code>AB → C</code>中是无关的，因为<code>{A → C, AB → C}</code>逻辑蕴含<code>A → C</code>。</li><li><strong>例2</strong>：给定<code>F = {A → C, AB → CD}</code>。<code>C</code>在<code>AB → CD</code>中是无关的，因为删除<code>C</code>后，仍然可以从其他依赖推断出<code>AB → C</code>。</li><li><strong>例3</strong>：<code>F = {AB → CD, A → E, E → C}</code>。检查<code>C</code>在<code>AB → CD</code>中是否无关。<ul><li><strong>步骤1</strong>：计算<code>AB</code>在<code>F' = {AB → D, A → E, E → C}</code>下的闭包。</li><li><strong>步骤2</strong>：闭包是<code>ABCDE</code>，包含<code>C</code>。</li><li><strong>结论</strong>：<code>C</code>是无关的。</li></ul></li></ul><h4 id="正则覆盖定义与计算">正则覆盖定义与计算</h4><ul><li><strong>定义4</strong>：<code>F</code>的一个正则覆盖<code>Fc</code>是一个满足以下条件的FD集合：<ol><li><code>F</code>逻辑蕴含<code>Fc</code>中的所有依赖。</li><li><code>Fc</code>逻辑蕴含<code>F</code>中的所有依赖。</li><li><code>Fc</code>中不包含无关属性。</li><li><code>Fc</code>中每个FD的左部是唯一的。不存在两个FD <code>α1 → β1</code>和<code>α2 → β2</code>使得<code>α1 = α2</code>。</li></ol></li><li><strong>计算</strong><code>F</code>的正则覆盖：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fc = F</span><br><span class="line">repeat</span><br><span class="line">    使用合并律，将Fc中形式为α1 → β1和α1 → β2的FD替换为α1 → β1β2。</span><br><span class="line">    在Fc中找到一个FD α → β，它在α或β中有一个无关属性。</span><br><span class="line">    如果找到了无关属性，将其从α → β中删除。</span><br><span class="line">until (Fc不再改变)</span><br></pre></td></tr></table></figure><ul><li><strong>注意1</strong>：在删除一些无关属性后，合并律可能变得适用。</li><li><strong>注意2</strong>：一个FD集合<code>F</code>可能有多个正则覆盖<code>Fc</code>。</li></ul><h4 id="正则覆盖计算示例">正则覆盖计算示例</h4><ul><li><code>R = {A, B, C}</code></li><li><code>F = {A → BC, B → C, A → B, AB → C}</code></li><li><strong>步骤1</strong>：使用合并律将<code>A → BC</code>和<code>A → B</code>合并为<code>A → BC</code>。<ul><li>集合变为<code>F1 = {A → BC, B → C, AB → C}</code>。</li></ul></li><li><strong>步骤2</strong>：<code>A</code>在<code>AB → C</code>中是无关的。<ul><li>检查从<code>AB → C</code>中删除<code>A</code>的结果是否被其他依赖蕴含。是的：<code>B → C</code>已经存在！</li><li>集合变为<code>F2 = {A → BC, B → C}</code>。</li></ul></li><li><strong>步骤3</strong>：<code>C</code>在<code>A → BC</code>中是无关的。<ul><li>检查<code>A → C</code>是否被<code>A → B</code>和其他依赖逻辑蕴含。是的：使用<code>A → B</code>和<code>B → C</code>的传递性。</li></ul></li><li><strong>结论</strong>：正则覆盖是：<code>Fc = {A → B, B → C}</code>。</li></ul><h3 id="无损连接分解">无损连接分解</h3><ul><li>对于<code>R = (R1, R2)</code>，我们要求对于模式<code>R</code>上所有可能的关系<code>r</code>，都有 <code>r = ∏_{R1}(r) ⋈ ∏_{R2}(r)</code>。</li><li>将<code>R</code>分解为<code>R1</code>和<code>R2</code>是无损连接的，如果以下依赖中至少有一个在<code>F*</code>中：<ul><li><code>R1 ∩ R2 → R1</code></li><li><code>R1 ∩ R2 → R2</code></li></ul></li><li><strong>注意</strong>：上述FD是无损连接分解的<strong>充分条件</strong>；只有当所有约束都是FD时，这些依赖才是<strong>必要条件</strong>。</li><li><strong>不同于表间存在外键关联</strong>：无损连接是一个更广义的概念。</li></ul><h3 id="依赖保持">依赖保持</h3><ul><li><strong>定义1</strong>：对于模式<code>R</code>，<code>F</code>在<code>R</code>上成立，以及<code>R</code>的分解<code>{R1, R2, ..., Rn}</code>：<ul><li><code>F</code>到<code>Ri</code>的<strong>限制</strong>，记作<code>Fi</code>，定义为 <code>Fi = {α → β | α → β ∈ F+ 且 αβ ⊆ Ri}</code>。<ul><li>这是<code>F+</code>中仅包含<code>Ri</code>中属性的FD集合。</li></ul></li></ul></li><li><strong>定义2</strong>：设<code>Fi</code>是<code>F</code>到<code>Ri</code>的限制。如果 <code>(F1 ∪ F2 ∪ ... ∪ Fn)+ = F+</code>，则分解是<strong>依赖保持的</strong>。</li><li><strong>注意</strong>：测试依赖保持是指数时间的。</li></ul><h4 id="依赖保持测试算法">依赖保持测试算法</h4><ul><li><strong>测试</strong>：FD <code>α → β</code>在分解<code>R = {R1, R2, ..., Rn}</code>中是否被保持？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result = α</span><br><span class="line">repeat</span><br><span class="line">    for each Ri in the decomposition</span><br><span class="line">        t = ((result ∩ Ri)+ ∩ Ri) // 在F下计算(result ∩ Ri)的闭包，然后与Ri取交集</span><br><span class="line">        result = result ∪ t</span><br><span class="line">until (result不再改变)</span><br></pre></td></tr></table></figure><ul><li>如果<strong>result</strong>包含<code>β</code>中的所有属性，则FD <code>α → β</code>被保持。</li><li>对所有FD进行测试以检查分解是否是依赖保持的。</li><li>该过程需要多项式时间。</li></ul><h4 id="依赖保持示例">依赖保持示例</h4><ul><li><strong>例1</strong>：<code>R (A, B, C, D)</code>， <code>F = {A → B, B → C, A → D, B → D}</code> 在<code>R</code>上。<ul><li><code>F+ = F ∪ {A → C} ∪ ...</code></li><li>无损分解：<code>R1(A, B, C)</code>， <code>F1 = {A → B, B → C}</code>；<code>R2(B, D)</code>， <code>F2 = {B → D}</code>。</li><li><strong>问题</strong>：<code>A → D</code>是否被保持？</li><li><code>A |-F1-&gt; B</code>， <code>B |-F2-&gt; D</code>，所以<code>A → D</code>被保持。</li></ul></li><li><strong>例2</strong>：<code>Student (sno, dept, head)</code>， <code>F = {sno → dept, dept → head}</code>。<ul><li><code>F+ = F ∪ {sno → head} ∪ {...}</code></li><li><strong>分解1</strong>：<code>R1(sno, dept)</code>， <code>F1 = {sno → dept}</code>；<code>R2(sno, head)</code>， <code>F2 = {sno → head}</code>。<ul><li><strong>无损</strong>，因为<code>R1 ∩ R2 = {sno}</code>，是<code>R1</code>和<code>R2</code>的键。</li><li><strong>非依赖保持</strong>，因为<code>(F1 ∪ F2)+ ≠ F+</code>，<strong>dept → head</strong>丢失了。</li><li><strong>原因</strong>：对于<code>F</code>中的<strong>dept → head</strong>，使用算法：<ul><li>关于<code>R1</code>：<code>result = (dept ∩ {sno, dept})+ ∩ {sno, dept} = {dept}+ ∩ {sno, dept} = {dept, head} ∩ {sno, dept} = {dept}</code>。</li><li>关于<code>R2</code>：<code>result = (dept ∩ {sno, head})+ ∩ {sno, head} = ∅+ ∩ {sno, head} = ∅</code>。</li><li>最终<code>result = {dept}</code>，不包含<code>head</code>，所以该FD未被保持。</li></ul></li></ul></li><li><strong>分解2</strong>：<code>R1(sno, dept)</code>， <code>F1 = {sno → dept}</code>；<code>R2(dept, head)</code>， <code>F2 = {dept → head}</code>。<ul><li><strong>无损连接</strong>，因为<code>R1 ∩ R2 = {dept}</code>，并且是<code>R2</code>的键。</li><li><strong>依赖保持</strong>，因为<code>(F1 ∪ F2)+ = F+</code>。</li></ul></li></ul></li></ul><hr><h2 id="7-5-使用函数依赖的分解算法">7.5 使用函数依赖的分解算法</h2><h3 id="内容概览-2">内容概览</h3><ul><li>测试BCNF</li><li>BCNF分解</li><li>BCNF分解算法</li><li>测试3NF</li><li>3NF分解</li><li>3NF分解算法</li></ul><h3 id="测试关系是否属于BCNF">测试关系是否属于BCNF</h3><ul><li><strong>方法</strong>：要判断FD <code>α → β</code>是否导致违反BCNF：<ol><li>计算<code>α+</code>（<code>α</code>的属性闭包）。</li><li>验证它是否包含<code>R</code>的所有属性，即它是否是<code>R</code>的超键。</li></ol></li><li><strong>简化测试</strong>：要检查一个关系模式<code>R</code>是否属于BCNF，只需检查<code>F</code>中（而不是<code>F+</code>中）的每个FD是否违反BCNF即可。<ul><li>如果<code>F</code>中没有FD导致违反BCNF，那么<code>F+</code>中也没有FD会导致违反BCNF。</li></ul></li><li><strong>注意</strong>：当测试<strong>R的分解</strong>中的关系时，仅使用<code>F</code>的简化测试是<strong>不正确</strong>的。<ul><li><strong>示例</strong>：<code>R = {A, B, C, D, E}</code>， <code>F = {A → B, BC → D}</code>。<ul><li>将<code>R</code>分解为<code>R1 = {A, B}</code>和<code>R2 = {A, C, D, E}</code>。</li><li><code>F</code>中的FD都不只包含<code>{A, C, D, E}</code>中的属性，所以我们可能误以为<code>R2</code>满足BCNF。</li><li>事实上，<code>F+</code>中的FD <code>AC → D</code>表明<code>R2</code>不属于BCNF（因为<code>AC</code>不是<code>R2</code>的超键）。</li></ul></li></ul></li></ul><h3 id="测试分解中的关系是否属于BCNF">测试分解中的关系是否属于BCNF</h3><ul><li>要么使用<code>Fi</code>（<code>F+</code>到<code>Ri</code>的限制）来测试<code>Ri</code>。</li><li>要么使用原始FD集合<code>F</code>，但进行如下测试：对于每个属性集<code>α ⊆ Ri</code>，检查<code>α+</code>要么不包含<code>Ri - α</code>中的任何属性，要么包含<code>Ri</code>的所有属性。</li></ul><h3 id="BCNF分解算法">BCNF分解算法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：关系模式 R，以及在其上成立的 FD 集合 F。</span><br><span class="line">输出：R 的一个无损 BCNF 分解。</span><br><span class="line"></span><br><span class="line">result := &#123;R&#125;;</span><br><span class="line">done := false;</span><br><span class="line">while (not done) do</span><br><span class="line">    if (result 中存在一个不属于 BCNF 的子模式 Ri)</span><br><span class="line">    then begin</span><br><span class="line">        令 α → β 是 Ri 上成立的一个 FD，使得：</span><br><span class="line">            (1) α 不是 Ri 的超键（由于 α → β，并且关于 F 在 R 上的限制）。</span><br><span class="line">            (2) α → β 是非平凡的（即 β ⊈ α）。</span><br><span class="line">        用两个子模式替换 result 中的 Ri：</span><br><span class="line">            (α ∪ β) 和 (Ri - β)</span><br><span class="line">        result := (result - &#123;Ri&#125;) ∪ &#123;(Ri - β), (α ∪ β)&#125;;</span><br><span class="line">    end</span><br><span class="line">    else done := true;</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：<ul><li>如何判断<code>Ri</code>是否属于BCNF？检查是否有非平凡FD <code>α → β</code>在<code>Ri</code>上成立，且<code>α</code>不是<code>Ri</code>的超键。</li><li>算法将非BCNF的<code>Ri</code>替换为<code>(Ri - β)</code>和<code>(α, β)</code>。<code>Ri</code>被分解为<code>(Ri - β)</code>和属于BCNF的<code>(α, β)</code>。</li><li><code>F</code>到模式<code>{α, β}</code>的限制是<code>α → β</code>，且<code>α</code>是<code>(α, β)</code>的超键，所以<code>(α, β)</code>属于BCNF。</li></ul></li></ul><h4 id="BCNF分解示例">BCNF分解示例</h4><ul><li><strong>例1</strong>：<ul><li><code>R = {A, B, C}</code></li><li><code>F = {A → B, B → C}</code></li><li>键 = <code>{A}</code></li><li><code>R</code>不属于BCNF（<code>B → C</code>成立但<code>B</code>不是超键）。</li><li><strong>分解</strong>：<ul><li>由于<code>B → C</code>违反BCNF（<code>B</code>不是超键），将<code>R</code>分解为：<ul><li><code>R1 = {B, C}</code>， <code>F1 = {B → C}</code></li><li><code>R2 = {A, B}</code>， <code>F2 = {A → B}</code></li></ul></li></ul></li></ul></li><li><strong>例2</strong>：<ul><li><code>class (course_id, title, dept_name, credits, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code></li><li>FDs:<ul><li><code>course_id → title, dept_name, credits</code></li><li><code>building, room_number → capacity</code></li><li><code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li></ul></li><li>候选键：<code>{course_id, sec_id, semester, year}</code>（计算过程略）。</li><li><strong>BCNF分解</strong>：<ul><li>FD <code>course_id → title, dept_name, credits</code> 成立，但 <code>course_id</code> 不是超键。将 <code>class</code> 替换为：<ul><li><code>course (course_id, title, dept_name, credits)</code> （属于BCNF，<code>course_id</code>是候选键）</li><li><code>class-1 (course_id, sec_id, semester, year, building, room_number, capacity, time_slot_id)</code></li></ul></li><li>检查 <code>class-1</code>：<ul><li>FDs: <code>building, room_number → capacity</code>；<code>course_id, sec_id, semester, year → building, room_number, time_slot_id</code></li><li>候选键：<code>{course_id, sec_id, semester, year}</code></li><li><code>class-1</code>不属于BCNF，因为<code>building, room_number → capacity</code>成立，但<code>{building, room_number}</code>不是超键。</li><li>将<code>class-1</code>替换为：<ul><li><code>classroom (building, room_number, capacity)</code> （属于BCNF）</li><li><code>section (course_id, sec_id, semester, year, building, room_number, time_slot_id)</code> （属于BCNF）</li></ul></li></ul></li></ul></li><li>最终<code>class</code>被分解为<code>course</code>、<code>classroom</code>和<code>section</code>。</li></ul></li></ul><h4 id="BCNF分解可能无法保持依赖">BCNF分解可能无法保持依赖</h4><ul><li><strong>例3</strong>：<ul><li><code>R = {J, K, L}</code></li><li><code>F = {JK → L, L → K}</code></li><li>两个候选键：<code>JK</code> 和 <code>JL</code></li><li><code>R</code>不属于BCNF（因为<code>L → K</code>成立，<code>L</code>不是超键）。</li><li>一个BCNF分解：<ul><li><code>R1 = {L, K}</code> 具有 <code>L → K</code>，</li><li><code>R2 = {J, L}</code> 没有FD。</li></ul></li><li><strong>问题</strong>：不保持依赖。<code>JK → L</code>丢失了。<code>R</code>的任何分解都无法保持<code>JK → L</code>。</li></ul></li></ul><h3 id="第三范式分解">第三范式分解</h3><ul><li><strong>动机</strong>：<ul><li>有些情况下，BCNF不是依赖保持的，而检查FD违反很重要。</li><li><strong>解决方案</strong>：定义一个较弱的范式，3NF。它允许一些冗余，但存在到3NF的无损连接、依赖保持分解。</li></ul></li><li><strong>注意</strong>：应计算出<code>R</code>的所有候选键！</li></ul><h4 id="测试关系是否属于3NF">测试关系是否属于3NF</h4><ul><li><strong>优化</strong>：只检查<code>F</code>中的FD，而不是<code>F+</code>中的所有FD。<ol><li>如果<code>α</code>是超键（使用属性闭包检查每个FD <code>α → β</code>）。</li><li>如果<code>α</code>不是超键，检查<code>β</code>中的<strong>每个属性</strong>是否包含在某个<strong>候选键</strong>中。</li></ol></li><li>测试是<strong>昂贵的</strong>，因为它涉及找到<strong>所有</strong>候选键。</li><li>测试3NF已被证明是NP-hard问题。</li><li>但是，<strong>分解</strong>到3NF可以在多项式时间内完成。</li></ul><h4 id="3NF分解算法">3NF分解算法</h4><ul><li><strong>输入</strong>：关系模式<code>R</code>，在其上成立的FD集合<code>F</code>。</li><li><strong>输出</strong>：<code>R</code>的一个无损且依赖保持的3NF分解。</li><li><strong>步骤</strong>：<br>0.  <strong>找出<code>R</code>的所有候选键</strong>。<ol><li>找出<code>F</code>的一个正则覆盖<code>Fc</code>。</li><li>对于<code>Fc</code>中的每个FD <code>α → β</code>，如果<code>αβ</code>还没有被包含在任何已生成的模式<code>Rj (1 ≤ j ≤ i)</code>中，则创建一个新的子模式<code>Ri := αβ</code>。</li><li>如果第2步生成的子模式中没有一个包含<code>R</code>的<strong>任一候选键</strong>，则挑选<code>R</code>的任意一个候选键，为其单独创建一个子模式<code>Ri</code>。</li><li>返回<code>(R1, R2, ..., Ri)</code>。</li></ol></li><li><strong>注意</strong>：<ul><li>只要有一个候选键包含在第2步构造出的某个子模式<code>Ri</code>中，就无需在第3步中为候选键单独构造子模式。</li><li>第3步中只需挑选<code>R</code>的<strong>一个</strong>候选键。</li></ul></li></ul><h4 id="3NF分解示例">3NF分解示例</h4><ul><li><strong>例1</strong>：<ul><li>考虑模式<code>R(X, Y, Z, W)</code>，<code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code>在<code>R</code>上成立。给出一个无损、依赖保持的3NF分解。</li><li><strong>解法</strong>：<ul><li><strong>步骤1. 求候选键</strong>：<ul><li>使用附录7-1算法：L类={Y, W}，R类=空，N类=空，LR类={X, Z}。X_set={Y, W}，计算<code>(YW)+ = R</code>，所以<code>YW</code>是唯一的候选键。</li></ul></li><li><strong>步骤2. 求正则覆盖<code>Fc</code></strong>：<ul><li>原始<code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code>。</li><li>考虑<code>Y → XZ</code>中的<code>X</code>和<code>W → XZ</code>中的<code>Z</code>。</li><li><code>{X → Z, Z → X, Y → Z, W → X}</code> 蕴含 <code>F</code>，所以<code>Y → XZ</code>中的<code>X</code>和<code>W → XZ</code>中的<code>Z</code>都是无关属性。</li><li>因此，一个正则覆盖是 <code>Fc = {X → Z, Z → X, Y → Z, W → X}</code>。</li><li>（注意：<code>F</code>的其他正则覆盖还有：<code>{X → Z, Z → X, Y → X, W → Z}</code>， <code>{X → Z, Z → X, Y → X, W → X}</code>， <code>{X → Z, Z → X, Y → Z, W → Z}</code>）</li></ul></li><li><strong>步骤3. 根据算法生成子模式</strong>：<ul><li>对<code>Fc = {X → Z, Z → X, Y → Z, W → X}</code>中的每个FD：<ul><li><code>X → Z</code>：创建 <code>R1 = {X, Z}</code></li><li><code>Z → X</code>：已被<code>R1</code>包含（<code>XZ</code>）。</li><li><code>Y → Z</code>：创建 <code>R2 = {Y, Z}</code></li><li><code>W → X</code>：创建 <code>R3 = {W, X}</code></li></ul></li><li>检查候选键<code>YW</code>：它没有被任何现有子模式包含（<code>R1={X,Z}</code>, <code>R2={Y,Z}</code>, <code>R3={W,X}</code>）。</li><li>因此，为候选键<code>YW</code>创建 <code>R4 = {Y, W}</code>。</li></ul></li><li>一个3NF分解是：<code>{XZ, YZ, WX, YW}</code>。</li><li>如果使用其他正则覆盖，会得到不同的但等价的分解，例如：<code>{XZ, YX, WX, YW}</code>， <code>{XZ, YX, WZ, YW}</code>， <code>{XZ, YZ, WZ, YW}</code>。</li></ul></li></ul></li><li><strong>例2</strong>：<ul><li><code>R {stNo, Name, Telno, stId, Classno, Cno, Cname, Grade}</code></li><li><code>F = {stNo → Name, Telno, stId, Classno, stId → stNo, stNo, Cno → Grade, Cno → Cname}</code></li><li><strong>所有候选键</strong>：<code>(stNo, Cno)</code>， <code>(stId, Cno)</code> （计算过程略）。</li><li><strong>R的最高范式</strong>？<ul><li>不属于BCNF，因为存在<code>stNo → ...</code>（左部不是超键），<code>stId → stNo</code>（左部不是超键），<code>Cno → Cname</code>（左部不是超键）。</li><li>不属于3NF，因为对于FD1 <code>stNo → Name, Telno, stId, Classno</code>，<code>α = stNo</code>不是超键，且<code>β - α</code>中的属性<code>{Name, Telno, stId, Classno}</code>不包含在任何候选键中（候选键是<code>(stNo, Cno)</code>和<code>(stId, Cno)</code>，这些属性不在键中）。</li></ul></li><li><strong>给出一个无损连接且依赖保持的3NF分解</strong>：<ul><li><code>Fc = F</code> （假设已是最小）。</li><li>对每个FD创建子模式：<ul><li><code>stNo → Name, Telno, stId, Classno</code>：<code>R1(stNo, Name, Telno, stId, Classno)</code></li><li><code>stId → stNo</code>：<code>stId, stNo</code>已包含在<code>R1</code>中。</li><li><code>stNo, Cno → Grade</code>：<code>R2(stNo, Cno, Grade)</code></li><li><code>Cno → Cname</code>：<code>R3(Cno, Cname)</code></li></ul></li><li>检查候选键：<code>(stNo, Cno)</code>已包含在<code>R2</code>中，因此无需为另一个候选键<code>(stId, Cno)</code>单独创建子模式。</li><li>分解为：<code>R1, R2, R3</code>。</li></ul></li></ul></li></ul><h3 id="BCNF与3NF对比">BCNF与3NF对比</h3><ul><li><strong>注意</strong>：总是可以将一个关系分解为一组属于3NF的关系，使得：<ul><li>分解是无损的。</li><li>依赖是保持的。</li></ul></li><li><strong>注意</strong>：总是可以将一个关系分解为一组属于BCNF的关系，使得：<ul><li>分解是无损的。</li><li>但可能无法保持依赖。</li></ul></li></ul><hr><h2 id="附录7-1-计算候选键算法">附录7-1 计算候选键算法</h2><h3 id="定理">定理</h3><ul><li>如果属性<code>A</code>只出现在<code>F</code>中函数依赖的左部<code>α</code>，则<code>A</code>一定是主属性，必然出现在候选键中。</li></ul><h3 id="方法">方法</h3><ul><li><strong>输入</strong>：关系模式<code>R</code>及其函数依赖集<code>F</code>。</li><li><strong>输出</strong>：<code>R</code>的所有候选键。</li><li><strong>步骤</strong>：<ol><li>将<code>R</code>的所有属性分为四类：<ul><li><strong>L类</strong>：仅出现在<code>F</code>中函数依赖<strong>左部</strong>的属性。</li><li><strong>R类</strong>：仅出现在<code>F</code>中函数依赖<strong>右部</strong>的属性。</li><li><strong>N类</strong>：在<code>F</code>中函数依赖左右两边均<strong>未出现</strong>的属性。</li><li><strong>LR类</strong>：在<code>F</code>中函数依赖左右两边均<strong>出现</strong>的属性。</li></ul></li><li>令 <code>X_set = L类 ∪ N类</code>， <code>Y_set = LR类</code>。</li><li>计算<code>X_set+</code>：<ul><li>如果<code>X_set+ = R</code>，则<code>X_set</code>为<code>R</code>的唯一候选键。转到步骤5。</li><li>否则，转到步骤4。</li></ul></li><li>在<code>Y_set</code>中取一个属性<code>A</code>，计算<code>(X_set ∪ {A})+</code>。若它包含了<code>R</code>的所有属性，则转步骤4.1；否则，调换属性重复此过程，直到试完<code>Y_set</code>中的所有单个属性。<ul><li>4.1 如果已找出所有的候选键，则转步骤5。</li><li>否则，在<code>Y_set</code>中依次取两个、三个……属性，求其属性闭包，直至其闭包包含<code>R</code>的所有属性。注意排除已找到的候选键的超集。</li></ul></li><li>停止，输出结果。</li></ol></li></ul><h3 id="计算候选键示例">计算候选键示例</h3><ul><li><strong>例1</strong>：<ul><li><code>R(X, Y, Z, W)</code>， <code>F = {X → Z, Z → X, Y → XZ, W → XZ}</code></li><li>L类：<code>Y, W</code></li><li>R类：无</li><li>N类：无</li><li>LR类：<code>X, Z</code></li><li><code>X_set = {Y, W}</code>，计算<code>(YW)+ = R</code>，所以<code>YW</code>是候选键（也是唯一的）。</li></ul></li><li><strong>例2</strong>：<ul><li><code>R(B, D, I, O, Q, S)</code>， <code>F = {B → Q, I → S, IS → Q, S → D}</code></li><li>L类：<code>B, I</code></li><li>R类：<code>D, Q</code></li><li>N类：<code>O</code></li><li>LR类：<code>S</code></li><li><code>X_set = {B, I, O}</code>，计算<code>(BIO)+ = R</code>，所以<code>BIO</code>是一个候选键。</li></ul></li><li><strong>例3</strong>：<ul><li><code>R(A, B, C, D, E)</code>， <code>F = {AB → CE, E → AB, C → D}</code></li><li>步骤1：<code>X_set = ∅</code>（L类：无；N类：无），<code>Y_set = {A, B, C, E}</code>（LR类），R类：<code>D</code>。</li><li>步骤2：<code>X_set+ = ∅+ = ∅</code>，不为<code>R</code>。</li><li>步骤3：从<code>Y_set</code>中取单个属性：<ul><li><code>(A)+</code>，<code>(B)+</code>，<code>(C)+</code>都不等于<code>R</code>。</li><li><code>(E)+ = {E, A, B, C, D} = R</code>，所以<code>E</code>是一个候选键。</li></ul></li><li>继续寻找其他候选键（不包括E）：<ul><li>取两个属性（不包括E）：<code>AB</code>。<code>(AB)+ = R</code>，所以<code>AB</code>是一个候选键。</li><li>检查其他两个属性组合（如<code>BC</code>，<code>(BC)+</code>不含<code>A</code>或<code>E</code>，不等于<code>R</code>）。</li><li>取三个属性（不包括E，且不包含AB）：无法构成新的候选键。</li></ul></li><li>所以候选键是：<code>E</code>， <code>AB</code>。</li></ul></li><li><strong>例4</strong>：<ul><li><code>R(A, B, C, D, E)</code>， <code>F = {A → BC, CD → E, B → D, E → AB}</code></li><li>出现在左边的属性：<code>{A, C, D, B, E}</code>，出现在右边的属性：<code>{A, C, D, B, E}</code>。</li><li>L类：<code>{}</code>， R类：<code>{}</code>， LR类：<code>{A, C, D, B, E}</code>， N类：无。</li><li>计算候选键：<ul><li>测试<code>(A)+ = {A, B, C, D, E} = R</code>，所以<code>A</code>是候选键。</li><li>测试<code>(E)+ = {E, A, B, C, D} = R</code>，所以<code>E</code>是候选键。</li><li>测试<code>(C)+</code>，<code>(D)+</code>，<code>(B)+</code>都不等于<code>R</code>。</li><li>测试<code>(CD)+ = {C, D, E, A, B} = R</code>，所以<code>CD</code>是候选键。</li><li>测试<code>(BD)+</code>等不等于<code>R</code>。</li></ul></li><li>最终找到4个候选键：<code>A</code>， <code>E</code>， <code>CD</code>，还有？需要检查所有可能组合，例如<code>BC</code>？根据闭包计算，<code>(BC)+</code>可能等于<code>R</code>？<code>B → D</code>，<code>BC → D</code>，<code>CD → E</code>，<code>BC → CD</code>？实际上<code>(BC)+</code>可能包含<code>BCD</code>，然后<code>CD → E</code>，得到<code>BCDE</code>，然后<code>E → AB</code>，得到<code>ABCDE</code>，所以<code>BC</code>也是候选键？需要仔细计算。题目给出答案是4个，可能为<code>A, E, CD, BC</code>。</li></ul></li></ul><hr><h2 id="附录7-2-习题类型">附录7-2 习题类型</h2><ol><li>给定关系表<code>r(R)</code>和若干函数依赖<code>α → β</code>，判断<code>r</code>是否满足<code>α → β</code>。</li><li>根据Armstrong公理系统，判断关于函数依赖的一些公式是否成立（例如，如果<code>A → B, B → C</code>，则<code>A → C</code>）。</li><li>根据文字描述，抽象出函数依赖关系。</li><li><strong>设计SQL语句，判断函数依赖和键</strong>。</li><li>利用算法，求候选键。</li><li>计算属性闭包<code>α+</code>。</li><li>计算函数依赖集<code>F</code>的最小正则集<code>Fc</code>。</li><li>给定关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，判断<code>R</code>属于第几范式，为什么？（只考虑1NF, 2NF, 3NF, BCNF）</li><li>判断一个模式分解是否为无损连接（使用定理）、函数依赖保持（使用定义或算法）。</li><li>给定非3NF的关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，将<code>R</code>分解为第三范式。</li><li>给定非BCNF的关系模式<code>R</code>和定义在<code>R</code>上的函数依赖集<code>F</code>，将<code>R</code>分解为BCNF范式。</li></ol><hr><h2 id="本章结构总结">本章结构总结</h2><ul><li><strong>I. 良好关系设计的特征 (7.1)</strong>：为什么需要规范化？良好模式？（模式修改中的问题）。</li><li><strong>II. 使用函数依赖进行分解 (7.2)</strong>：分解、无损分解、规范化原则、键和函数依赖、无损分解和函数依赖。</li><li><strong>III. 范式 (7.3)</strong>：良好模式的标准。定义：BCNF、3NF、2NF、依赖保持、属性与关系。</li><li><strong>IV. 函数依赖理论 (7.4)</strong>：闭包、逻辑蕴含、属性集闭包、正则覆盖、无损连接分解、依赖保持。</li><li><strong>V. 使用函数依赖的分解算法 (7.5)</strong>：BCNF和3NF的分解算法。</li><li><strong>VI. [略] 使用多值依赖的分解 (7.6)</strong>：更高范式（不基于FD）。</li><li><strong>VII. [略] 数据库设计过程 (7.9)</strong></li><li><strong>附录7-1</strong> 求解候选键算法</li><li><strong>附录7-2</strong> 示例与练习</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§4 Intermediate-SQL 解读</title>
      <link href="/2025/12/24/DB_Intermediate%20SQL/"/>
      <url>/2025/12/24/DB_Intermediate%20SQL/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="数据库关系模式图示">数据库关系模式图示</h3><p><strong>takes</strong> (学生选课)</p><ul><li>ID</li><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li><li>grade</li></ul><p><strong>section</strong> (课程开设)</p><ul><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li><li>building</li><li>room_no</li><li>time_slot_id</li></ul><p><strong>classroom</strong> (教室)</p><ul><li>building</li><li>room_no</li><li>capacity</li></ul><p><strong>time_slot</strong> (时间槽)</p><ul><li>time_slot_id</li><li>day</li><li>start_time</li><li>end_time</li></ul><p><strong>teaches</strong> (教师授课)</p><ul><li>ID</li><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li></ul><p><strong>course</strong> (课程)</p><ul><li>course_id</li><li>title</li><li>dept_name</li><li>credits</li></ul><p><strong>prereq</strong> (先修课程)</p><ul><li>course_id</li><li>prereq_id</li></ul><p><strong>student</strong> (学生)</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>tot_cred</li></ul><p><strong>department</strong> (系)</p><ul><li>dept_name</li><li>building</li><li>budget</li></ul><p><strong>advisor</strong> (导师)</p><ul><li>s_id</li><li>i_id</li></ul><p><strong>instructor</strong> (教师)</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>salary</li></ul><hr><h2 id="4-1-连接表达式">4.1 连接表达式</h2><ul><li><strong>定义：</strong> 连接操作接受两个关系，并返回结果作为另一个关系。</li><li><strong>定义：</strong> 连接操作是一种笛卡尔积，要求两个关系中的元组相匹配。</li><li>连接结果中的属性来源于：笛卡尔积 ✕ + 选择 ✔</li><li><strong>定义：连接条件</strong> – 定义两个关系中的哪些元组相匹配，以及结果中存在哪些属性。</li><li><strong>定义：连接类型</strong> – 定义如何处理每个关系中不与另一个关系中任何元组匹配的元组。</li></ul><table><thead><tr><th style="text-align:left">连接类型</th><th style="text-align:left">连接条件</th></tr></thead><tbody><tr><td style="text-align:left">内连接</td><td style="text-align:left">natural</td></tr><tr><td style="text-align:left">左外连接</td><td style="text-align:left">on &lt;谓词&gt;</td></tr><tr><td style="text-align:left">右外连接</td><td style="text-align:left">using ((A_1, A_2, \ldots, A_n))</td></tr><tr><td style="text-align:left">全外连接</td><td style="text-align:left"></td></tr></tbody></table><h3 id="1-自然连接操作">(1) 自然连接操作</h3><p>考虑两个关系：</p><ul><li><p><strong>course</strong> (课程表)</p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td></tr></tbody></table></li><li><p><strong>prereq</strong> (先修课表)</p><table><thead><tr><th>course_id</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>CS-101</td></tr></tbody></table></li><li><p><strong>查询1：</strong> <code>select * from course natural join prereq</code></p></li><li><p><strong>查询2：</strong> <code>select * from course join prereq on course.course_id = prereq.course_id</code></p></li></ul><p><strong>course natural join prereq on course_id</strong> 的结果：</p><ul><li><em>CS-315的课程信息缺失</em>（因为prereq中没有CS-315）</li><li><em>CS-437的先修课信息缺失</em>（因为course中没有CS-437）</li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr></tbody></table><h3 id="2-外连接">(2) 外连接</h3><ul><li><strong>定义：</strong> <strong>连接</strong>操作的扩展，用于避免信息丢失。</li><li>计算连接，然后将一个关系中不与另一个关系中任何元组匹配的元组添加到<strong>连接</strong>结果中。</li><li><strong>使用空值（null）。</strong></li></ul><h4 id="1-左外连接">1. 左外连接</h4><ul><li><code>course natural left outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr></tbody></table><ul><li><code>select * from course natural left outer join prereq</code></li></ul><h4 id="2-右外连接">2. 右外连接</h4><ul><li><code>course natural right outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table><ul><li><code>select * from course natural right outer join prereq</code></li></ul><h4 id="3-全外连接">3. 全外连接</h4><ul><li><code>select * from course natural full outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table><h3 id="连接关系-–-示例">连接关系 – 示例</h3><ul><li><p><strong>内连接与自然连接的区别</strong></p><ul><li><p><code>course inner join prereq on course.course_id = prereq.course_id</code></p><table><thead><tr><th>course.course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th><th>prereq.course_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td><td>BIO-301</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td><td>CS-190</td></tr></tbody></table></li><li><p><code>course left outer join prereq on course.course_id = prereq.course_id</code></p><table><thead><tr><th>course.course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th><th>prereq.course_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td><td>BIO-301</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td><td>CS-190</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td><td>null</td></tr></tbody></table></li></ul></li><li><p><code>course natural right outer join prereq</code></p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table></li><li><p><code>course full outer join prereq using (course_id)</code></p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table></li></ul><hr><h2 id="4-2-视图">4.2 视图</h2><ul><li>并非所有用户都希望看到整个逻辑模型。<ul><li>例如，某人需要知道教师的姓名和所在系，但不需要知道其工资。</li><li>可以查看一个关系：<code>select ID, name, dept_name from instructor</code></li></ul></li><li><strong>定义：</strong> 任何<strong>不属于</strong> <strong>概念</strong>模型，但作为虚拟关系对用户<strong>可见</strong>的关系。</li><li>视图对某些用户隐藏了某些数据。</li></ul><h3 id="视图定义">视图定义</h3><ul><li><strong>注意：</strong> 视图 = 对一个或多个关系的投影。</li><li>视图作为虚拟表存在。</li><li><strong>注意：</strong> 视图被称为虚拟关系/表。<ul><li>只有视图的定义存储在数据库系统中，视图的元组存储在基础关系中。</li><li>视图的求值被归结为定义该视图的关系代数表达式的求值。</li></ul></li><li><strong>注意：</strong> <em>with</em>子句和<em>create view</em>子句的区别。<ul><li>with子句创建一个临时表来存储查询结果，创建的临时表在SQL执行结束后被取消。</li></ul></li><li><strong>定义：物化视图</strong><ul><li>视图的定义和数据都存储在数据库系统中。</li></ul></li></ul><h3 id="视图定义语句">视图定义语句</h3><ul><li><strong>定义：</strong> 使用 <strong>create view</strong> 语句定义视图。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> V <span class="keyword">as</span> <span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>其中 <code>&lt;查询表达式&gt;</code> 是SQL表达式。视图名称用 <code>V</code> 表示。</li><li>视图名称可用于引用该虚拟表。</li><li>视图定义与创建新关系不同。</li><li>视图定义导致保存一个表达式。</li></ul><h3 id="视图示例">视图示例</h3><ul><li><p><strong>不包含工资的教师视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> ID, name, dept_name</span><br><span class="line">  <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ul><li>查找<em>Biology</em>系的所有教师：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> faculty</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>部门工资总额视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> departments_total_salary (dept_name, total_salary) <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line">  <span class="keyword">from</span> instructor</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用其他视图定义的视图">使用其他视图定义的视图</h3><ol><li>创建 <code>physics_fall_2019</code> 视图：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2019 <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course.course_id, sec_id, building, room_number</span><br><span class="line">  <span class="keyword">from</span> course, section</span><br><span class="line">  <span class="keyword">where</span> course.course_id <span class="operator">=</span> section.course_id</span><br><span class="line">    <span class="keyword">and</span> course.dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> section.semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> section.year <span class="operator">=</span> <span class="string">&#x27;2019&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>基于 <code>physics_fall_2019</code> 创建 <code>physics_fall_2019_watson</code> 视图：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2019_watson <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course_id, room_number</span><br><span class="line">  <span class="keyword">from</span> physics_fall_2019</span><br><span class="line">  <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>注意：</strong> 一个视图可以用于定义另一个视图的表达式。<ul><li><strong>定义：</strong> 如果视图关系 ( v_2 ) 用于定义视图关系 ( v_1 ) 的表达式中，则称 ( v_1 ) <strong>直接依赖于</strong> ( v_2 )。</li><li><strong>定义：</strong> 如果 ( v_1 ) 直接依赖于 ( v_2 )，或者存在从 ( v_1 ) 到 ( v_2 ) 的依赖路径，则称视图关系 ( v_1 ) <strong>依赖于</strong> 视图关系 ( v_2 )。</li><li><strong>定义：</strong> 如果视图关系 ( v ) 依赖于自身，则称其为<strong>递归的</strong>。</li></ul></li></ul><h3 id="视图展开">视图展开</h3><p>展开查询或另一个视图中对视图的使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2009_watson <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course_id, room_number</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> course.course_id, building, room_number</span><br><span class="line">        <span class="keyword">from</span> course, section</span><br><span class="line">        <span class="keyword">where</span> course.course_id <span class="operator">=</span> section.course_id</span><br><span class="line">          <span class="keyword">and</span> course.dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> section.semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> section.year <span class="operator">=</span> <span class="string">&#x27;2009&#x27;</span>)</span><br><span class="line">  <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="视图的更新">视图的更新</h3><p>向 <code>faculty</code> 视图中插入新元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> faculty <span class="keyword">values</span> (<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此插入操作必须表示为向 <code>instructor</code> 关系中插入元组：<br><code>('30765', 'Green', 'Music', null)</code>。</p><hr><h2 id="4-3-事务">4.3 事务</h2><ul><li><strong>定义：</strong> <strong>事务</strong>由一系列查询和/或更新语句组成，它是一个工作<strong>单元</strong>。</li><li><strong>注意：</strong> ACID属性<ul><li>原子性、一致性、隔离性、持久性。</li><li>原子事务：要么完全执行，要么完全回滚，就像从未发生过一样。</li><li>与并发事务<strong>隔离</strong>。</li></ul></li><li><strong>注意：</strong> 当事务语句执行时，事务<strong>隐式</strong>开始。事务以以下语句结束：<ul><li><strong>Commit work.</strong> 更新永久生效。</li><li><strong>Rollback work.</strong> 所有已执行的更新被撤销。</li></ul></li></ul><h3 id="事务示例：银行账户转账">事务示例：银行账户转账</h3><ul><li>初始状态：A=1000，B=2000，A+B=3000</li><li>转账操作：A = A - 50 = 950；B = B + 50 = 2050；A+B = 3000</li></ul><h3 id="T-SQL-事务示例">T-SQL 事务示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@transfer_name</span> <span class="type">varchar</span>(<span class="number">10</span>)    <span class="comment">/* 事务变量定义 */</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@transfer_name</span> <span class="operator">=</span> <span class="string">&#x27;t-transfer-from-A-to-B&#x27;</span>    <span class="comment">/* 事务命名 */</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION <span class="variable">@transfer_name</span>    <span class="comment">/* 事务开始 */</span></span><br><span class="line">USE ACCOUNT    <span class="comment">/* 打开数据库 ACCOUNT */</span></span><br><span class="line">GO    <span class="comment">/* 将上述批 SQL 语句提交 SQL Server */</span></span><br><span class="line"><span class="keyword">UPDATE</span> A    <span class="comment">/* 修改 A 帐户 */</span></span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line"><span class="keyword">UPDATE</span> B    <span class="comment">/* 修改 B 帐户 */</span></span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line">GO</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION <span class="variable">@transfer_name</span>    <span class="comment">/* 事务提交 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-4-完整性约束">4.4 完整性约束</h2><ul><li><strong>定义：</strong> 完整性约束防止数据库遭受意外破坏，确保对数据库的授权更改不会导致数据一致性的丢失。<ul><li>教师姓名不能为空。</li><li>任意两个教师不能有相同的教师ID。</li><li><code>course</code> 关系中的每个系名必须在 <code>department</code> 关系中有匹配的系名。</li></ul></li></ul><h3 id="完整性约束分类">完整性约束分类</h3><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">属性级</th><th style="text-align:left">元组级</th><th style="text-align:left">关系级</th></tr></thead><tbody><tr><td style="text-align:left">静态</td><td style="text-align:left">数据类型、数据格式、域约束、空值</td><td style="text-align:left">属性值间的约束，例如：映射基数约束</td><td style="text-align:left">实体完整性、参照完整性、函数依赖</td></tr><tr><td style="text-align:left">动态</td><td style="text-align:left">属性值或属性定义更新的约束</td><td style="text-align:left">属性值间的约束（例如：新旧值关系）</td><td style="text-align:left">事务约束：原子性、一致性、隔离性、持久性</td></tr></tbody></table><h3 id="完整性约束示例">完整性约束示例</h3><ul><li><strong>例1：</strong> <code>Employee</code> 表中经理的工资不应低于1000美元。</li><li><strong>例2：</strong> 表 T (x, y, z)，其中 z = x + y，z是从x和y派生的属性。</li><li><strong>例3：</strong> <code>student</code> 表中的学号不应为空。</li><li><strong>例4：</strong> 学生的年龄只能增加。</li><li><strong>例5：</strong> 当修改<code>employee</code>元组时，新工资需满足 <code>new.sal &gt; old.sal + 0.5 * age</code>。</li><li><strong>例6：</strong> 统计约束。在表中，经理的工资应该是工人工资的四倍以上。</li></ul><h3 id="单关系上的约束">单关系上的约束</h3><ul><li>使用 <strong>create table</strong> 命令定义关系：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (A1 D1, A2 D2, ..., An Dn,</span><br><span class="line">                (integrity<span class="operator">-</span>constraint1),</span><br><span class="line">                ...,</span><br><span class="line">                (integrity<span class="operator">-</span>constraintk))</span><br></pre></td></tr></table></figure><ul><li><code>r</code> 是关系名。</li><li>每个 <code>Ai</code> 是关系 <code>r</code> 模式中的一个属性名。</li><li><code>Di</code> 是属性 <code>Ai</code> 域中值的数据类型。</li></ul></li><li><strong>注意：</strong> 完整性约束包括：<ul><li>primary key</li><li>not null</li><li>unique</li><li>check (P)，其中 <code>P</code> 是一个谓词。</li></ul></li></ul><h4 id="Not-Null-约束">Not Null 约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">not null</span></span><br></pre></td></tr></table></figure><h4 id="Unique-约束">Unique 约束</h4><ul><li><strong>定义：</strong> Unique 约束形式如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unique</span> (A1, A2, ..., Am)</span><br></pre></td></tr></table></figure><ul><li>属性 <code>A1, A2, ..., Am</code> 构成一个候选码。</li><li>允许候选码为空（与主键不同）。</li><li>示例：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> customer (</span><br><span class="line">  customer_id <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">  customer_name <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">  customer_city <span class="type">char</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (customer_id),</span><br><span class="line">  <span class="keyword">unique</span> (customer_name)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Check-子句">Check 子句</h4><ul><li>应用于关系声明和域声明。</li><li><code>check (P)</code>，其中 <code>P</code> 是一个谓词。</li><li>示例：确保 <code>semester</code> 属性值在 {‘Fall’, ‘Winter’, ‘Spring’, ‘Summer’} 中。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> section (</span><br><span class="line">  course_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">  sec_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">  semester <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line">  <span class="keyword">year</span> <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">  room_number <span class="type">varchar</span>(<span class="number">7</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">  <span class="keyword">check</span> (semester <span class="keyword">in</span> (<span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>, <span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="参照完整性">参照完整性</h3><ul><li><strong>参照完整性</strong><ul><li><strong>确保</strong>在一个关系的给定属性（外键）上出现的值，也出现在另一个关系的对应属性（主键）上。</li><li>如果 <code>Biology</code> 是出现在 <code>instructor</code> 关系元组中的一个系名，那么 <code>department</code> 关系中必须存在 <code>Biology</code> 的元组。</li></ul></li></ul><h4 id="参照完整性依赖">参照完整性依赖</h4><ul><li><strong>定义：</strong> 设 ( r_1(R_1) ) 和 ( r_2(R_2) ) 是分别具有主键 ( K_1 ) 和 ( K_2 ) 的关系。<ul><li>例如：<br>( r_1: \text{department(dept_name, building, budget)} )<br>( r_2: \text{course(course_id, title, dept_name, credits)} )</li></ul></li><li>( R_2 ) 的子集 ( \alpha )（例如 dept_name）是一个<strong>外键</strong>（来自 ( r_2 )，<strong>course</strong>），引用关系 ( r_1 )（<strong>department</strong>）中的 ( K_1 )，如果对于 ( r_2 ) 中的每个元组 ( t_2 )，在 ( r_1 ) 中必须存在一个元组 ( t_1 )，使得 ( t_1[K_1] = t_2[\alpha] )。</li><li><strong>注意：</strong> ( \alpha = K_1 \subseteq R_2 )</li><li><strong>定义：</strong> 参照完整性约束被称为<strong>子集依赖</strong>，因为它可以写成：<br>( \prod_{\alpha}(r_2) \subseteq \prod_{K_1}(r_1) )<ul><li>例如：( \prod_{dept_name} (course) \subseteq \prod_{dept_name} (department) )</li></ul></li><li>表 ( r_2 ) 的外键 ( \alpha ) 引用被引用表 ( r_1 ) 的主键属性 ( K_1 )。</li><li><strong>注意：</strong> 良好的数据库设计应确保任何关系模式 ( R_2 ) 只能通过其外键引用其他关系模式 ( R_1 )。</li></ul><h3 id="参照完整性声明">参照完整性声明</h3><ul><li>主键、候选键和外键可以在 <strong>create table</strong> 语句中指定：<ul><li><strong>primary key</strong> 子句列出构成主键的属性。</li><li><strong>unique</strong> 子句列出构成候选键的属性。</li><li><strong>foreign key</strong> 子句列出构成外键的属性以及外键引用的关系名。</li><li>外键引用被引用表的主键属性。</li></ul></li></ul><h3 id="参照完整性中的级联操作">参照完整性中的级联操作</h3><ul><li><strong>简略声明：</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">  course_id <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">primary key</span>,</span><br><span class="line">  title <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">references</span> department</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong>详细声明（支持级联）：</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">  ...</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>级联的替代操作：set null, set default。</li><li>对被引用表 <code>department</code> 的删除/更新操作将导致对引用表 <code>course</code> 的级联删除/更新。</li></ul><h3 id="事务期间的完整性约束违反">事务期间的完整性约束违反</h3><ul><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> person (</span><br><span class="line">  ID <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  name <span class="type">char</span>(<span class="number">40</span>),</span><br><span class="line">  mother <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  father <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (father) <span class="keyword">references</span> person(ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (mother) <span class="keyword">references</span> person(ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong>如何在具有主键-外键关联的两个表上修改数据？</strong></li><li><strong>如何插入元组而不引起约束违反？</strong><ul><li>在插入 <code>person</code> 之前先插入该人的父亲和母亲。</li><li>或者，先将 <code>father</code> 和 <code>mother</code> 设置为 <code>null</code>，在插入所有人之后再更新（如果 <code>father</code> 和 <code>mother</code> 属性声明为 <code>not null</code> 则不可行）。</li></ul></li></ul><hr><h2 id="4-5-数据类型和模式">4.5 数据类型和模式</h2><h3 id="内置数据类型">内置数据类型</h3><ul><li><strong>date：</strong> 日期，包含（4位）年、月、日。<ul><li>例如：<code>date '2017-7-27'</code></li></ul></li><li><strong>time：</strong> 一天中的时间，时、分、秒。<ul><li>例如：<code>time '09:00:30.75'</code></li></ul></li><li><strong>timestamp：</strong> 日期 + 一天中的时间。<ul><li>例如：<code>timestamp '2017-7-27 09:00:30.75'</code></li></ul></li><li><strong>interval：</strong> 时间段。<ul><li>如果 x 和 y 是 date 类型，那么 <code>x - y</code> 是一个 interval，其值是从日期 x 到日期 y 的天数。</li><li>例如：<code>interval '1 day' = '2017-7-28' – '2017-7-27'</code></li></ul></li></ul><h3 id="类型转换">类型转换</h3><ul><li><strong><code>cast(e as t)</code></strong><ul><li>将字符串 <code>e</code> 转换为类型 <code>t</code>。</li><li>例如：<code>cast('2017-07-20' as date)</code></li><li>例如：<code>cast('09:00:30.75' as time)</code></li><li><pre><code class="language-sql">select cast(ID as numeric(5)) as inst_idfrom instructororder by inst_id<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*   从日期或时间值中提取部分。</span><br><span class="line">*   对于日期或时间值 `d`，可以提取其各个字段。</span><br><span class="line">    *   例如：`extract(year from date &#x27;2017-07-20&#x27;) = 2017`</span><br><span class="line">    *   例如：`extract(timezone_hour from timestamp &#x27;2017-7-27 09:00:30.75&#x27;) = 09`</span><br><span class="line"></span><br><span class="line">### CAST/CONVERT 用于数据类型转换示例</span><br><span class="line"></span><br><span class="line">#### A. 同时使用 CAST 和 CONVERT</span><br><span class="line">每个示例都检索列表价格第一位是3的产品名称，并将 ListPrice 转换为 int。</span><br><span class="line">```sql</span><br><span class="line">-- 使用 CAST</span><br><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line">SELECT SUBSTRING(Name, 1, 30) AS ProductName, ListPrice</span><br><span class="line">FROM Production.Product</span><br><span class="line">WHERE CAST(ListPrice AS int) LIKE &#x27;3%&#x27;;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 使用 CONVERT</span><br><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line">SELECT SUBSTRING(Name, 1, 30) AS ProductName, ListPrice</span><br><span class="line">FROM Production.Product</span><br><span class="line">WHERE CONVERT(int, ListPrice) LIKE &#x27;3%&#x27;;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="B-使用包含算术运算符的-CAST">B. 使用包含算术运算符的 CAST</h4><p>将销售额除以佣金百分比，结果四舍五入到最接近的整数后转换为 int。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(ROUND(SalesYTD<span class="operator">/</span>CommissionPCT, <span class="number">0</span>) <span class="keyword">AS</span> <span class="type">int</span>) <span class="keyword">AS</span> <span class="string">&#x27;Computed&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Sales.SalesPerson</span><br><span class="line"><span class="keyword">WHERE</span> CommissionPCT <span class="operator">!=</span> <span class="number">0</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h4 id="C-使用-CAST-进行连接">C. 使用 CAST 进行连接</h4><p>使用 CAST 连接非字符非二进制表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;The list price is &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(ListPrice <span class="keyword">AS</span> <span class="type">varchar</span>(<span class="number">12</span>)) <span class="keyword">AS</span> ListPrice</span><br><span class="line"><span class="keyword">FROM</span> Production.Product</span><br><span class="line"><span class="keyword">WHERE</span> ListPrice <span class="keyword">BETWEEN</span> <span class="number">350.00</span> <span class="keyword">AND</span> <span class="number">400.00</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h4 id="D-使用-CAST-生成可读性更高的文本">D. 使用 CAST 生成可读性更高的文本</h4><p>使用 CAST 将 Name 列转换为 char(10) 列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">CAST</span>(p.Name <span class="keyword">AS</span> <span class="type">char</span>(<span class="number">10</span>)) <span class="keyword">AS</span> Name, s.UnitPrice</span><br><span class="line"><span class="keyword">FROM</span> Sales.SalesOrderDetail s <span class="keyword">JOIN</span> Production.Product p <span class="keyword">on</span> s.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;Long-Sleeve Logo Jersey, M&#x27;</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="默认值">默认值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">primary key</span> (ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>插入数据时，未指定 <code>tot_cred</code> 则使用默认值0：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student(ID, name, dept_name) <span class="keyword">values</span> (<span class="string">&#x27;12789&#x27;</span>, <span class="string">&#x27;Newman&#x27;</span>, <span class="string">&#x27;Comp.Sci&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="用户定义类型">用户定义类型</h3><ul><li>使用 <code>create type</code> 子句定义用户定义类型。<ul><li>示例：<code>create type Dollars as numeric(12,2)</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> department (</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">  budget Dollars</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>使用 <code>cast</code> 将一个类型的值转换为另一个域。<ul><li>例如，<code>cast(department.budget to numeric(12,2))</code>，然后表达式 <code>(department.budget + 20)</code> 可以被求值。</li></ul></li></ul><h3 id="用户定义域">用户定义域</h3><ul><li><code>create domain</code> 构造创建用户定义的域类型。<ul><li><code>create domain person_name char(20) not null</code></li></ul></li><li>类型和域相似。域可以指定约束，例如 <code>not null</code>。</li><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain degree_level <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">constraint</span> degree_level_test</span><br><span class="line">  <span class="keyword">check</span> (<span class="keyword">value</span> <span class="keyword">in</span> (<span class="string">&#x27;Bachelors&#x27;</span>, <span class="string">&#x27;Masters&#x27;</span>, <span class="string">&#x27;Doctorate&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂检查条件和断言">复杂检查条件和断言</h3><ul><li><p>一些构造如 <em>check</em> 和 <em>assertion</em> 被定义为用于指定复杂的完整性约束。</p><ul><li><strong>但是，目前大多数数据库系统不支持它们。</strong></li></ul></li><li><p><strong>复杂 Check 条件示例：</strong></p><ul><li>对于关系 <code>section</code>，每个元组中的 <code>time_slot_id</code> 实际上应该是 <code>time_slot</code> 关系中的一个时间槽标识符。此约束可以定义为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (time_slot_id <span class="keyword">in</span> (<span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot))</span><br></pre></td></tr></table></figure><ul><li>在 <code>create table</code> 中使用 <code>check</code>：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department,</span><br><span class="line">  <span class="keyword">check</span>(tot_cred <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>断言</strong></p><ul><li>断言是表示我们希望数据库始终满足的条件的谓词。<ul><li>例如：域约束、参照完整性约束。</li></ul></li><li>断言的形式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>断言名称<span class="operator">&gt;</span> <span class="keyword">check</span> <span class="operator">&lt;</span>谓词<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>同样不被大多数DBMS（如 SQL Server）支持。为什么？</strong><ul><li>当创建断言时，DBMS 测试其有效性。任何对数据库的修改只有在该断言不被违反时才被允许。</li><li>这种测试可能引入显著的开销，因此应非常谨慎地使用断言。</li></ul></li></ul></li><li><p><strong>断言示例：</strong></p><ul><li>对于 <code>student</code> 关系中的每个元组，<code>tot_cred</code> 属性的值必须等于该学生成功完成的课程的学分总和。</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion credits_earned_constraint <span class="keyword">check</span></span><br><span class="line">  (<span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> ID</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> tot_cred <span class="operator">&lt;&gt;</span></span><br><span class="line">      (<span class="keyword">select</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">       <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> course</span><br><span class="line">       <span class="keyword">where</span> student.ID <span class="operator">=</span> takes.ID</span><br><span class="line">         <span class="keyword">and</span> grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">         <span class="keyword">and</span> grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">      )</span><br><span class="line">  ))</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-6-SQL-中的索引定义">4.6 SQL 中的索引定义</h2><ul><li>许多查询只引用表中的一小部分记录。</li><li>读取每条记录以查找具有特定值的记录是<strong>低效的</strong>。</li><li>关系属性上的<strong>索引</strong>是一种数据结构，它允许数据库系统高效地查找关系中在该属性上具有指定值的那些元组，而无需扫描关系的所有元组。</li><li>使用 <strong>create index</strong> 命令创建索引：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>关系名<span class="operator">&gt;</span> (属性);</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引定义示例">索引定义示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">primary key</span> (ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index studentID_index <span class="keyword">on</span> student(ID);</span><br></pre></td></tr></table></figure><p>查询时可以利用索引高效定位记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> ID <span class="operator">=</span> <span class="string">&#x27;12345&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-7-授权">4.7 授权</h2><h3 id="对数据库部分的授权形式">对数据库部分的授权形式</h3><ul><li><strong>Read</strong> - 允许读取数据，但不允许修改。</li><li><strong>Insert</strong> - 允许插入新数据，但不允许修改现有数据。</li><li><strong>Update</strong> - 允许修改数据，但不允许删除。</li><li><strong>Delete</strong> - 允许删除数据。</li></ul><h3 id="对数据库模式修改的授权形式（第8章）">对数据库模式修改的授权形式（第8章）</h3><ul><li><strong>resources</strong> - 允许创建新关系。</li><li><strong>alteration</strong> - 允许在关系中添加或删除属性。</li><li><strong>drop</strong> - 允许删除关系。</li><li><strong>index</strong> - 允许创建和删除索引。</li></ul><h3 id="授权规范">授权规范</h3><ul><li>使用 <strong>grant</strong> 语句授予授权。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>关系名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;用户列表&gt;</code> 可以是：用户ID，或 <strong>public</strong>（允许所有有效用户获得授予的权限）。</li></ul></li><li>授予<strong>视图</strong>上的权限并不意味着授予对底层关系的任何权限。</li><li>权限的授予者必须已经拥有指定项目上的该权限（或者是数据库管理员）。</li></ul><h3 id="权限类型">权限类型</h3><ul><li><strong>select</strong>：允许读取关系，或使用视图进行查询的能力。<ul><li>示例：授予用户 ( U_1, U_2, U_3 ) 对 <code>instructor</code> 关系的 select 授权：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> instructor <span class="keyword">to</span> U1, U2, U3</span><br></pre></td></tr></table></figure></li><li><strong>insert</strong>：插入元组的能力。</li><li><strong>update</strong>：使用 SQL update 语句更新的能力。</li><li><strong>delete</strong>：删除元组的能力。</li><li><strong>all privileges</strong>：用作所有允许权限的简写形式。</li></ul><h3 id="撤销授权">撤销授权</h3><ul><li>使用 <strong>revoke</strong> 语句撤销授权。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>关系名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> branch <span class="keyword">from</span> U1, U2, U3</span><br></pre></td></tr></table></figure></li><li><code>&lt;权限列表&gt;</code> 可以是 <strong>all</strong>，以撤销撤销者可能持有的所有权限。</li><li>如果 <code>&lt;撤销列表&gt;</code> 包含 <strong>public</strong>，则所有用户都会失去该权限，除非他们被明确授予该权限。</li></ul><h3 id="角色">角色</h3><ul><li>创建角色：<code>create role instructor;</code></li><li>将角色授予用户：<code>grant instructor to Amit;</code></li><li>可以向角色授予权限：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> takes <span class="keyword">to</span> instructor;</span><br></pre></td></tr></table></figure></li><li>角色可以授予给用户，也可以授予给其他角色：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role teaching_assistant;</span><br><span class="line"><span class="keyword">grant</span> teaching_assistant <span class="keyword">to</span> instructor;</span><br><span class="line"><span class="comment">-- Instructor 继承 teaching_assistant 的所有权限</span></span><br></pre></td></tr></table></figure></li><li>角色链：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role dean;</span><br><span class="line"><span class="keyword">grant</span> instructor <span class="keyword">to</span> dean;</span><br><span class="line"><span class="keyword">grant</span> dean <span class="keyword">to</span> Satoshi;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图上的授权">视图上的授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> geo_instructor <span class="keyword">as</span></span><br><span class="line">  (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">from</span> instructor</span><br><span class="line">   <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Geology&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> geo_instructor <span class="keyword">to</span> geo_staff;</span><br></pre></td></tr></table></figure><ul><li>假设 <code>geo_staff</code> 成员执行：<code>select * from geo_instructor;</code></li><li>如果发生以下情况会怎样？<ul><li><code>geo_staff</code> 对 <code>instructor</code> 没有权限？</li><li>视图创建者对 <code>instructor</code> 没有某些权限？</li></ul></li></ul><h3 id="其他授权特性">其他授权特性</h3><ul><li><strong>references</strong> 权限用于创建外键。<ul><li><code>grant reference (dept_name) on department to Mariano;</code></li><li>为什么需要这个？</li></ul></li><li><strong>权限转移</strong><ul><li><code>grant select on department to Amit with grant option;</code></li></ul></li><li><strong>级联撤销</strong><ul><li><code>revoke select on department from Amit, Satoshi cascade;</code></li></ul></li><li><strong>限制撤销</strong><ul><li><code>revoke select on department from Amit, Satoshi restrict;</code></li></ul></li></ul><p><strong>等等。</strong> 更多细节请阅读第4.6节。</p><hr><h2 id="实验要求与讨论">实验要求与讨论</h2><h3 id="实验要求：外键关联与级联操作">实验要求：外键关联与级联操作</h3><ul><li><strong>平台：</strong> openGauss</li><li><strong>任务：</strong> 定义两张表间的无级联修改和有级联修改的外键关联。判断当增/删/改一张表中的主键、外键值时，DBMS 的反应。</li></ul><h3 id="数据库系统设计时，是否使用外键？">数据库系统设计时，是否使用外键？</h3><ul><li>外键反映了不同数据项间的逻辑关联和约束关系，是一种客观存在。<ul><li>例如：<code>department</code> 表和 <code>course</code> 表中的 <code>dept_name</code>。</li></ul></li><li>对外键的处理方式反映了对这种数据相互间关系的处理态度，需要根据实际情况而定，考虑数据完整性、处理效率等多种因素。<ul><li>并非简单的“需要外键”或“不设外键”。</li></ul></li></ul><h4 id="方式1：设置数据库表的外键">方式1：设置数据库表的外键</h4><ul><li><strong>优点</strong><ul><li>DBMS 自动维护数据间的关联、约束关系。</li></ul></li><li><strong>缺点</strong><ul><li>数据导入、增删改时，多个表间的相互关联保证了数据一致性和完整性，但影响到整体数据处理效率（额外的 DBMS 处理开销）。</li><li>例如：插入一条 <code>dept_name</code> 不存在的 <code>course</code> 元组，失败，并影响前面已经成功插入的数据——局部错误影响整体。</li></ul></li></ul><h4 id="方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性">方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性</h4><ul><li><strong>优点</strong><ul><li>1）避免局部错误影响整体进度；</li><li>2）业务逻辑层的数据一致性处理速度可以比较快，例如将数据提至内存中批量处理。</li></ul></li><li><strong>缺点</strong>：对应用层业务处理程序设计的额外要求。</li><li>上述两种方式用在对数据一致性完整性要求高的场景下，例如银行。</li></ul><h4 id="方式3：不设置外键，业务层应用逻辑也不处理数据间一致性">方式3：不设置外键，业务层应用逻辑也不处理数据间一致性</h4><ul><li>牺牲数据的正确性，换取数据处理的效率。</li><li>例如：大数据应用场景下，对数据精度、正确性要求不高。</li></ul><h3 id="LTE-网络数据库课程实验讨论">LTE 网络数据库课程实验讨论</h3><ul><li><code>tbMRData</code>、<code>tbATUData</code> 表中的主小区、邻小区 ID 对应于 <code>tbCell</code> 中的小区标识 <code>Sector_ID</code>。</li><li><strong>实际应用中，不建议</strong>在 <code>tbMRData</code>、<code>tbATUData</code> 与 <code>tbCell</code> 之间建立外键。否则，两表间由于强行的外键约束，可能带来低效的数据处理。<ul><li><strong>例1：</strong> 向 <code>tbMRData</code>、<code>tbATUData</code> 中大批量导入数据时，插入的某条测量报告数据中的某些主小区、邻小区没有出现在 <code>tbCell</code> 表中，导致本条以及前面各条已成功插入的测量报告均插入失败。</li><li><strong>例2：</strong> 当 <code>tbCell</code> 中某个小区修改名字时，在（数据量非常大，例如 T 级别，上亿条）<code>tbMRData</code>、<code>tbATUData</code> 表中以该小区作为主、邻小区的测量报告也必须随之修改。</li></ul></li><li><strong>现网环境中不一致的原因：</strong><ul><li><code>tbMRData</code>、<code>tbATUData</code> 中的测量报告的测量范围超出 <code>tbCell</code> 的范围，有些测量报告的主小区、邻小区没有出现在 <code>tbCell</code> 表中。</li><li><code>tbCell</code> 表中的小区数据有可能被修改，导致与 <code>tbMRData</code>、<code>tbATUData</code> 中的测量报告不一致。</li></ul></li></ul><h3 id="LTE-网络数据库实验要求">LTE 网络数据库实验要求</h3><ol><li>在建表、数据导入阶段，<strong>先不要建立</strong> <code>tbMRData</code>、<code>tbATUData</code> 与 <code>tbCell</code> 间的外键。</li><li>数据导入完成后，再建立表间外键关联，观察：<ul><li>是否能建立？</li><li>如果建立，<code>tbCell</code> 中主键值的变化对 <code>tbMRData</code>、<code>tbATUData</code> 的影响，或反之。</li></ul></li><li>在已建立的表中增加外键的方法，参见具体 DBMS 平台用户手册。</li></ol><hr><h2 id="附录-4-1-T-SQL-中的-CREATE-TABLE">附录 4-1: T-SQL 中的 CREATE TABLE</h2><p>（此处详细语法结构图展示了 T-SQL 中 CREATE TABLE 语句的复杂选项，包括列定义、约束、物理存储选项（分区、文件组）、索引类型（聚集/非聚集）等，强调了物理设计层面的考量。具体语法细节可参考 SQL Server 文档。）</p><hr><h2 id="本章内容总结（大纲）">本章内容总结（大纲）</h2><p><strong>I. SQL 数据类型和模式 (4.5)</strong></p><ul><li>日期和时间类型</li><li>类型转换和格式化函数</li><li>默认值</li><li>大对象类型，用户定义类型</li><li>create table 扩展，生成唯一键值</li><li>模式、目录、环境</li></ul><p><strong>II. 连接表达式 (4.1) (用于多表访问)</strong></p><ul><li>自然连接</li><li>连接条件</li><li>外连接</li><li>连接类型和条件</li></ul><p><strong>III. 视图 (4.2)</strong></p><ul><li>定义、查询、更新</li><li>物化视图</li></ul><p><strong>IV. 事务 (4.3)</strong></p><ul><li>定义、示例</li></ul><p><strong>V. 完整性约束 (4.4)</strong></p><ul><li>not null, unique, check</li><li>参照完整性</li><li>复杂检查约束和断言</li><li>为约束命名，事务期间的约束违反</li></ul><p><strong>VI. SQL 中的索引定义 (4.6)</strong></p><p><strong>VII. 授权 (4.7)</strong></p><ul><li>grant/revoke, 角色</li></ul><p><strong>实验：</strong> 完整性约束</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§5 Advanced-SQL课件详解</title>
      <link href="/2025/12/24/DB_AdvancedSQL/"/>
      <url>/2025/12/24/DB_AdvancedSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="章节标题与大纲">章节标题与大纲</h2><h3 id="第五章：高级SQL">第五章：高级SQL</h3><p><strong>授课时间</strong>：2025年10月<br><strong>授课单位</strong>：计算机学院</p><h3 id="本章大纲">本章大纲</h3><p>本章旨在深入探讨超越基础SQL操作的高级特性，重点涵盖以下三个核心领域：</p><ol><li><strong>从编程语言访问SQL</strong>：探讨如何在Java、C等通用编程语言中执行SQL语句，实现应用程序与数据库系统的交互。</li><li><strong>函数和存储过程</strong>：学习在数据库服务器端创建可重用的程序化逻辑单元，包括标量函数和存储过程。</li><li><strong>触发器</strong>：掌握基于事件-条件-动作模型的数据库自动化响应机制，用于维护数据完整性和执行业务规则。</li></ol><h2 id="从编程语言访问SQL（概述与架构）">从编程语言访问SQL（概述与架构）</h2><h3 id="5-1-从编程语言访问SQL">5.1 从编程语言访问SQL</h3><h4 id="5-1-0-数据库应用系统（DBAS）架构回顾">5.1.0 数据库应用系统（DBAS）架构回顾</h4><p>数据库应用系统是由<strong>用户</strong>、<strong>应用程序</strong>、**数据库管理系统（DBMS）<strong>和</strong>数据库（DB）<strong>共同构成的完整体系。应用程序作为用户与数据库之间的桥梁，需要通过特定的</strong>应用程序编程接口（API）**与数据库服务器进行交互。这一交互过程通常遵循以下步骤：</p><ol><li>建立与数据库服务器的连接。</li><li>通过连接向服务器发送SQL命令（查询或更新）。</li><li>对于查询操作，以一次一个元组的方式，将结果集提取到应用程序的变量中进行后续处理。</li></ol><h4 id="5-1-1-两种主要的访问范式">5.1.1 两种主要的访问范式</h4><p>从编程语言访问SQL主要有两种实现途径，它们在集成方式和执行时机上存在根本区别：</p><ol><li><p><strong>动态SQL</strong></p><ul><li><strong>定义</strong>：在通用编程语言中，程序在<strong>运行时</strong>动态地构建SQL查询字符串，并通过API函数调用（如JDBC、ODBC）将该字符串提交给数据库服务器执行，然后处理返回的结果。</li><li><strong>核心特征</strong>：<ul><li><strong>灵活性高</strong>：SQL语句可以根据程序逻辑和用户输入动态生成。</li><li><strong>显式控制</strong>：程序员需手动管理连接、语句执行、结果获取和资源释放的全生命周期。</li></ul></li><li><strong>主流技术标准</strong>：<ul><li><strong>JDBC</strong>：专为Java语言设计的数据库连接API标准。</li><li><strong>ODBC</strong>：一种开放的、与语言和数据库无关的调用级接口标准，广泛用于C、C++等语言。</li></ul></li></ul></li><li><p><strong>嵌入式SQL</strong></p><ul><li><strong>定义</strong>：将SQL语句直接<strong>编写</strong>在宿主语言（如C、COBOL）的源代码中。在编译程序之前，先由一个<strong>预处理器</strong>扫描源代码，将这些嵌入式SQL语句转换为对数据库运行时库的特定函数调用。随后，再由宿主语言的编译器进行编译。</li><li><strong>核心特征</strong>：<ul><li><strong>编译时确定</strong>：SQL语句在编译期是可见的，可进行早期语法检查和优化。</li><li><strong>编程模型更贴近SQL</strong>：使用游标（Cursor）机制处理多行结果集，语法上更接近直接的SQL交互。</li><li><strong>底层依赖动态SQL</strong>：最终生成的函数调用实质上利用了动态SQL的API（如ODBC）来完成数据库通信。</li></ul></li></ul></li></ol><h2 id="JDBC详解（基础与核心流程）">JDBC详解（基础与核心流程）</h2><h3 id="5-1-2-JDBC（Java-Database-Connectivity）">5.1.2 JDBC（Java Database Connectivity）</h3><h4 id="特性与用途">特性与用途</h4><p>JDBC是Java平台中用于执行SQL语句的一套标准API。它不仅支持数据的查询与更新，还提供了检索数据库<strong>元数据</strong>的能力，例如查询数据库中有哪些表、表中各列的名称和数据类型等。</p><p>JDBC建立了一套标准的通信模型：</p><ol><li>打开一个数据库连接。</li><li>创建一个<code>Statement</code>（语句）对象。</li><li>使用该<code>Statement</code>对象发送SQL查询并获取结果。</li><li>利用Java的异常处理机制来管理操作中可能出现的错误。</li></ol><h4 id="JDBC核心代码示例与逐步解析">JDBC核心代码示例与逐步解析</h4><p>以下是一个完整的JDBC方法示例，演示了连接数据库、执行插入和查询操作的全过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String userId, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// === 步骤 1：加载数据库驱动程序（JDBC 4.0+ 可省略）===</span></span><br><span class="line">        <span class="comment">// 此步骤告知Java运行时环境所要使用的JDBC驱动实现类。</span></span><br><span class="line">        <span class="comment">// 注意：自JDBC 4.0（Java 6）起，驱动可自动加载，此语句常可省略。</span></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 2：建立数据库连接 ===</span></span><br><span class="line">        <span class="comment">// 使用DriverManager的getConnection方法，传入数据库URL、用户名和密码。</span></span><br><span class="line">        <span class="comment">// URL格式因数据库厂商而异。本例连接一个Oracle数据库。</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, <span class="comment">// 数据库URL</span></span><br><span class="line">            userId, <span class="comment">// 用户名</span></span><br><span class="line">            passwd  <span class="comment">// 密码</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 3：创建语句对象 ===</span></span><br><span class="line">        <span class="comment">// 通过Connection对象创建一个Statement对象，用于执行静态SQL语句。</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4a：执行数据更新操作（INSERT, UPDATE, DELETE）===</span></span><br><span class="line">        <span class="comment">// 使用executeUpdate方法，它返回受影响的行数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.executeUpdate(</span><br><span class="line">                <span class="string">&quot;insert into instructor values(&#x27;77987&#x27;, &#x27;Kim&#x27;, &#x27;Physics&#x27;, 98000)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            <span class="comment">// 捕获并处理可能发生的SQL异常（如主键冲突、违反约束等）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4b：执行数据查询操作 ===</span></span><br><span class="line">        <span class="comment">// 使用executeQuery方法执行SELECT语句，返回一个ResultSet（结果集）对象。</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;select dept_name, avg(salary) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from instructor &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by dept_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 5：遍历并处理结果集 ===</span></span><br><span class="line">        <span class="comment">// ResultSet的next()方法将游标移动到下一行。首次调用移至第一行。</span></span><br><span class="line">        <span class="comment">// 当没有更多行时返回false。</span></span><br><span class="line">        <span class="keyword">while</span> (rset.next()) &#123;</span><br><span class="line">            <span class="comment">// 使用getString(列名)和getFloat(列索引)等方法获取当前行的列值。</span></span><br><span class="line">            <span class="comment">// 列索引从1开始。</span></span><br><span class="line">            System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>) + <span class="string">&quot; &quot;</span> + rset.getFloat(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 6：清理资源（至关重要！）===</span></span><br><span class="line">        <span class="comment">// 必须按顺序关闭ResultSet、Statement和Connection，以释放数据库和系统资源。</span></span><br><span class="line">        <span class="comment">// 实际开发中应使用try-with-resources语句确保资源被关闭。</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDBC Driver not found: &quot;</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        <span class="comment">// 捕获连接、语句创建等过程中更广泛的SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 捕获其他非SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Exception : &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键点解析">关键点解析</h4><ol><li><strong><code>Class.forName()</code></strong>：此语句显式加载特定的JDBC驱动类。这是JDBC 3.0及之前版本的规范做法。在JDBC 4.0及以上版本（Java 6+），只要驱动JAR包在类路径中，驱动管理器可以自动发现并加载驱动，因此这行代码常可省略。</li><li><strong><code>DriverManager.getConnection()</code></strong>：这是建立连接的工厂方法。数据库URL的格式是驱动特定的。<code>jdbc:oracle:thin:@db.yale.edu:1521:univdb</code> 表示使用Oracle的“thin”驱动，连接主机<code>db.yale.edu</code>上端口1521的服务<code>univdb</code>。</li><li><strong><code>Statement.executeUpdate()</code> vs <code>executeQuery()</code></strong>：<ul><li><code>executeUpdate()</code>：用于执行会修改数据库内容的SQL语句（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code>等），返回一个整数，表示受影响的行数。</li><li><code>executeQuery()</code>：专门用于执行<code>SELECT</code>语句，返回一个<code>ResultSet</code>对象。</li></ul></li><li><strong><code>ResultSet</code>处理</strong>：<ul><li>结果集初始时游标位于第一行<strong>之前</strong>。</li><li><code>next()</code>方法将游标向前移动一行，并返回一个布尔值，指示新行是否有效。</li><li>可以使用列名（字符串）或列索引（从1开始）来获取列值。<code>getString(1)</code>和<code>getString(“dept_name”)</code>是等价的（假设<code>dept_name</code>是<code>SELECT</code>子句中的第一个元素）。</li></ul></li><li><strong>异常处理</strong>：几乎所有JDBC操作都可能抛出<code>SQLException</code>，必须妥善处理。通常使用<code>try-catch</code>块来捕获，并至少记录错误信息。</li><li><strong>资源管理</strong>：<code>Connection</code>、<code>Statement</code>和<code>ResultSet</code>都是持有昂贵底层资源（如数据库连接、服务器游标）的对象。<strong>必须</strong>在使用完毕后显式调用<code>close()</code>方法将其关闭，以防止资源泄漏。推荐使用Java 7引入的<code>try-with-resources</code>语法实现自动关闭。</li></ol><h4 id="处理空值（Null-Values）">处理空值（Null Values）</h4><p>从<code>ResultSet</code>中读取数据时，如果某列的值为SQL <code>NULL</code>，则<code>getXXX()</code>方法会返回对应Java类型的默认值（如0、<code>false</code>、<code>null</code>）。为了准确区分数据库中的<code>NULL</code>和默认值，可以使用<code>ResultSet.wasNull()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Got null value for column &#x27;a&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC高级特性（预编译语句、元数据、事务控制）">JDBC高级特性（预编译语句、元数据、事务控制）</h2><h3 id="5-1-2-1-预编译语句（PreparedStatement）">5.1.2.1 预编译语句（PreparedStatement）</h3><p>预编译语句是<code>Statement</code>接口的一个更强大、更安全、通常也更高效的子接口。</p><ul><li><p><strong>工作原理</strong>：SQL语句在创建<code>PreparedStatement</code>对象时即被发送到数据库进行<strong>预编译</strong>。语句中的变量部分用占位符<code>?</code>表示。之后，每次执行只需为这些<code>?</code>传入具体的参数值即可。</p></li><li><p><strong>优势</strong>：</p><ol><li><strong>性能</strong>：对于需要重复执行多次（仅参数不同）的SQL语句，数据库只需编译一次，后续执行直接使用编译好的执行计划，效率显著提升。</li><li><strong>安全</strong>：有效防止<strong>SQL注入攻击</strong>。因为参数值是通过<code>setXXX()</code>方法传递的，而不是拼接到SQL字符串中，数据库会将其视为纯粹的数据，而非可执行代码的一部分。</li><li><strong>可读性与维护性</strong>：将SQL逻辑与参数值分离，代码更清晰。</li></ol></li><li><p><strong>创建与使用示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建PreparedStatement，使用?作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into instructor values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置参数值。索引从1开始。</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);      <span class="comment">// 设置第一个?为ID</span></span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);      <span class="comment">// 设置第二个?为name</span></span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);    <span class="comment">// 设置第三个?为dept_name</span></span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);          <span class="comment">// 设置第四个?为salary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行更新。注意：这里没有SQL字符串参数。</span></span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 重用同一个PreparedStatement插入另一条记录，只需重新设置变化的参数</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>); <span class="comment">// 仅修改ID</span></span><br><span class="line">pStmt.executeUpdate();       <span class="comment">// 再次执行</span></span><br></pre></td></tr></table></figure><p><strong>关键说明</strong>：前四个<code>setXXX</code>语句仅仅是为<code>INSERT</code>语句的参数赋值，并没有触发数据库的插入操作。真正的插入是在调用<code>executeUpdate()</code>时执行的。这允许在批量操作中高效地复用同一个<code>PreparedStatement</code>对象。</p></li></ul><h3 id="5-1-2-2-元数据特性（Metadata）">5.1.2.2 元数据特性（Metadata）</h3><p>元数据是“关于数据的数据”。JDBC提供了访问两类元数据的接口：</p><ol><li><p><strong>结果集元数据（<code>ResultSetMetaData</code>）</strong>：获取关于特定查询结果的结构信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM department&quot;</span>);</span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Column &quot;</span> + i + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;  Name: &quot;</span> + rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Type: &quot;</span> + rsmd.getColumnTypeName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Display Size: &quot;</span> + rsmd.getColumnDisplaySize(i));</span><br><span class="line">    <span class="comment">// 还有其他方法，如isNullable, isAutoIncrement等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用途</strong>：动态处理未知结构的查询结果，常用于通用查询工具或报表生成器。</p></li><li><p><strong>数据库元数据（<code>DatabaseMetaData</code>）</strong>：获取关于整个数据库的目录信息，如所有表、列、主键、外键等。</p><ul><li><strong>获取表的所有列</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getColumns参数: 目录, 模式, 表名模式, 列名模式</span></span><br><span class="line"><span class="comment">// null 表示“所有目录”， &quot;%&quot; 表示“所有”（类似于SQL的LIKE）</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">columns</span> <span class="operator">=</span> dbmd.getColumns(<span class="literal">null</span>, <span class="string">&quot;univdb&quot;</span>, <span class="string">&quot;department&quot;</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (columns.next()) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">        columns.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">        columns.getString(<span class="string">&quot;TYPE_NAME&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>获取表的主键信息</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getPrimaryKeys参数: 目录, 模式, 表名</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">pks</span> <span class="operator">=</span> dmd.getPrimaryKeys(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;department&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pks.next()) &#123;</span><br><span class="line">    <span class="comment">// KEY_SEQ表示该列在主键中的顺序（针对复合主键）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;PK Sequence: &quot;</span> + pks.getString(<span class="string">&quot;KEY_SEQ&quot;</span>) +</span><br><span class="line">                       <span class="string">&quot;, Column: &quot;</span> + pks.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-1-2-3-事务控制（Transaction-Control）">5.1.2.3 事务控制（Transaction Control）</h3><p>默认情况下，JDBC连接处于<strong>自动提交模式</strong>：每条SQL语句都被视为一个独立的事务，并在执行后立即自动提交。</p><ul><li><strong>问题</strong>：对于包含多个更新操作的逻辑单元（如银行转账），自动提交会导致原子性无法保证。如果中间某条语句失败，之前已提交的更改无法自动撤销。</li><li><strong>解决方案</strong>：手动管理事务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关闭自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行一系列更新操作</span></span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE id = &#x27;A&#x27;&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance + 100 WHERE id = &#x27;B&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果全部成功，手动提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 4. 如果发生任何异常，回滚事务，撤销所有未提交的更改</span></span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            <span class="comment">// 处理回滚异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理原异常e</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 5. 恢复自动提交模式（可选，但建议）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-2-4-调用函数和存储过程">5.1.2.4 调用函数和存储过程</h3><p>使用<code>CallableStatement</code>接口调用数据库中的存储函数和存储过程。</p><ul><li><strong>调用函数</strong>（有返回值）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;? = call function_name(?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt1</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;? = call get_dept_count(?)&#125;&quot;</span>);</span><br><span class="line">cStmt1.registerOutParameter(<span class="number">1</span>, Types.INTEGER); <span class="comment">// 注册第一个?为输出参数（返回值）</span></span><br><span class="line">cStmt1.setString(<span class="number">2</span>, <span class="string">&quot;Comp. Sci.&quot;</span>); <span class="comment">// 设置第二个?为输入参数</span></span><br><span class="line">cStmt1.execute();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cStmt1.getInt(<span class="number">1</span>); <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure></li><li><strong>调用过程</strong>（无返回值或通过OUT参数返回）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;call procedure_name(?, ?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt2</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;call adjust_salary(?, ?)&#125;&quot;</span>);</span><br><span class="line">cStmt2.setString(<span class="number">1</span>, <span class="string">&quot;10101&quot;</span>);</span><br><span class="line">cStmt2.setInt(<span class="number">2</span>, <span class="number">5000</span>);</span><br><span class="line">cStmt2.execute();</span><br></pre></td></tr></table></figure></li></ul><h2 id="ODBC详解">ODBC详解</h2><h3 id="5-1-3-ODBC（Open-Database-Connectivity）">5.1.3 ODBC（Open Database Connectivity）</h3><p>ODBC是一个由微软主导制定的开放数据库互连标准，它提供了一个与编程语言和数据库管理系统均无关的调用级API。</p><h4 id="架构">架构</h4><p>ODBC采用分层驱动架构：</p><ol><li><strong>应用程序</strong>：调用标准的ODBC API函数。</li><li><strong>ODBC驱动程序管理器</strong>：作为应用程序的入口点，负责加载、卸载驱动程序，并将应用程序的ODBC调用分派给正确的驱动程序。</li><li><strong>ODBC驱动程序</strong>：由各个数据库厂商提供，负责将标准的ODBC函数调用转换为特定数据库的网络协议或本地API调用（如调用Oracle的OCI库、SQL Server的TDS协议等）。</li><li><strong>数据源</strong>：通过ODBC管理器配置的、指向特定数据库服务器的连接定义（DSN，Data Source Name）。</li></ol><h4 id="ODBC-C语言编程示例与逐步解析">ODBC C语言编程示例与逐步解析</h4><p>以下C程序片段展示了使用ODBC API连接数据库、执行查询并获取结果的完整流程，包含详细的步骤注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// === 步骤 0：声明变量 ===</span></span><br><span class="line">    RETCODE error;           <span class="comment">// 用于接收每个ODBC API调用的返回码（SQL_SUCCESS, SQL_ERROR等）</span></span><br><span class="line">    HENV env;                <span class="comment">// 环境句柄，代表ODBC的上下文环境</span></span><br><span class="line">    HDBC conn;               <span class="comment">// 连接句柄，代表一个数据库连接</span></span><br><span class="line">    HSTMT stmt;              <span class="comment">// 语句句柄，代表一个SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 1：分配环境句柄 ===</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 2：分配连接句柄 ===</span></span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 3：建立连接 ===</span></span><br><span class="line">    <span class="comment">// SQLConnect参数：连接句柄，服务器名，用户名，密码。</span></span><br><span class="line">    <span class="comment">// SQL_NTS 表示前一个参数是以空字符结尾的字符串。</span></span><br><span class="line">    SQLConnect(conn,</span><br><span class="line">               <span class="string">&quot;db.yale.edu&quot;</span>, SQL_NTS,  <span class="comment">// 服务器</span></span><br><span class="line">               <span class="string">&quot;avi&quot;</span>, SQL_NTS,          <span class="comment">// 用户名</span></span><br><span class="line">               <span class="string">&quot;avipasswd&quot;</span>, SQL_NTS);   <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 4：分配语句句柄 ===</span></span><br><span class="line">    SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 5：准备并执行SQL语句 ===</span></span><br><span class="line">    <span class="type">char</span> *sqlquery = <span class="string">&quot;select dept_name, sum(salary) from instructor group by dept_name&quot;</span>;</span><br><span class="line">    <span class="comment">// SQLExecDirect直接执行一个SQL字符串。</span></span><br><span class="line">    error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// === 步骤 6：将结果列绑定到C程序变量 ===</span></span><br><span class="line">        <span class="type">char</span> deptname[<span class="number">80</span>];     <span class="comment">// 用于接收dept_name的缓冲区</span></span><br><span class="line">        <span class="type">float</span> salary;          <span class="comment">// 用于接收sum(salary)的变量</span></span><br><span class="line">        SQLINTEGER lenOut1, lenOut2; <span class="comment">// 用于接收字符串实际长度（可为NULL指示符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQLBindCol将结果集的列与程序变量关联。</span></span><br><span class="line">        <span class="comment">// 参数：语句句柄，列号（从1开始），C变量类型，变量地址，缓冲区长度，长度/指示符缓冲区地址。</span></span><br><span class="line">        SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="keyword">sizeof</span>(deptname), &amp;lenOut1);</span><br><span class="line">        SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2); <span class="comment">// 长度0用于非字符串类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 7：循环获取每一行结果 ===</span></span><br><span class="line">        <span class="comment">// SQLFetch将游标移动到下一行，并将已绑定的列数据提取到对应的C变量中。</span></span><br><span class="line">        <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 检查指示符，判断数据是否为NULL。如果lenOut1 == SQL_NULL_DATA，则deptname无效。</span></span><br><span class="line">            <span class="keyword">if</span> (lenOut1 != SQL_NULL_DATA) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Department: %s, Total Salary: %g\n&quot;</span>, deptname, salary);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误：可以使用SQLError函数获取详细的错误信息。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query execution failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 8：清理资源（逆序释放）===</span></span><br><span class="line">    SQLFreeStmt(stmt, SQL_DROP);   <span class="comment">// 释放语句句柄</span></span><br><span class="line">    SQLDisconnect(conn);          <span class="comment">// 断开连接</span></span><br><span class="line">    SQLFreeConnect(conn);         <span class="comment">// 释放连接句柄</span></span><br><span class="line">    SQLFreeEnv(env);              <span class="comment">// 释放环境句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于连接时长的重要说明">关于连接时长的重要说明</h4><p>在实际生产环境中，数据库服务器或网络设备通常会对客户端连接设置<strong>超时限制</strong>（例如，非活动连接60秒后自动断开）。如果应用程序执行一个非常耗时的SQL查询，其执行时间超过了连接的超时设置，那么该查询可能会被服务器强行终止，导致操作失败。</p><ul><li><strong>注意事项</strong>：使用默认连接设置时，必须确保任何单个数据库操作都不会超过系统的默认连接超时时长。</li><li><strong>解决方案</strong>：ODBC API（如<code>SQLSetConnectAttr</code>）或连接字符串参数通常允许应用程序<strong>调整连接超时或查询超时设置</strong>。在开发需要执行长时间操作的应用程序时，必须合理配置这些超时参数，以保证操作的顺利完成。</li></ul><h2 id="嵌入式SQL详解">嵌入式SQL详解</h2><h3 id="5-1-4-嵌入式SQL">5.1.4 嵌入式SQL</h3><h4 id="SQL的使用方式分类">SQL的使用方式分类</h4><ol><li><strong>交互式SQL</strong>：用户通过数据库系统提供的命令行界面或图形工具直接输入并执行SQL语句，主要用于数据定义（DDL）和即席查询（DML）。</li><li><strong>动态SQL</strong>：如前所述的JDBC/ODBC，在程序运行时动态构建和执行SQL字符串。</li><li><strong>嵌入式SQL</strong>：将SQL语句<strong>直接嵌入</strong>到C、COBOL、Fortran等宿主语言的源代码中，在程序<strong>编译前</strong>通过预处理器进行转换。</li></ol><h4 id="基本概念">基本概念</h4><ul><li><strong>宿主语言</strong>：嵌入SQL语句的通用编程语言（如C）。</li><li><strong>预处理器</strong>：一个专门的工具，它扫描包含嵌入式SQL的源代码文件，识别出所有SQL语句，将它们转换为对数据库运行时库（通常基于ODBC或类似接口）的函数调用，并生成一个纯宿主语言的中间文件供编译器编译。</li><li><strong>优点</strong>：结合了SQL强大的数据操作能力和宿主语言的计算、流程控制及输入/输出能力，适用于编写复杂的数据处理应用程序。</li></ul><h4 id="语法要素与示例">语法要素与示例</h4><ul><li><strong>语句标识</strong>：所有嵌入式SQL语句都以<code>EXEC SQL</code>开头，以宿主语言特定的结束符结尾（C语言中常用分号<code>;</code>，COBOL中用<code>END-EXEC</code>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></table></figure></li><li><strong>连接数据库</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO server USER user_name USING password;</span><br></pre></td></tr></table></figure></li><li><strong>共享变量（宿主变量）</strong>：<ul><li>宿主语言的变量可以在嵌入式SQL语句中使用，以<strong>冒号（<code>:</code>）</strong> 作为前缀，以便与SQL自身的列名区分。</li><li>这些共享变量必须在专门的<code>DECLARE SECTION</code>中声明。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;  <span class="comment">// 宿主变量</span></span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>];         <span class="comment">// 用于接收ID</span></span><br><span class="line">    <span class="type">char</span> sn[<span class="number">20</span>];        <span class="comment">// 用于接收name</span></span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 从用户输入或其他地方为credit_amount赋值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL SELECT ID, name INTO :si, :sn</span><br><span class="line">         FROM student</span><br><span class="line">         WHERE tot_cred &gt; :credit_amount; <span class="comment">// 在WHERE子句中使用宿主变量</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="游标（Cursor）：处理多行结果集的关键机制">游标（Cursor）：处理多行结果集的关键机制</h4><p>当嵌入式SQL查询可能返回多行结果时，无法直接用<code>INTO</code>子句将多行赋值给有限的宿主变量。此时必须使用<strong>游标</strong>。</p><ol><li><p><strong>声明游标</strong>：将游标与一个查询关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE tot_cred &gt; :credit_amount;</span><br></pre></td></tr></table></figure></li><li><p><strong>打开游标</strong>：执行游标关联的查询。此时，DBMS会准备结果集（可能物化到一个临时区域），游标定位在结果集第一行<strong>之前</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN c;</span><br></pre></td></tr></table></figure><p><strong>重要</strong>：打开游标时，查询中引用的宿主变量（如<code>:credit_amount</code>）的值被“定格”使用。后续修改该宿主变量不会影响已打开的游标结果。</p></li><li><p><strong>提取数据</strong>：将游标向前推进一行，并将该行数据提取到指定的宿主变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line"><span class="comment">// 每次FETCH后，需要检查SQL通信区（SQLCA）中的返回码，判断是否成功提取到数据或已到达结果集末尾。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭游标</strong>：释放与游标相关的数据库资源（如临时存储空间、锁等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure></li></ol><p><strong>完整游标使用循环示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;</span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>], sn[<span class="number">20</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 获取credit_amount的值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name FROM student WHERE tot_cred &gt; :credit_amount;</span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c;</span><br><span class="line"><span class="comment">// 使用SQLCODE（SQLCA中的一个变量）检查状态。0表示成功，100表示无更多数据。</span></span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Student: %s, Name: %s\n&quot;</span>, si, sn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure><h4 id="通过游标进行定位更新或删除">通过游标进行定位更新或删除</h4><p>游标不仅可以读取数据，还可以用于更新或删除“当前”行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个用于更新的游标，必须使用FOR UPDATE子句</span></span><br><span class="line">EXEC SQL DECLARE c_upd CURSOR FOR</span><br><span class="line">    SELECT * FROM instructor WHERE dept_name = <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">    FOR UPDATE OF salary; <span class="comment">// 指定可更新的列</span></span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c_upd;</span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c_upd INTO ...; <span class="comment">// 将整行数据提取到对应的宿主变量</span></span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新当前游标指向的行</span></span><br><span class="line">        EXEC SQL UPDATE instructor</span><br><span class="line">                 SET salary = salary + <span class="number">1000</span></span><br><span class="line">                 WHERE CURRENT OF c_upd; <span class="comment">// 关键：定位更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c_upd;</span><br></pre></td></tr></table></figure><h2 id="SQL函数与存储过程">SQL函数与存储过程</h2><h3 id="5-2-函数与存储过程">5.2 函数与存储过程</h3><p>SQL允许在数据库服务器端创建命名的、可重用的程序化模块：<strong>函数</strong>和<strong>存储过程</strong>。它们可以用SQL语言自身编写，也可以用外部编程语言（如C、Java）编写。</p><ul><li><strong>外部语言函数/过程</strong>：适用于处理复杂计算或特定数据类型（如图像、几何对象）。例如，用C编写一个函数来判断两个多边形是否重叠。</li><li><strong>表值函数</strong>：一种特殊函数，可以返回一个关系（表）作为结果。</li><li><strong>SQL的编程扩展</strong>：SQL-99标准引入了丰富的程序化构造，如变量声明、条件语句（IF-THEN-ELSE）、循环（LOOP, WHILE）和赋值，使得用纯SQL编写复杂逻辑成为可能。</li></ul><h4 id="5-2-1-SQL标量函数示例">5.2.1 SQL标量函数示例</h4><p>创建一个返回指定部门教师人数的函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_count(dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>; <span class="comment">-- 声明局部变量</span></span><br><span class="line">    <span class="comment">-- 将查询结果赋值给局部变量</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count.dept_name;</span><br><span class="line">    <span class="keyword">RETURN</span> d_count; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>使用函数</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在查询中像内置函数一样调用</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, budget</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-SQL存储过程示例">5.2.2 SQL存储过程示例</h4><p>将上述功能改写为存储过程。存储过程通常通过<code>OUT</code>参数返回结果，并且不包含<code>RETURN</code>语句（除非是返回状态码）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">IN</span> dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>), <span class="comment">-- 输入参数</span></span><br><span class="line">    <span class="keyword">OUT</span> d_count <span class="type">INTEGER</span>       <span class="comment">-- 输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong>：</p><ul><li>从另一个SQL过程或脚本中调用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">CALL</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>, d_count);</span><br></pre></td></tr></table></figure></li><li>从嵌入式SQL中调用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    integer d_count;</span><br><span class="line">    <span class="type">char</span> dept_name[] = <span class="string">&quot;Physics&quot;</span>;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line">EXEC SQL CALL <span class="title function_">dept_count_proc</span><span class="params">(:dept_name, :d_count)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-优势与存储">5.2.3 优势与存储</h4><p>函数和存储过程在创建时被<strong>编译和优化</strong>，生成执行计划并存储在数据库的系统目录中（如图所示，在SQL Server中位于“可编程性”下的“函数”和“存储过程”节点）。应用程序只需调用其名称，无需再次进行语法分析和优化，因此具有以下优点：</p><ul><li><strong>性能提升</strong>：减少重复编译开销。</li><li><strong>减少网络流量</strong>：将复杂运算放在服务器端，只传递参数和结果。</li><li><strong>代码重用与封装</strong>：业务逻辑集中存储在数据库，多个应用可共享，确保一致性，便于维护。</li><li><strong>增强安全性</strong>：可以通过授权控制用户对过程和函数的执行权限，而不直接暴露底层表。</li></ul><h2 id="触发器">触发器</h2><h3 id="5-3-触发器">5.3 触发器</h3><h4 id="5-3-1-概述">5.3.1 概述</h4><ul><li><strong>定义</strong>：触发器是存储在数据库中的一种特殊类型的存储过程，它<strong>自动执行</strong>，以作为对数据库中特定表进行数据修改（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的“副作用”。</li><li><strong>本质</strong>：一种基于<strong>事件-条件-动作</strong>模型的完整性维护和业务规则执行机制。<ul><li><strong>事件</strong>：什么操作（增、删、改）会触发它。</li><li><strong>条件</strong>：（可选）触发后，在什么条件下才执行动作。</li><li><strong>动作</strong>：当事件发生且条件满足时要执行的SQL语句（补救措施或额外操作）。</li></ul></li><li><strong>历史</strong>：触发器概念在SQL-99标准中正式引入，但很多数据库厂商在此前就已通过非标准语法提供了支持。<strong>注意</strong>：不同DBMS的触发器语法细节（尤其是引用新旧行、语句级触发）可能存在差异。</li></ul><h4 id="5-3-2-触发事件与动作">5.3.2 触发事件与动作</h4><ul><li><strong>触发事件</strong>：可以是<code>INSERT</code>、<code>DELETE</code>或<code>UPDATE</code>。</li><li><strong>更新触发器的粒度</strong>：对于<code>UPDATE</code>触发器，可以限定只在特定列被更新时才触发。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes <span class="comment">-- 只在grade列被更新时触发</span></span><br></pre></td></tr></table></figure></li><li><strong>引用新旧行值</strong>：<ul><li><code>REFERENCING OLD ROW AS</code>：用于在<code>DELETE</code>和<code>UPDATE</code>触发器中引用<strong>修改前</strong>的旧行数据。</li><li><code>REFERENCING NEW ROW AS</code>：用于在<code>INSERT</code>和<code>UPDATE</code>触发器中引用<strong>修改后</strong>的新行数据（对于<code>INSERT</code>，旧行不存在；对于<code>DELETE</code>，新行不存在）。</li></ul></li><li><strong>触发时机</strong>：<code>BEFORE</code>或<code>AFTER</code>。<ul><li><code>BEFORE</code>触发器：在约束检查<strong>之前</strong>、操作实际修改数据<strong>之前</strong>执行。常用于数据清洗、转换或执行额外约束。</li><li><code>AFTER</code>触发器：在操作已成功执行、约束检查通过<strong>之后</strong>执行。常用于审计、维护衍生数据或执行级联操作。</li></ul></li></ul><h4 id="5-3-3-行级触发器示例详解">5.3.3 行级触发器示例详解</h4><ol><li><p><strong><code>BEFORE</code>触发器示例：数据清洗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> setnull_trigger BEFORE <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>) <span class="comment">-- 触发条件：新成绩为空字符串</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">SET</span> nrow.grade <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 动作：在插入前将其设为NULL</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>逻辑</strong>：当更新<code>takes</code>表的<code>grade</code>列时，如果新值是空字符串，则在数据真正写入表之前，将其更改为<code>NULL</code>。</li><li><strong>关键</strong>：因为是<code>INSERT</code>或<code>UPDATE</code>操作，所以可以引用<code>NEW ROW</code>。<code>BEFORE</code>触发器有能力修改即将被写入的<code>NEW ROW</code>的值。</li></ul></li><li><p><strong><code>AFTER</code>触发器示例：维护复杂的参照完整性</strong><br>假设我们有不使用外键约束，或用触发器实现比外键更复杂规则的需求。</p><ul><li><p><strong>示例1：插入<code>section</code>时检查<code>time_slot_id</code>是否存在</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>; <span class="comment">-- 动作：回滚整个插入事务</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：试图插入一条<code>section</code>记录，其<code>time_slot_id</code>为‘3-5节’，但<code>timeslot</code>表中并无此时间段定义。</li><li><strong>动作</strong>：<code>ROLLBACK</code>会撤销导致触发器激活的整个<code>INSERT</code>事务，阻止非法数据进入。</li></ul></li><li><p><strong>示例2：删除<code>timeslot</code>时，确保不被<code>section</code>引用</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> timeslot</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (</span><br><span class="line">    <span class="comment">-- 条件1：被删除的time_slot_id是表中该ID的最后一条记录</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot)</span><br><span class="line">    <span class="keyword">AND</span></span><br><span class="line">    <span class="comment">-- 条件2：并且该ID仍在section表中被引用</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> section)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：删除<code>timeslot</code>表中关于‘1-2节’的最后一条记录，但<code>section</code>表中仍有课程安排使用‘1-2节’。</li><li><strong>逻辑</strong>：<code>WHEN</code>子句中的条件确保只在删除某个<code>time_slot_id</code>的<strong>最后一个</strong>实例，且该ID仍被参照时，才触发回滚。这比简单的外键<code>ON DELETE RESTRICT</code>更精细。</li></ul></li></ul></li><li><p><strong><code>AFTER</code>触发器示例：自动维护派生属性（冗余数据）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">      <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> credits</span><br><span class="line">        <span class="keyword">FROM</span> course</span><br><span class="line">        <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> student.ID <span class="operator">=</span> nrow.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：学生一门课的成绩从不及格(‘F’)或空，更新为及格（非‘F’且非空）。</li><li><strong>条件</strong>：<code>WHEN</code>子句精确捕捉了这种“状态转变”。</li><li><strong>动作</strong>：根据<code>nrow.course_id</code>找到课程学分，累加到对应学生(<code>nrow.ID</code>)的总学分<code>tot_cred</code>中。这是一个典型的用触发器维护数据一致性的例子。</li></ul></li></ol><h4 id="5-3-4-语句级触发器">5.3.4 语句级触发器</h4><p>行级触发器（<code>FOR EACH ROW</code>）对受影响的每一行都执行一次动作。如果一条语句更新了1000行，则触发器动作会执行1000次。</p><ul><li><strong>语句级触发器</strong>：使用<code>FOR EACH STATEMENT</code>（默认），整个触发事件（一条SQL语句）只触发一次动作，无论该语句影响了多少行。</li><li><strong>引用过渡表</strong>：使用<code>REFERENCING OLD TABLE AS</code> 或 <code>REFERENCING NEW TABLE AS</code> 来引用包含所有被影响行的旧值或新值的<strong>临时表</strong>（称为过渡表）。</li><li><strong>优点</strong>：当触发动作不依赖于单行数据，或需要对所有受影响行进行聚合操作时，语句级触发器<strong>效率高得多</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> log_salary_update AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> instructor</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> old_vals</span><br><span class="line">            <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> new_vals</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="comment">-- 将本次批量更新的摘要记录到审计表</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> salary_audit(update_time, avg_increase)</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="built_in">AVG</span>(new_vals.salary <span class="operator">-</span> old_vals.salary)</span><br><span class="line">    <span class="keyword">FROM</span> old_vals, new_vals</span><br><span class="line">    <span class="keyword">WHERE</span> old_vals.ID <span class="operator">=</span> new_vals.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3-5-何时应避免使用触发器">5.3.5 何时应避免使用触发器</h4><p>尽管触发器功能强大，但在现代数据库系统中，许多传统的触发器应用场景已有更好替代方案：</p><ol><li><p><strong>维护汇总数据（如部门总薪资）</strong>：</p><ul><li><strong>旧方式</strong>：在<code>instructor</code>表上设置<code>AFTER INSERT/UPDATE/DELETE</code>触发器，实时更新<code>department</code>表的一个<code>total_salary</code>字段。</li><li><strong>现代方式</strong>：使用<strong>物化视图</strong>。数据库系统自动维护物化视图的更新，通常比手动编写的触发器更高效、可靠。</li></ul></li><li><p><strong>数据库复制</strong>：</p><ul><li><strong>旧方式</strong>：用触发器将变更记录到“增量表”（change/delta relations），再由独立进程读取并应用到副本。</li><li><strong>现代方式</strong>：使用数据库内置的<strong>复制技术</strong>（如基于日志的复制、逻辑复制）。这些功能更健壮，对性能影响更小。</li></ul></li><li><p><strong>简单的数据验证</strong>：</p><ul><li><strong>首选</strong>：应尽量使用声明式的<strong>完整性约束</strong>（<code>NOT NULL</code>, <code>UNIQUE</code>, <code>CHECK</code>, <code>FOREIGN KEY</code>）。约束更易于声明、理解和维护，并由DBMS优化执行。</li></ul></li><li><p><strong>过度复杂的业务逻辑</strong>：</p><ul><li><strong>问题</strong>：将大量核心业务逻辑放入触发器，会造成“逻辑黑洞”，使得数据变更行为难以理解和调试，也增加了应用与数据库的耦合度。</li><li><strong>建议</strong>：核心业务逻辑应放在应用层或中间件，数据库主要负责数据存储和基础完整性。触发器仅用于处理与数据本身紧密相关、原子性的规则。</li></ul></li></ol><h2 id="本章总结与展望">本章总结与展望</h2><h3 id="本章总结">本章总结</h3><p>第五章“高级SQL”系统性地讲解了将SQL与程序设计及数据库内部自动化逻辑相结合的高级技术。</p><ol><li><strong>从编程语言访问SQL</strong>：掌握了<strong>动态SQL</strong>（JDBC, ODBC）和<strong>嵌入式SQL</strong>两种集成范式。理解了连接管理、预编译语句、事务控制、元数据访问等核心编程接口，能够构建健壮的数据库应用程序。</li><li><strong>函数与存储过程</strong>：学会了在数据库服务器端创建可重用的程序单元，封装业务逻辑，提升性能、安全性和代码可维护性。</li><li><strong>触发器</strong>：深入理解了基于<strong>事件-条件-动作</strong>模型的自动化机制。能够设计行级和语句级触发器，用于实现复杂的完整性约束、审计跟踪和衍生数据维护。同时，也认识到应优先使用声明式约束和现代数据库内置功能，谨慎而有选择地使用触发器。</li></ol><h3 id="后续章节展望（简要提及）">后续章节展望（简要提及）</h3><p>本章末尾指出，高级SQL的主题还包含其他重要内容，将在后续可能展开：</p><ul><li><strong>5.4 递归查询</strong>：用于处理具有层次结构或图结构的数据（如组织结构、物料清单BOM）。</li><li><strong>5.5 高级聚合函数</strong>：超越<code>SUM</code>、<code>AVG</code>，如<code>ROLLUP</code>、<code>CUBE</code>、<code>GROUPING SETS</code>用于多维分析，以及窗口函数（<code>OVER</code>子句）用于行间计算。</li><li><strong>5.6 流程化函数</strong>：可能指更复杂的流程控制语句在SQL程序中的应用。</li></ul><hr><p><strong>结束</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级SQL 简读</title>
      <link href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：从编程语言访问-SQL">第一章：从编程语言访问 SQL</h2><h3 id="1-1-概述：数据库应用系统架构">1.1 概述：数据库应用系统架构</h3><p>数据库应用系统 (DBAS) 由用户 (Users)、应用程序 (Application Programs)、数据库管理系统 (DBMS) 和数据库 (DB) 四部分组成。应用程序需要与数据库服务器进行交互，这通常通过应用程序编程接口 (API) 实现。一个典型的交互流程包括：</p><ol><li>连接数据库服务器。</li><li>向数据库服务器发送 SQL 命令。</li><li>将查询结果集中的元组逐个提取到程序变量中进行处理。</li></ol><h3 id="1-2-访问-SQL-的两种主要途径">1.2 访问 SQL 的两种主要途径</h3><h4 id="1-2-1-动态-SQL">1.2.1 动态 SQL</h4><ul><li><strong>定义</strong>：在通用编程语言（如 Java、C、C++）中，程序将 SQL 查询动态构建为字符串，然后通过 API 函数提交给数据库并获取结果。</li><li><strong>特点</strong>：<ul><li>查询在运行时构建和发送，非常灵活。</li><li>需要在程序中显式处理连接、语句执行和结果集获取。</li></ul></li><li><strong>主流技术</strong>：<ul><li><strong>JDBC</strong>：用于 Java 语言的数据库连接标准。</li><li><strong>ODBC</strong>：一种开放的、与语言无关的数据库连接标准，支持 C、C++ 等多种语言。</li></ul></li></ul><h4 id="1-2-2-嵌入式-SQL">1.2.2 嵌入式 SQL</h4><ul><li><strong>定义</strong>：将 SQL 语句直接嵌入到宿主语言（如 C、COBOL）的源代码中。在编译时，由预处理器将这些 SQL 语句转换为特定数据库 API 的函数调用。</li><li><strong>特点</strong>：<ul><li>SQL 语句在编译时确定，可进行早期语法检查和优化。</li><li>编程模型更接近原生 SQL，通常通过游标处理结果集。</li><li>最终实现依赖于底层的动态 SQL 机制。</li></ul></li></ul><h3 id="1-3-JDBC-详解">1.3 JDBC 详解</h3><p>JDBC 是 Java 数据库连接的标准 API，它提供了一套用于执行 SQL 语句、检索结果以及访问数据库元数据的接口。</p><h4 id="1-3-1-JDBC-核心编程模型">1.3.1 JDBC 核心编程模型</h4><p>一个典型的 JDBC 程序包含以下步骤，如示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String userid, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 加载数据库驱动程序 (JDBC 4+ 可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 建立数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>,</span><br><span class="line">            userid, passwd);</span><br><span class="line">        <span class="comment">// 3. 创建语句对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// 4a. 执行数据更新操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.executeUpdate(</span><br><span class="line">                <span class="string">&quot;insert into instructor values(&#x27;77987&#x27;, &#x27;Kim&#x27;, &#x27;Physics&#x27;, 98000)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4b. 执行查询并处理结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;select dept_name, avg(salary) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from instructor &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by dept_name&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rset.next()) &#123;</span><br><span class="line">            System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>) + <span class="string">&quot; &quot;</span> + rset.getFloat(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 清理资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exception: &quot;</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-关键组件与步骤解析">1.3.2 关键组件与步骤解析</h4><ol><li><strong>加载驱动</strong>：<code>Class.forName()</code> 用于显式加载 JDBC 驱动类。自 JDBC 4.0 (Java 6) 起，支持驱动自动发现，此步骤可省略。</li><li><strong>建立连接</strong>：通过 <code>DriverManager.getConnection(url, user, password)</code> 获取 <code>Connection</code> 对象。URL 格式因数据库而异。</li><li><strong>创建语句</strong>：使用 <code>Connection.createStatement()</code> 创建 <code>Statement</code> 对象，用于发送静态 SQL 语句。</li><li><strong>执行语句</strong>：<ul><li><strong>更新操作</strong>：使用 <code>executeUpdate()</code> 执行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CREATE TABLE</code> 等语句，返回受影响的行数。</li><li><strong>查询操作</strong>：使用 <code>executeQuery()</code> 执行 <code>SELECT</code> 语句，返回一个 <code>ResultSet</code> 对象。</li></ul></li><li><strong>处理结果集</strong>：<ul><li><code>ResultSet.next()</code> 方法将游标移动到下一行，如果有数据则返回 <code>true</code>。</li><li>使用 <code>getString(columnLabel/Index)</code>、<code>getInt()</code>、<code>getFloat()</code> 等方法获取当前行的列值。</li><li>可以使用列名（字符串）或列索引（从1开始）指定列。</li></ul></li><li><strong>处理空值</strong>：可以使用 <code>ResultSet.wasNull()</code> 方法检查上一次 <code>getXXX()</code> 调用读取的值是否为 SQL <code>NULL</code>。</li><li><strong>异常处理</strong>：使用 <code>try-catch</code> 块捕获 <code>SQLException</code>。</li><li><strong>资源关闭</strong>：必须显式关闭 <code>ResultSet</code>、<code>Statement</code> 和 <code>Connection</code> 对象以释放数据库资源。现代 Java 可使用 <code>try-with-resources</code> 语法自动管理。</li></ol><h4 id="1-3-3-预编译语句">1.3.3 预编译语句</h4><p>为了提升性能和安全（防止SQL注入），应使用 <code>PreparedStatement</code>。</p><ul><li><strong>原理</strong>：SQL 语句被预编译并存储在数据库中，其中参数用 <code>?</code> 占位。执行时只需传入参数值。</li><li><strong>优点</strong>：高效（多次执行同一模板语句时无需重复编译）、安全（参数值会被正确转义）。</li><li><strong>示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into instructor values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>); <span class="comment">// 设置第一个?的值，索引从1开始</span></span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line"><span class="comment">// 重用同一PreparedStatement插入另一条记录</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-4-元数据检索">1.3.4 元数据检索</h4><p>JDBC 允许程序动态探查数据库的结构。</p><ul><li><strong>结果集元数据</strong> (<code>ResultSetMetaData</code>)：获取查询结果的列信息。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Column name: &quot;</span> + rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;Column type: &quot;</span> + rsmd.getColumnTypeName(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>数据库元数据</strong> (<code>DatabaseMetaData</code>)：获取数据库整体信息，如表、列、主键等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// 获取指定表的所有列信息</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getColumns(<span class="literal">null</span>, <span class="string">&quot;univdb&quot;</span>, <span class="string">&quot;department&quot;</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>) + <span class="string">&quot;: &quot;</span> + rs.getString(<span class="string">&quot;TYPE_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定表的主键信息</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">pkRs</span> <span class="operator">=</span> dbmd.getPrimaryKeys(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;department&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pkRs.next()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;PK Seq: &quot;</span> + pkRs.getString(<span class="string">&quot;KEY_SEQ&quot;</span>) +</span><br><span class="line">                       <span class="string">&quot;, Column: &quot;</span> + pkRs.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-5-事务控制">1.3.5 事务控制</h4><p>默认情况下，JDBC 处于自动提交模式，每条 SQL 语句都是一个独立的事务。</p><ul><li><strong>手动管理事务</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 关闭自动提交</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行多条更新语句</span></span><br><span class="line">    stmt.executeUpdate(...);</span><br><span class="line">    stmt.executeUpdate(...);</span><br><span class="line">    conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    conn.rollback(); <span class="comment">// 发生错误时回滚</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>); <span class="comment">// 恢复自动提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-6-调用存储过程和函数">1.3.6 调用存储过程和函数</h4><p>使用 <code>CallableStatement</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt1</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;? = call some_function(?)&#125;&quot;</span>);</span><br><span class="line">cStmt1.registerOutParameter(<span class="number">1</span>, Types.INTEGER); <span class="comment">// 注册输出参数</span></span><br><span class="line">cStmt1.setInt(<span class="number">2</span>, <span class="number">100</span>); <span class="comment">// 设置输入参数</span></span><br><span class="line">cStmt1.execute();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cStmt1.getInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用存储过程</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt2</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;call some_procedure(?,?)&#125;&quot;</span>);</span><br><span class="line">cStmt2.setString(<span class="number">1</span>, <span class="string">&quot;param1&quot;</span>);</span><br><span class="line">cStmt2.setInt(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">cStmt2.execute();</span><br></pre></td></tr></table></figure><h3 id="1-4-ODBC-详解">1.4 ODBC 详解</h3><p>ODBC 是一个与编程语言和数据库无关的调用级接口标准。</p><h4 id="1-4-1-ODBC-架构">1.4.1 ODBC 架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序 → ODBC API → ODBC 驱动程序管理器 → 特定DB的ODBC驱动 → 数据库</span><br></pre></td></tr></table></figure><ul><li><strong>驱动程序管理器</strong>：负责加载、卸载驱动程序，并作为应用程序的入口点。</li><li><strong>驱动程序</strong>：由数据库厂商提供，负责将标准的 ODBC 调用转换为特定数据库的通信协议。</li></ul><h4 id="1-4-2-ODBC-C-语言编程示例">1.4.2 ODBC C 语言编程示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    RETCODE error; <span class="comment">// 返回码</span></span><br><span class="line">    HENV env;      <span class="comment">// 环境句柄</span></span><br><span class="line">    HDBC conn;     <span class="comment">// 连接句柄</span></span><br><span class="line">    HSTMT stmt;    <span class="comment">// 语句句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配环境句柄</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    <span class="comment">// 2. 分配连接句柄</span></span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    <span class="comment">// 3. 建立连接</span></span><br><span class="line">    SQLConnect(conn, <span class="string">&quot;db.yale.edu&quot;</span>, SQL_NTS, <span class="string">&quot;avi&quot;</span>, SQL_NTS, <span class="string">&quot;avipasswd&quot;</span>, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 分配语句句柄</span></span><br><span class="line">    SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 执行SQL语句</span></span><br><span class="line">    <span class="type">char</span> *sqlquery = <span class="string">&quot;select dept_name, sum(salary) from instructor group by dept_name&quot;</span>;</span><br><span class="line">    error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// 6. 绑定结果列到C变量</span></span><br><span class="line">        <span class="type">char</span> deptname[<span class="number">80</span>];</span><br><span class="line">        <span class="type">float</span> salary;</span><br><span class="line">        SQLINTEGER lenOut1, lenOut2;</span><br><span class="line">        SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="number">80</span>, &amp;lenOut1);</span><br><span class="line">        SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 逐行获取结果</span></span><br><span class="line">        <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %s %g\n&quot;</span>, deptname, salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 清理资源</span></span><br><span class="line">    SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-连接时长管理">1.4.3 连接时长管理</h4><ul><li>实际数据库平台对客户端连接时长有限制（如默认60秒）。</li><li>如果 SQL 查询执行时间超过连接时长，操作会被强行终止。</li><li>可通过 ODBC API (<code>SQLSetConnectAttr</code>) 或连接字符串参数调整连接超时设置，以确保长时间操作顺利完成。</li></ul><h3 id="1-5-嵌入式-SQL-详解">1.5 嵌入式 SQL 详解</h3><h4 id="1-5-1-基本概念">1.5.1 基本概念</h4><ul><li><strong>宿主语言</strong>：嵌入 SQL 语句的通用编程语言，如 C、COBOL。</li><li><strong>工作原理</strong>：源代码通过预处理器，将嵌入式 SQL 语句转换为对数据库运行时库的函数调用，然后再由宿主语言编译器编译。</li><li><strong>优点</strong>：结合了 SQL 强大的数据操作能力和宿主语言的计算、流程控制能力。</li></ul><h4 id="1-5-2-语法与示例">1.5.2 语法与示例</h4><ul><li><strong>声明共享变量</strong>：宿主语言变量需在特殊声明节中声明，并在 SQL 语句前加冒号 (<code>:</code>) 引用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;</span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> sn[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br></pre></td></tr></table></figure></li><li><strong>连接数据库</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> server <span class="keyword">USER</span> user_name <span class="keyword">USING</span> password;</span><br></pre></td></tr></table></figure></li><li><strong>静态 SQL 查询与游标</strong>：当查询返回多行结果时，必须使用游标。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 声明游标</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> c <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> ID, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> tot_cred <span class="operator">&gt;</span> :credit_amount;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 打开游标（执行查询）</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 循环获取数据</span><br><span class="line">while (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> :si, :sn;</span><br><span class="line">    if (sqlca.sqlcode <span class="operator">!=</span> <span class="number">0</span>) break; <span class="operator">/</span><span class="operator">/</span> 使用 SQLCA 检查状态</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 处理 si, sn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 关闭游标</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></table></figure></li><li><strong>通过游标更新数据</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> c <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> instructor <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="operator">/</span><span class="operator">/</span> 声明为可更新游标</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br><span class="line">while (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> ...;</span><br><span class="line">    if (no_more_data) break;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 更新当前游标指向的行</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">UPDATE</span> instructor</span><br><span class="line">             <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line">             <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></table></figure></li></ul><h2 id="第二章：SQL-函数与存储过程">第二章：SQL 函数与存储过程</h2><h3 id="2-1-SQL-函数">2.1 SQL 函数</h3><p>函数是接受参数、执行计算并返回一个标量值的命名程序单元。</p><h4 id="2-1-1-创建-SQL-标量函数">2.1.1 创建 SQL 标量函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个返回指定部门教师人数的函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_count(dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count.dept_name;</span><br><span class="line">    <span class="keyword">RETURN</span> d_count;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<ul><li><code>RETURNS</code> 指定返回值的类型。</li><li><code>BEGIN ... END</code> 定义函数体。</li><li><code>DECLARE</code> 用于声明局部变量。</li><li><code>SELECT ... INTO</code> 将查询结果赋值给变量。</li><li><code>RETURN</code> 语句返回值。</li></ul></li></ul><h4 id="2-1-2-使用-SQL-函数">2.1.2 使用 SQL 函数</h4><p>函数可以在 SQL 语句中像内置函数一样使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询教师人数超过12人的院系及其预算</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, budget</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-SQL-存储过程">2.2 SQL 存储过程</h3><p>存储过程与函数类似，但通常不直接返回值，而是通过输出参数返回结果，并且可以执行更复杂的操作，包括数据修改。</p><h4 id="2-2-1-创建存储过程">2.2.1 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">IN</span> dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>),   <span class="comment">-- 输入参数</span></span><br><span class="line">    <span class="keyword">OUT</span> d_count <span class="type">INTEGER</span>         <span class="comment">-- 输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-调用存储过程">2.2.2 调用存储过程</h4><ul><li><strong>从嵌入式 SQL 中调用</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">    <span class="type">integer</span> d_count;</span><br><span class="line">    <span class="type">char</span> dept_name[] <span class="operator">=</span> &quot;Physics&quot;;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CALL</span> dept_count_proc(:dept_name, :d_count);</span><br></pre></td></tr></table></figure></li><li><strong>从动态 SQL (JDBC/CallableStatement) 中调用</strong>：如前文 JDBC 部分所示。</li><li><strong>从 SQL 脚本或其他过程中调用</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">CALL</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>, d_count);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-优势与存储">2.3 优势与存储</h3><ul><li><strong>预编译与优化</strong>：函数和存储过程在创建时即被编译和优化，生成执行计划并存储在数据库字典中。</li><li><strong>性能提升</strong>：应用程序调用时无需重复进行语法分析、优化，直接执行，效率高。</li><li><strong>减少网络流量</strong>：将复杂逻辑在数据库端执行，只返回结果，避免了大量中间数据的传输。</li><li><strong>代码重用与封装</strong>：业务逻辑被封装在数据库中，可供多个应用程序共享，保证一致性。</li></ul><h2 id="第三章：触发器">第三章：触发器</h2><h3 id="3-1-触发器概述">3.1 触发器概述</h3><h4 id="3-1-1-定义与模型">3.1.1 定义与模型</h4><p>触发器是一种特殊的存储过程，它<strong>自动响应</strong>数据库表上的特定数据修改事件（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>），并根据预定义的条件执行相应的动作。</p><ul><li><strong>事件</strong>：引发触发器执行的操作（插入、更新、删除）。</li><li><strong>条件</strong>：（可选）一个布尔表达式，当条件为真时，触发器动作才执行。</li><li><strong>动作</strong>：触发器要执行的一系列 SQL 语句，用于实现数据检查、完整性维护或业务逻辑。</li></ul><h4 id="3-1-2-语法概览">3.1.2 语法概览</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> column_list&#125;</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line">[<span class="keyword">REFERENCING</span> &#123;<span class="keyword">OLD</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] old_name <span class="operator">|</span> <span class="keyword">NEW</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] new_name</span><br><span class="line">             <span class="operator">|</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] old_table_name <span class="operator">|</span> <span class="keyword">NEW</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] new_table_name&#125;]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;]</span><br><span class="line">[<span class="keyword">WHEN</span> (<span class="keyword">condition</span>)]</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="comment">-- 触发动作体 (SQL 语句)</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-行级触发器">3.2 行级触发器</h3><p>行级触发器对受事件影响的每一行都执行一次触发动作。</p><h4 id="3-2-1-引用新旧行值">3.2.1 引用新旧行值</h4><p>在触发器体内，可以引用被修改行的旧值和新值。</p><ul><li><code>REFERENCING OLD ROW AS</code>：用于 <code>DELETE</code> 和 <code>UPDATE</code> 操作，引用修改前的行。</li><li><code>REFERENCING NEW ROW AS</code>：用于 <code>INSERT</code> 和 <code>UPDATE</code> 操作，引用修改后的行。</li></ul><h4 id="3-2-2-应用示例">3.2.2 应用示例</h4><ol><li><p><strong>数据清洗（<code>BEFORE</code> 触发器）</strong>：在插入或更新前修正数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> setnull_trigger BEFORE <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>)  <span class="comment">-- 当新成绩为空字符串时</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">SET</span> nrow.grade <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 将其设置为 NULL</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><em>说明：此触发器在 <code>takes</code> 表的 <code>grade</code> 列被更新前触发。如果新值是空字符串，则将其改为 <code>NULL</code>。<code>BEFORE</code> 触发器可以修改即将写入数据库的新值。</em></p></li><li><p><strong>维护参照完整性（复杂检查）</strong>：实现比外键约束更复杂的关联规则。</p><ul><li><strong>示例1：插入<code>section</code>时检查<code>time_slot_id</code>有效性</strong>。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>; <span class="comment">-- 回滚整个插入事务</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><em>说明：当尝试插入一个<code>time_slot_id</code>不在<code>timeslot</code>表中的<code>section</code>记录时，事务被回滚。</em></li><li><strong>示例2：删除<code>timeslot</code>时防止孤立引用</strong>。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> timeslot</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (</span><br><span class="line">    <span class="comment">-- 被删除的time_slot_id是timeslot表中该ID的最后一条记录</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot)</span><br><span class="line">    <span class="keyword">AND</span></span><br><span class="line">    <span class="comment">-- 并且该ID仍在section表中被引用</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> section)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><em>说明：防止删除一个正在被<code>section</code>表使用的<code>time_slot_id</code>，且确保它是该ID的最后一个实例。</em></li></ul></li><li><p><strong>维护派生数据（自动更新）</strong>：保持数据间的一致性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">      <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> credits</span><br><span class="line">        <span class="keyword">FROM</span> course</span><br><span class="line">        <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> student.ID <span class="operator">=</span> nrow.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><em>说明：当学生某门课的成绩从不通过(<code>F</code>)或空变为通过（非<code>F</code>且非空）时，自动将该课程的学分累加到学生的总学分(<code>tot_cred</code>)中。</em></p></li></ol><h3 id="3-3-语句级触发器">3.3 语句级触发器</h3><p>语句级触发器在每个触发事件（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）上只执行一次，无论该语句影响了多少行。</p><ul><li><strong>语法</strong>：使用 <code>FOR EACH STATEMENT</code>（这是默认值）。</li><li><strong>引用过渡表</strong>：可以使用 <code>REFERENCING OLD TABLE AS</code> 或 <code>REFERENCING NEW TABLE AS</code> 来引用被该语句影响的所有行的旧值或新值的集合（过渡表）。</li><li><strong>适用场景</strong>：当触发动作不依赖于具体每一行的数据，或者需要对所有受影响的行进行批量操作时，语句级触发器比行级触发器更高效。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> log_salary_change AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> instructor</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> old_table</span><br><span class="line">            <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> new_table</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> salary_audit_log(change_time, old_avg, new_avg)</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">           <span class="built_in">AVG</span>(old_table.salary),</span><br><span class="line">           <span class="built_in">AVG</span>(new_table.salary)</span><br><span class="line">    <span class="keyword">FROM</span> old_table, new_table; <span class="comment">-- 注意：过渡表需在FROM子句中引用</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-触发器的适用与不适用场景">3.4 触发器的适用与不适用场景</h3><h4 id="3-4-1-适用场景">3.4.1 适用场景</h4><ul><li><strong>实现复杂的业务规则或完整性约束</strong>，这些约束无法通过标准的 <code>CHECK</code>、<code>UNIQUE</code>、<code>FOREIGN KEY</code> 约束来表达。</li><li><strong>审计与日志记录</strong>：自动记录数据变更（谁、何时、改了哪些数据）。</li><li><strong>维护衍生或汇总数据</strong>（尽管现在有更好的选择，见下文）。</li><li><strong>数据同步与复制</strong>（在早期技术中）。</li></ul><h4 id="3-4-2-不适用-慎用场景（现代最佳实践）">3.4.2 不适用/慎用场景（现代最佳实践）</h4><ol><li><strong>维护汇总数据</strong>：<ul><li><strong>旧方式</strong>：用触发器在每次数据变更时更新汇总表（如部门总工资）。</li><li><strong>现代方式</strong>：使用 <strong>物化视图</strong>。数据库系统可以自动、高效地维护物化视图的更新，通常比手写触发器更可靠、性能更好。</li></ul></li><li><strong>数据库复制</strong>：<ul><li><strong>旧方式</strong>：用触发器将变更记录到“增量表”，再由其他进程应用。</li><li><strong>现代方式</strong>：使用数据库内置的<strong>复制功能</strong>（如日志传输、逻辑复制），这些功能更健壮、对性能影响更小。</li></ul></li><li><strong>简单的数据有效性检查</strong>：<ul><li><strong>首选</strong>：应尽量使用声明式的<strong>完整性约束</strong>（<code>NOT NULL</code>, <code>CHECK</code>, <code>FOREIGN KEY</code>）。约束更易于声明、理解和维护，且通常由 DBMS 更高效地执行。</li></ul></li><li><strong>过度复杂的业务逻辑</strong>：<ul><li><strong>问题</strong>：将大量复杂逻辑放入触发器可能导致“逻辑黑洞”，使得数据变更行为难以理解和调试，也增加了应用与数据库的耦合度。</li><li><strong>建议</strong>：考虑将核心业务逻辑放在应用层或中间件，数据库主要负责数据存储和基本完整性。</li></ul></li></ol><h3 id="3-5-总结">3.5 总结</h3><p>触发器是基于事件-条件-动作模型的强大工具，是实现复杂数据完整性规则和自动化业务逻辑的有效手段。然而，在现代数据库系统中，应优先考虑使用声明式约束和内置功能（如物化视图、复制）来满足需求。当必须使用触发器时，应谨慎设计，确保其逻辑清晰、高效，并做好充分文档记录，以避免维护的复杂性。</p><hr><h2 id="本章总结">本章总结</h2><p>第五章“高级SQL”将SQL的能力从单纯的数据查询操作扩展到与应用程序的深度集成以及数据库内部的程序化逻辑。</p><ol><li><strong>SQL与编程语言集成</strong>：掌握了通过<strong>JDBC</strong> (Java)、<strong>ODBC</strong> (C/C++) 和<strong>嵌入式SQL</strong>从应用程序中连接、查询和操作数据库的核心模式与技术细节。理解连接管理、事务控制、预编译语句和元数据访问是构建健壮数据库应用的基础。</li><li><strong>数据库端程序化逻辑</strong>：学会了在数据库服务器内部创建可重用的逻辑单元——<strong>函数</strong>（返回标量值）和<strong>存储过程</strong>（执行操作，可通过参数返回结果）。它们提高了代码复用性、减少了网络开销，并允许将业务逻辑封装在数据层。</li><li><strong>自动化响应机制</strong>：深入理解了<strong>触发器</strong>这一基于事件-条件-动作模型的强大工具。能够创建行级和语句级触发器，用于实现复杂的数据完整性约束、自动维护衍生数据、记录审计日志等。同时，也认识到应优先使用声明式约束和现代数据库内置功能，仅在必要时谨慎使用触发器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§3 Intro-to-SQL 简读</title>
      <link href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SQL概述（Overview-of-SQL）">一、SQL概述（Overview of SQL）</h2><h3 id="1-1-SQL的基本概念">1.1 SQL的基本概念</h3><p><strong>SQL (Structured Query Language)</strong> 是一种结构化查询语言，是使用最广泛的数据库查询语言。它已经扩展到其他领域，例如大数据（BigData）处理。</p><h3 id="1-2-SQL的组成部分">1.2 SQL的组成部分</h3><p>SQL由以下几个主要部分组成：</p><p><strong>1. DML（数据操作语言 - Data Manipulation Language）</strong></p><ul><li>查询/检索信息的能力</li><li>对元组进行选择、插入、删除、更新操作</li><li>主要命令：SELECT, INSERT, DELETE, UPDATE</li></ul><p><strong>2. DDL（数据定义语言 - Data Definition Language）</strong></p><ul><li>对模式、视图和索引进行定义、删除、修改</li><li>主要命令：CREATE, DROP, ALTER</li></ul><p><strong>3. 完整性约束（Integrity Constraints）</strong></p><ul><li>指定完整性约束的命令</li></ul><p><strong>4. 视图定义（View Definition）</strong></p><ul><li>定义视图的命令</li></ul><p><strong>5. 事务控制（Transaction Control）</strong></p><ul><li>指定事务开始和结束的命令</li><li>主要命令：BEGIN TRANSACTION, COMMIT, ROLLBACK</li></ul><p><strong>6. 嵌入式SQL和动态SQL</strong></p><ul><li>嵌入在编程语言中的SQL语句</li></ul><p><strong>7. 授权（Authorization）</strong></p><ul><li>主要命令：GRANT, REVOKE</li></ul><hr><h2 id="二、SQL数据定义（DDL）">二、SQL数据定义（DDL）</h2><h3 id="2-1-DDL的功能">2.1 DDL的功能</h3><p>DDL允许对关系进行以下规范：</p><ul><li>每个关系的模式（schema）</li><li>与每个属性关联的值类型</li><li>完整性约束（如 age&gt;0）</li><li>为每个关系维护的索引</li><li>每个关系的安全和授权信息</li><li>每个关系在磁盘上的物理存储结构</li></ul><h3 id="2-2-域类型（Domain-Types）">2.2 域类型（Domain Types）</h3><p><strong>基本数据类型：</strong></p><ol><li><p><strong>char(n)</strong> - 固定长度字符串，用户指定长度n</p></li><li><p><strong>varchar(n)</strong> - 可变长度字符串，用户指定最大长度n</p></li><li><p><strong>int</strong> - 整数（依赖于机器）</p></li><li><p><strong>smallint</strong> - 小整数（整数的机器依赖子集）</p></li><li><p>numeric(p,d)</p><p>- 定点数</p><ul><li>p：精度（总位数）</li><li>d：小数点右侧的位数</li><li>例如：numeric(3,1) 可以精确存储 44.5</li></ul></li></ol><p><strong>日期和时间类型：</strong></p><ol><li><strong>date</strong> - 日期，包含年（4位）、月、日<ul><li>例如：date '2001-07-27'</li></ul></li><li><strong>time</strong> - 时间，包含小时、分钟、秒<ul><li>例如：time '09:00:30' 或 time '09:00:30.75'</li></ul></li><li><strong>timestamp</strong> - 日期加时间<ul><li>例如：timestamp '2001-7-27 09:00:30.75'</li></ul></li><li><strong>interval</strong> - 时间间隔<ul><li>两个日期/时间/时间戳相减得到间隔值</li><li>例如：interval '1' day</li><li>间隔值可以加到日期/时间/时间戳值上</li></ul></li></ol><p><strong>空值处理：</strong></p><ul><li>所有域类型都允许空值（NULL）</li><li>声明属性为 NOT NULL 可以禁止该属性为空值</li></ul><p><strong>用户自定义类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain person<span class="operator">-</span>name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br></pre></td></tr></table></figure><h3 id="2-3-创建表（Create-Table）">2.3 创建表（Create Table）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (</span><br><span class="line">    A1 D1,</span><br><span class="line">    A2 D2,</span><br><span class="line">    ...,</span><br><span class="line">    An Dn,</span><br><span class="line">    (integrity<span class="operator">-</span>constraint1),</span><br><span class="line">    ...,</span><br><span class="line">    (integrity<span class="operator">-</span>constraintk)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>r 是关系名称</li><li>Ai 是属性名</li><li>Di 是属性Ai的数据类型</li></ul><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor (</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-4-完整性约束（Integrity-Constraints）">2.4 完整性约束（Integrity Constraints）</h3><p><strong>主要约束类型：</strong></p><ol><li><strong>primary key (A1, ..., An)</strong> - 主键约束</li><li><strong>foreign key (Am, ..., An) references r</strong> - 外键约束</li><li><strong>not null</strong> - 非空约束</li></ol><p><strong>完整示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor (</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">primary key</span> (ID),</span><br><span class="line">    <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>复合主键示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> takes (</span><br><span class="line">    ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">    course_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    grade <span class="type">varchar</span>(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">primary key</span> (ID, course_id, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">foreign key</span> (ID) <span class="keyword">references</span> student,</span><br><span class="line">    <span class="keyword">foreign key</span> (course_id, <span class="keyword">year</span>) <span class="keyword">references</span> section</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-5-模式更新（Schema-Updates）">2.5 模式更新（Schema Updates）</h3><p><strong>删除表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r</span><br></pre></td></tr></table></figure><p><strong>添加属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> r <span class="keyword">add</span> A D</span><br></pre></td></tr></table></figure><ul><li>A 是要添加的属性名</li><li>D 是属性的域</li><li>所有现有元组的新属性值被赋为 NULL</li><li>例如：<code>alter table student add age integer</code></li></ul><p><strong>删除属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> r <span class="keyword">drop</span> A</span><br></pre></td></tr></table></figure><ul><li>A 是要删除的属性名</li><li>例如：<code>alter table student drop age</code></li><li>注意：许多数据库不支持删除属性</li></ul><p><strong>性能考虑：</strong></p><ul><li>表中的元组按行存储</li><li>添加属性或删除表会导致昂贵的记录修改和移动操作</li><li>NoSQL数据库和大数据系统采用列式存储以优化此类操作</li></ul><hr><h2 id="三、SQL查询基本结构">三、SQL查询基本结构</h2><h3 id="3-1-基本查询形式">3.1 基本查询形式</h3><p><strong>标准SQL查询结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Ai 表示属性</li><li>ri 表示关系</li><li>P 是谓词（条件）</li><li>查询结果是一个关系</li></ul><p><strong>等价的关系代数表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">πA1, A2, ..., An(σP(r1 × r2 × ... × rm))</span><br></pre></td></tr></table></figure><h3 id="3-2-SELECT子句详解">3.2 SELECT子句详解</h3><p><strong>基本功能：</strong></p><ul><li>SELECT子句列出属性，对应关系代数的投影操作</li></ul><p><strong>示例1：查询所有教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>大小写不敏感：</strong></p><ul><li>Name ≡ NAME ≡ name</li></ul><p><strong>去除重复（DISTINCT）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>保留重复（ALL）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">all</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ul><li>ALL是默认选项</li></ul><p><strong>使用星号（*）选择所有属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p>⚠️ <strong>实际应用中应避免使用*，可能导致索引失效</strong></p><p><strong>字面量（Literal）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 无FROM子句</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;437&#x27;</span>  <span class="comment">-- 结果：单列单行，值为437</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;437&#x27;</span> <span class="keyword">as</span> FOO  <span class="comment">-- 给列命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有FROM子句</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">from</span> instructor  <span class="comment">-- 结果：N行（instructor表的行数），每行值为&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>算术表达式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用AS重命名</span></span><br><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">as</span> monthly_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><h3 id="3-3-WHERE子句详解">3.3 WHERE子句详解</h3><p><strong>基本功能：</strong></p><ul><li>WHERE子句指定结果必须满足的条件</li><li>对应关系代数的选择谓词</li></ul><p><strong>逻辑连接词：</strong></p><ul><li>AND（与）</li><li>OR（或）</li><li>NOT（非）</li></ul><p><strong>比较运算符：</strong></p><ul><li>&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;（不等于）</li></ul><p><strong>示例1：单条件查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例2：复合条件查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span> <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">70000</span></span><br></pre></td></tr></table></figure><p><strong>BETWEEN运算符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找工资在90000到100000之间的教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span></span><br><span class="line"><span class="comment">-- 等价于：salary &gt;= 90000 and salary &lt;= 100000</span></span><br></pre></td></tr></table></figure><p><strong>元组比较运算符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> (instructor.ID, dept_name) <span class="operator">=</span> (teaches.ID, <span class="string">&#x27;Biology&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-4-FROM子句详解">3.4 FROM子句详解</h3><p><strong>基本功能：</strong></p><ul><li>FROM子句列出关系</li><li>对应关系代数的笛卡尔积操作</li></ul><p><strong>笛卡尔积：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br></pre></td></tr></table></figure><ul><li>生成每个instructor-teaches配对</li><li>包含两个关系的所有属性</li><li>对于共同属性（如ID），在结果表中使用关系名重命名（<a href="http://instructor.ID">instructor.ID</a>）</li></ul><p>⚠️ <strong>重要注意事项：</strong> 当FROM子句包含多个关系时：</p><ul><li><strong>必须在WHERE子句中加入连接条件</strong></li><li>防止产生代价高昂的多表笛卡尔积操作</li><li>频繁执行的SQL查询，FROM子句的表个数不要过多（<strong>不超过4个表</strong>）</li><li>如需查询涉及≥4张表，考虑将这些表的数据进行合并</li></ul><p><strong>连接查询示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找所有教过课的教师姓名和课程ID</span></span><br><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加部门筛选</span></span><br><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">    <span class="keyword">and</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-自然连接（Natural-Join）">3.5 自然连接（Natural Join）</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>对比传统连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">    <span class="keyword">and</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><p>自然连接自动匹配两个关系中所有同名属性。</p><hr><h2 id="四、SQL查询的计算过程">四、SQL查询的计算过程</h2><h3 id="4-1-完整的SELECT语法">4.1 完整的SELECT语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>&#125; &#123;<span class="operator">&lt;</span><span class="keyword">column</span> expression<span class="operator">&gt;</span>&#125;</span><br><span class="line"><span class="keyword">from</span> &#123;<span class="operator">&lt;</span>table_name <span class="keyword">or</span> view_name<span class="operator">&gt;</span>&#125;</span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>conditional expression <span class="number">1</span><span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>column_name <span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">having</span> <span class="operator">&lt;</span>conditional expression <span class="number">2</span><span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>column_name <span class="number">2</span><span class="operator">&gt;</span> &#123;<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="4-2-查询执行顺序">4.2 查询执行顺序</h3><p><strong>1. FROM和WHERE阶段：</strong></p><ul><li>从FROM子句列出的基表或视图中选择满足WHERE条件的元组</li><li>从这些元组中选择属性，形成结果表</li></ul><p><strong>2. GROUP BY和聚合函数阶段：</strong></p><ul><li>根据条件表达式对结果表进行分组</li><li>对每个组执行组/聚合函数</li><li>输出每个组作为结果</li></ul><p><strong>3. HAVING阶段：</strong></p><ul><li>对分组结果进行筛选</li><li>输出满足条件的组</li></ul><p><strong>4. ORDER BY阶段：</strong></p><ul><li>对结果表或组按降序或升序排序</li></ul><hr><h2 id="五、其他基本操作">五、其他基本操作</h2><h3 id="5-1-重命名操作（RENAME）">5.1 重命名操作（RENAME）</h3><p><strong>使用AS子句重命名关系和属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">old</span><span class="operator">-</span>name <span class="keyword">as</span> <span class="keyword">new</span><span class="operator">-</span>name</span><br></pre></td></tr></table></figure><p><strong>示例：找出所有工资高于计算机科学系教师的教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name <span class="keyword">as</span> TeacherName</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary </span><br><span class="line">    <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>使用元组变量（tuple variable）T和S区分同一关系的不同实例</li><li>AS关键字是可选的：<code>instructor as T ≡ instructor T</code></li></ul><p><strong>为什么需要元组变量？</strong></p><ul><li>涉及对instructor关系中salary属性的不同值的比较</li><li>利用T和S区分不同的instructor实例</li><li>实现了对同一属性的不同值的比较</li></ul><h3 id="5-2-字符串操作">5.2 字符串操作</h3><p><strong>模式匹配运算符LIKE：</strong></p><p><strong>特殊字符：</strong></p><ol><li><strong>百分号（%）</strong> - 匹配任意子串</li><li><strong>下划线（_）</strong> - 匹配任意单个字符</li></ol><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找姓名中包含&quot;dar&quot;的所有教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%dar%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配字符串&quot;100%&quot;</span></span><br><span class="line"><span class="keyword">like</span> <span class="string">&#x27;100\%&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span></span><br><span class="line"><span class="comment">-- 使用反斜杠作为转义字符</span></span><br></pre></td></tr></table></figure><p><strong>模式示例：</strong></p><ul><li><code>'Intro%'</code> - 匹配以&quot;Intro&quot;开头的任意字符串</li><li><code>'%Comp%'</code> - 匹配包含&quot;Comp&quot;作为子串的任意字符串</li><li><code>'___'</code> - 匹配恰好三个字符的字符串</li><li><code>'___%'</code> - 匹配至少三个字符的字符串</li></ul><p><strong>注意：模式是大小写敏感的</strong></p><p><strong>其他字符串操作：</strong></p><ul><li>连接（使用&quot;||&quot;）</li><li>大小写转换</li><li>查找字符串长度</li><li>提取子串等</li></ul><h3 id="5-3-结果排序（ORDER-BY）">5.3 结果排序（ORDER BY）</h3><p><strong>基本排序：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按字母顺序列出所有教师姓名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><p><strong>指定排序方向：</strong></p><ul><li><strong>DESC</strong> - 降序</li><li><strong>ASC</strong> - 升序（默认）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p><strong>多属性排序：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_name, name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不同属性不同排序方向</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_name <span class="keyword">asc</span>, name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>性能警告：</strong> 避免使用数据库的ORDER BY操作对大数据文件进行排序，这可能导致严重的性能问题。</p><hr><h2 id="六、集合操作（Set-Operations）">六、集合操作（Set Operations）</h2><h3 id="6-1-基本集合操作">6.1 基本集合操作</h3><p>SQL支持三种集合操作：</p><ul><li><strong>UNION</strong> - 并集（∪）</li><li><strong>INTERSECT</strong> - 交集（∩）</li><li><strong>EXCEPT</strong> - 差集（−）</li></ul><p><strong>特点：</strong></p><ul><li>自动消除重复</li><li>要保留重复，使用：UNION ALL, INTERSECT ALL, EXCEPT ALL</li></ul><h3 id="6-2-UNION（并集）">6.2 UNION（并集）</h3><p><strong>示例：查找2017年秋季或2018年春季开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-INTERSECT（交集）">6.3 INTERSECT（交集）</h3><p><strong>示例：查找既在2017年秋季又在2018年春季开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><h3 id="6-4-EXCEPT（差集）">6.4 EXCEPT（差集）</h3><p><strong>示例：查找2017年秋季开设但2018年春季没有开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="七、空值处理（NULL-Values）">七、空值处理（NULL Values）</h2><h3 id="7-1-NULL的含义">7.1 NULL的含义</h3><p>NULL表示：</p><ul><li>未知值（unknown value）</li><li>值不存在（value does not exist）</li></ul><h3 id="7-2-算术运算与NULL">7.2 算术运算与NULL</h3><p>任何涉及NULL的算术表达式结果都是NULL</p><ul><li>例如：5 + null = null</li></ul><h3 id="7-3-检查NULL值">7.3 检查NULL值</h3><p>使用 <strong>IS NULL</strong> 谓词：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找工资为NULL的所有教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="7-4-比较运算与NULL">7.4 比较运算与NULL</h3><p>SQL将涉及NULL的任何比较结果视为<strong>未知（unknown）</strong></p><ul><li>5 &lt; null → unknown</li><li>null &lt;&gt; null → unknown</li><li>null = null → unknown</li></ul><h3 id="7-5-布尔运算与UNKNOWN">7.5 布尔运算与UNKNOWN</h3><p><strong>AND运算：</strong></p><ul><li>true AND unknown = unknown</li><li>false AND unknown = false</li><li>unknown AND unknown = unknown</li></ul><p><strong>OR运算：</strong></p><ul><li>unknown OR true = true</li><li>unknown OR false = unknown</li><li>unknown OR unknown = unknown</li></ul><p><strong>WHERE子句处理：</strong></p><ul><li>如果WHERE子句的谓词求值为unknown，则视为false</li></ul><p>⚠️ <strong>实际应用建议：</strong> 避免引入属性NULL值，防止索引失效；使用默认值（default value）替代。</p><hr><h2 id="八、聚合函数（Aggregate-Functions）">八、聚合函数（Aggregate Functions）</h2><h3 id="8-1-基本聚合函数">8.1 基本聚合函数</h3><p>聚合函数对列的值进行操作，但返回单个值：</p><ol><li><strong>avg</strong> - 平均值</li><li><strong>min</strong> - 最小值</li><li><strong>max</strong> - 最大值</li><li><strong>sum</strong> - 求和</li><li><strong>count</strong> - 计数</li></ol><h3 id="8-2-聚合函数语法">8.2 聚合函数语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;A1, A2, ..., Ai&#125;, ag_fun(Ai<span class="operator">+</span><span class="number">1</span>), ..., ag_fun(Ai<span class="operator">+</span>k)</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P1</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> A1, A2, ..., Ai</span><br><span class="line">    [<span class="keyword">having</span> P2]]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>P1 定义在 r1, r2, ..., rm 的所有属性上</li><li>P2 定义在 A1, A2, ..., Ai 上，作为GROUP BY的约束</li></ul><h3 id="8-3-基本聚合示例">8.3 基本聚合示例</h3><p><strong>示例1：计算平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例2：计算教师数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> teaches</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure><p><strong>示例3：计算元组数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> course</span><br></pre></td></tr></table></figure><h3 id="8-4-GROUP-BY子句">8.4 GROUP BY子句</h3><p><strong>功能：</strong> 将结果按指定属性分组</p><p><strong>示例：查找每个系的平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure><p><strong>重要规则：</strong> SELECT子句中在聚合函数外的属性必须出现在GROUP BY列表中</p><p><strong>错误示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误！ID不在GROUP BY中</span></span><br><span class="line"><span class="keyword">select</span> dept_name, ID, <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure><p><strong>NULL值处理：</strong> 除了count(*)外，所有聚合操作都忽略聚合属性上的NULL值元组</p><h3 id="8-5-HAVING子句">8.5 HAVING子句</h3><p><strong>功能：</strong> 对分组形成后的结果应用条件</p><p><strong>示例：查找平均工资超过42000的所有系的名称和平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><p><strong>WHERE vs HAVING：</strong></p><ul><li><strong>WHERE</strong> - 在形成分组<strong>之前</strong>应用谓词</li><li><strong>HAVING</strong> - 在形成分组<strong>之后</strong>应用谓词</li></ul><hr><h2 id="九、嵌套子查询（Nested-Subqueries）">九、嵌套子查询（Nested Subqueries）</h2><h3 id="9-1-基本概念">9.1 基本概念</h3><p>子查询是嵌套在另一个查询中的SELECT-FROM-WHERE表达式。</p><p><strong>可以出现的位置：</strong></p><ol><li><strong>FROM子句：</strong> ri可以被任何有效的子查询替换</li><li><strong>WHERE子句：</strong> P可以被表达式替换：<code>B &lt;operation&gt; (subquery)</code></li><li><strong>SELECT子句：</strong> Ai可以被生成单个值的子查询替换</li></ol><p>⚠️ <strong>优化建议：</strong> 从SQL优化角度，避免使用低效的嵌套查询，改为FROM子句中的多表连接，便于DBMS查询优化。</p><h3 id="9-2-集合成员资格（Set-Membership）">9.2 集合成员资格（Set Membership）</h3><p><strong>IN运算符：</strong></p><p><strong>示例1：查找2009年秋季和2010年春季都开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">    <span class="keyword">and</span> course_id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>NOT IN运算符：</strong></p><p><strong>示例2：查找2009年秋季开设但2010年春季未开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">    <span class="keyword">and</span> course_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong></p><ol><li>从头至尾依次扫描section中每一行</li><li>对每一行：<ul><li>判断其semester、year是否满足查询条件</li><li>执行嵌入在WHERE子句中的SELECT查询</li><li>判断本行的course_id是否在结果集合中</li></ul></li></ol><p>⚠️ <strong>性能问题：</strong></p><ul><li>嵌入式查询可能执行效率较低</li><li>被嵌入的SELECT子句可能多次重复执行</li><li>实际应用中应尽量避免membership等嵌入式查询</li></ul><p><strong>改进方案（多表连接）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 低效的嵌套查询</span></span><br><span class="line"><span class="keyword">select</span> SECTOR_ID, PHYCELLID</span><br><span class="line"><span class="keyword">from</span> tbPCIAssignment</span><br><span class="line"><span class="keyword">where</span> EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span> <span class="keyword">and</span> ASSIGN_ID<span class="operator">=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">and</span> SECTOR_ID <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> N_SECTOR_ID</span><br><span class="line">        <span class="keyword">from</span> tbAdjCell</span><br><span class="line">        <span class="keyword">where</span> S_SECTOR_ID<span class="operator">=</span><span class="string">&#x27;58617-1&#x27;</span> <span class="keyword">and</span> N_EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高效的多表连接</span></span><br><span class="line"><span class="keyword">select</span> A.SECTOR_ID, A.PHYCELLID</span><br><span class="line"><span class="keyword">from</span> tbPCIAssignment <span class="keyword">as</span> A, tbAdjCell <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">where</span> A.EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span> </span><br><span class="line">    <span class="keyword">and</span> A.ASSIGN_ID<span class="operator">=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">and</span> A.SECTOR_ID<span class="operator">=</span>B.N_SECTOR_ID</span><br><span class="line">    <span class="keyword">and</span> B.S_SECTOR_ID<span class="operator">=</span><span class="string">&#x27;58617-1&#x27;</span></span><br></pre></td></tr></table></figure><p>根据课件中的SQL Server执行计划，性能比为 <strong>77:23</strong>（嵌套查询更慢）</p><p><strong>其他IN用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 名字不是&quot;Mozart&quot;也不是&quot;Einstein&quot;的教师</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;Mozart&#x27;</span>, <span class="string">&#x27;Einstein&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组IN</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id, semester, <span class="keyword">year</span></span><br><span class="line">    <span class="keyword">from</span> teaches</span><br><span class="line">    <span class="keyword">where</span> teaches.ID <span class="operator">=</span> <span class="number">10101</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-3-集合比较-SOME子句">9.3 集合比较 - SOME子句</h3><p><strong>示例：查找工资高于生物系至少一名教师的教师姓名</strong></p><p><strong>方法1：使用元组变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary </span><br><span class="line">    <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法2：使用SOME</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>SOME的定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &lt;comp&gt; some r ⟺ ∃t ∈ r such that (F &lt;comp&gt; t)</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;comp&gt;</code> 可以是：&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;</p><p><strong>示例：</strong></p><ul><li><code>(5 &lt; some {0, 5, 6})</code> = true（因为5 &lt; 6）</li><li><code>(5 &lt; some {0, 5})</code> = false</li><li><code>(5 = some {0, 5})</code> = true（因为5 = 5）</li><li><code>(5 ≠ some {0, 5})</code> = true（因为5 ≠ 0）</li></ul><p><strong>重要等价关系：</strong></p><ul><li><code>(= some)</code> ≡ <code>in</code></li><li>但是 <code>(&lt;&gt; some)</code> ≠ <code>not in</code></li></ul><h3 id="9-4-集合比较-ALL子句">9.4 集合比较 - ALL子句</h3><p><strong>示例：查找工资高于生物系所有教师的教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>ALL的定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &lt;comp&gt; all r ⟺ ∀t ∈ r (F &lt;comp&gt; t)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><ul><li><code>(5 &lt; all {0, 5, 6})</code> = false（因为5不小于5）</li><li><code>(5 &lt; all {6, 10, 4})</code> = false（因为5不小于4）</li><li><code>(5 = all {4, 5})</code> = false</li><li><code>(5 ≠ all {4, 6})</code> = true（5不等于4且5不等于6）</li></ul><p><strong>重要等价关系：</strong></p><ul><li><code>(&lt;&gt; all)</code> ≡ <code>not in</code></li><li>但是 <code>(= all)</code> ≠ <code>in</code></li></ul><h3 id="9-5-测试空关系-EXISTS">9.5 测试空关系 - EXISTS</h3><p><strong>EXISTS构造：</strong> 如果参数子查询非空，则返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists r ⟺ r ≠ ∅</span><br><span class="line">not exists r ⟺ r = ∅</span><br></pre></td></tr></table></figure><p><strong>集合包含：</strong></p><ul><li>X − Y = ∅ ⟺ X ⊆ Y</li><li>X ⊆ Y ⟺ (X − Y) = ∅ ⟺ not exists (X except Y)</li></ul><p><strong>示例1：查找2017年秋季和2018年春季都开设的所有课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> section <span class="keyword">as</span> T</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span></span><br><span class="line">            <span class="keyword">and</span> S.course_id <span class="operator">=</span> T.course_id</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li><strong>相关名（Correlation name）</strong> - 外部查询中的变量S</li><li><strong>相关子查询（Correlated subquery）</strong> - 内部查询</li></ul><h3 id="9-6-NOT-EXISTS的使用">9.6 NOT EXISTS的使用</h3><p><strong>示例：查找选修了生物系开设的所有课程的学生</strong></p><p><strong>思路：</strong></p><ul><li>X = 生物系开设的所有课程</li><li>Y = 某个特定学生选修的所有课程</li><li>判断Y是否包含X（即 X ⊆ Y）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    (<span class="keyword">select</span> course_id</span><br><span class="line">     <span class="keyword">from</span> course</span><br><span class="line">     <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">    (<span class="keyword">select</span> T.course_id</span><br><span class="line">     <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">     <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-7-测试重复元组-UNIQUE">9.7 测试重复元组 - UNIQUE</h3><p><strong>UNIQUE测试：</strong> 检查子查询结果中是否有重复元组</p><p><strong>示例：查找2017年最多开设一次的所有课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_id</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span> (</span><br><span class="line">    <span class="keyword">select</span> R.course_id</span><br><span class="line">    <span class="keyword">from</span> section <span class="keyword">as</span> R</span><br><span class="line">    <span class="keyword">where</span> T.course_id <span class="operator">=</span> R.course_id</span><br><span class="line">        <span class="keyword">and</span> R.year <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-8-FROM子句中的子查询">9.8 FROM子句中的子查询</h3><p><strong>示例：查找平均工资超过42000美元的系的平均教师工资</strong></p><p><strong>方法1：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, avg_salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> avg_salary <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><p><strong>方法2：给派生关系命名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, avg_salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">) <span class="keyword">as</span> dept_avg(dept_name, avg_salary)</span><br><span class="line"><span class="keyword">where</span> avg_salary <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><h3 id="9-9-WITH子句（推荐使用）">9.9 WITH子句（推荐使用）</h3><p><strong>功能：</strong> WITH子句提供了一种定义临时关系的方法，该关系仅在包含WITH子句的查询中可用。</p><p><strong>优点：</strong> 将复杂查询分解为若干步，每个视图定义一个中间计算结果，逻辑清晰。</p><p><strong>示例1：查找所有预算最高的系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max_budget(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">max</span>(budget)</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> department.name</span><br><span class="line"><span class="keyword">from</span> department, max_budget</span><br><span class="line"><span class="keyword">where</span> department.budget <span class="operator">=</span> max_budget.value</span><br></pre></td></tr></table></figure><p><strong>示例2：查找总工资大于所有系平均总工资的系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> dept_total(dept_name, <span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">),</span><br><span class="line">dept_total_avg(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">from</span> dept_total</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> dept_total, dept_total_avg</span><br><span class="line"><span class="keyword">where</span> dept_total.value <span class="operator">&gt;</span> dept_total_avg.value</span><br></pre></td></tr></table></figure><h3 id="9-10-标量子查询（Scalar-Subquery）">9.10 标量子查询（Scalar Subquery）</h3><p><strong>定义：</strong> 标量子查询是期望返回单个值的子查询</p><p><strong>示例：列出所有系及其教师数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,</span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">     <span class="keyword">from</span> instructor</span><br><span class="line">     <span class="keyword">where</span> department.dept_name <span class="operator">=</span> instructor.dept_name)</span><br><span class="line">    <span class="keyword">as</span> num_instructors</span><br><span class="line"><span class="keyword">from</span> department</span><br></pre></td></tr></table></figure><hr><h2 id="十、数据库修改（Database-Modification）">十、数据库修改（Database Modification）</h2><h3 id="10-1-删除操作（DELETE）">10.1 删除操作（DELETE）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p><strong>示例1：删除所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>示例2：删除财务系的所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例3：删除Watson楼中系的所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">    <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例4：删除工资低于平均工资的教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>执行顺序问题：</strong></p><ul><li>删除元组时，平均工资会改变</li><li>解决方案：<ol><li>首先计算avg(salary)并找到所有要删除的元组</li><li>然后删除所有找到的元组（不重新计算平均值或重新测试元组）</li></ol></li></ul><h3 id="10-2-插入操作（INSERT）">10.2 插入操作（INSERT）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> r</span><br><span class="line"><span class="keyword">values</span> (v1, v2, ..., vn)</span><br></pre></td></tr></table></figure><p><strong>示例1：添加新课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> course</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;CS-437&#x27;</span>, <span class="string">&#x27;Database Systems&#x27;</span>, <span class="string">&#x27;Comp. Sci.&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价写法</span></span><br><span class="line"><span class="keyword">insert into</span> course (course_id, title, dept_name, credits)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;CS-437&#x27;</span>, <span class="string">&#x27;Database Systems&#x27;</span>, <span class="string">&#x27;Comp. Sci.&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>示例2：插入NULL值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;3003&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p><strong>示例3：从查询结果插入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将音乐系中获得超过144学分的每个学生</span></span><br><span class="line"><span class="comment">-- 聘为音乐系教师，工资为18000美元</span></span><br><span class="line"><span class="keyword">insert into</span> instructor</span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name, <span class="number">18000</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span> <span class="keyword">and</span> total_cred <span class="operator">&gt;</span> <span class="number">144</span></span><br></pre></td></tr></table></figure><p><strong>重要特性：</strong> SELECT-FROM-WHERE语句在将其结果插入关系之前完全求值。否则像下面的查询会导致问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> table1 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1</span><br></pre></td></tr></table></figure><h3 id="10-3-更新操作（UPDATE）">10.3 更新操作（UPDATE）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> r</span><br><span class="line"><span class="keyword">set</span> A <span class="operator">=</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p><strong>示例1：给所有教师加薪5%</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br></pre></td></tr></table></figure><p><strong>示例2：条件更新</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给工资低于70000的教师加薪5%</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">70000</span></span><br></pre></td></tr></table></figure><p><strong>示例3：使用子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给工资低于平均工资的教师加薪5%</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例4：多条件更新的顺序问题</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 工资超过100000的教师加薪3%，其他加薪5%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方案1：两个UPDATE语句（顺序很重要！）</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="comment">-- 如果顺序相反，初始工资为99999的教师会被加薪两次</span></span><br></pre></td></tr></table></figure><h3 id="10-4-条件更新-CASE语句">10.4 条件更新 - CASE语句</h3><p><strong>更好的解决方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">then</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line">    <span class="keyword">else</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="10-5-使用标量子查询更新">10.5 使用标量子查询更新</h3><p><strong>示例：重新计算并更新所有学生的tot_creds值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line"><span class="keyword">set</span> tot_cred <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">    <span class="keyword">from</span> takes, course</span><br><span class="line">    <span class="keyword">where</span> takes.course_id <span class="operator">=</span> course.course_id</span><br><span class="line">        <span class="keyword">and</span> S.ID <span class="operator">=</span> takes.ID</span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>问题：</strong> 对于没有选修任何课程的学生，tot_creds会被设置为NULL</p><p><strong>改进方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line"><span class="keyword">set</span> tot_cred <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> <span class="built_in">sum</span>(credits) <span class="keyword">is</span> <span class="keyword">not null</span> <span class="keyword">then</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">        <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">from</span> takes, course</span><br><span class="line">    <span class="keyword">where</span> takes.course_id <span class="operator">=</span> course.course_id</span><br><span class="line">        <span class="keyword">and</span> S.ID <span class="operator">=</span> takes.ID</span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="10-6-多表更新">10.6 多表更新</h3><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给定：</span></span><br><span class="line"><span class="comment">-- Student(S#, Sname, age, ..., C#, Grade, ...)</span></span><br><span class="line"><span class="comment">-- SGrade(S#, C#, Grade)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 利用SGrade的内容更新Student</span></span><br><span class="line"><span class="keyword">update</span> Student <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">set</span> Grade <span class="operator">=</span> B.Grade</span><br><span class="line"><span class="keyword">from</span> SGrade <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">where</span> A.S# <span class="operator">=</span> B.S# <span class="keyword">and</span> A.C# <span class="operator">=</span> B.C#</span><br></pre></td></tr></table></figure><hr><h2 id="十一、重要实践建议">十一、重要实践建议</h2><h3 id="11-1-命名规范">11.1 命名规范</h3><ul><li>在Oracle等大型商用数据库系统中，关系表的属性名只能取英文名，不支持中文属性名</li><li>SQL Server支持中英文属性名</li><li>开发大型数据库应用时，程序访问的关系表属性名（最好）取英文名，便于应用程序的可移植性</li><li>准确表示英文专业术语</li></ul><h3 id="11-2-性能优化建议">11.2 性能优化建议</h3><p>**1. 避免使用SELECT ***</p><ul><li>实际应用中避免在SELECT子句中使用*</li><li>防止索引失效</li></ul><p><strong>2. 避免属性NULL值</strong></p><ul><li>实际应用中避免引入属性NULL值</li><li>防止索引失效</li><li>用默认值（default value）替代</li></ul><p><strong>3. 控制FROM子句的表数量</strong></p><ul><li>FROM子句包括多个关系表时，要在WHERE子句中加入连接条件</li><li>防止出现代价高昂的多表笛卡尔积操作</li><li>频繁执行的SQL查询，FROM子句的表个数不要过多（不超过4个表）</li><li>如需查询涉及≥4张表，考虑将数据进行合并</li></ul><p><strong>4. 避免低效的嵌套查询</strong></p><ul><li>从SQL优化角度，避免使用低效的嵌套查询</li><li>改为FROM子句中的多表连接，便于DBMS查询优化</li></ul><p><strong>5. 避免大数据排序</strong></p><ul><li>不要用数据库的ORDER BY操作对大数据文件进行排序</li></ul><p><strong>6. 优先使用WITH子句</strong></p><ul><li>使用WITH子句将复杂查询分解为多步</li><li>逻辑清晰，便于维护</li></ul><hr><h2 id="总结">总结</h2><p>这份课件涵盖了SQL的核心知识点：</p><ol><li><strong>数据定义（DDL）</strong> - 创建、修改、删除表结构</li><li><strong>基本查询（DML）</strong> - SELECT-FROM-WHERE结构</li><li><strong>高级查询</strong> - 连接、聚合、分组、排序</li><li><strong>集合操作</strong> - UNION、INTERSECT、EXCEPT</li><li><strong>嵌套查询</strong> - IN、EXISTS、ALL、SOME等</li><li><strong>数据修改</strong> - INSERT、DELETE、UPDATE</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>§2 关系模型 简读</title>
      <link href="/2025/12/22/DB_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/22/DB_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1>第一编：关系模型（Relational Model）【Chapter 2】</h1><blockquote><p>这是<strong>整个数据库理论的根基</strong><br>👉 不懂这一章，SQL 永远是“背语法”</p></blockquote><hr><h2 id="一、什么是关系数据库（Relational-Database）">一、什么是关系数据库（Relational Database）</h2><h3 id="1️⃣-为什么需要关系模型？">1️⃣ 为什么需要关系模型？</h3><p>在关系模型之前：</p><ul><li>层次模型（树）</li><li>网状模型（图）</li></ul><p>👉 <strong>问题</strong>：</p><ul><li>数据结构复杂</li><li>查询困难</li><li>程序和数据强耦合</li></ul><p><strong>关系模型的革命性思想</strong>：</p><blockquote><p>👉 用“数学集合 + 二维表”来抽象现实世界的数据</p></blockquote><hr><h3 id="2️⃣-关系数据库的基本组成">2️⃣ 关系数据库的基本组成</h3><blockquote><p><strong>定义（直观）</strong><br>一个关系数据库 = <strong>若干张二维表（关系）</strong></p></blockquote><table><thead><tr><th>表元素</th><th>数学/理论名词</th><th>数据库名词</th></tr></thead><tbody><tr><td>行</td><td>Tuple</td><td>元组</td></tr><tr><td>列</td><td>Attribute</td><td>属性</td></tr><tr><td>表</td><td>Relation</td><td>关系</td></tr><tr><td>表头</td><td>Schema</td><td>模式</td></tr><tr><td>表中数据</td><td>Instance</td><td>实例</td></tr></tbody></table><hr><h2 id="二、关系模型的严格定义（Formal-Definition）">二、关系模型的严格定义（Formal Definition）</h2><blockquote><p>这是<strong>考试最爱考定义的地方</strong></p></blockquote><hr><h3 id="1️⃣-属性（Attribute）">1️⃣ 属性（Attribute）</h3><ul><li><p>属性表示一个“对象的特征”</p></li><li><p>用符号表示：</p>A_1, A_2, \dots, A_n</li></ul><p>📌 例子（instructor）：</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>salary</li></ul><hr><h3 id="2️⃣-域（Domain）">2️⃣ 域（Domain）</h3><blockquote><p><strong>域 = 属性允许取值的集合</strong></p></blockquote>D_i = { 所有 A_i 可以取的合法值 }<p>📌 例：</p><ul><li>ID ∈ char(5)</li><li>salary ∈ numeric(8,2)</li></ul><p>⚠ <strong>重要思想</strong>：</p><ul><li>域是<strong>类型 + 约束</strong></li><li>域 ≠ 属性名</li></ul><hr><h3 id="3️⃣-关系模式（Relation-Schema）">3️⃣ 关系模式（Relation Schema）</h3><blockquote><p><strong>描述“表长什么样”</strong></p></blockquote><p>形式化定义：</p>R = (A_1, A_2, \dots, A_n)<p>📌 instructor 模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instructor(ID, name, dept_name, salary)</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-关系实例（Relation-Instance）">4️⃣ 关系实例（Relation Instance）</h3><blockquote><p><strong>描述“表里现在有什么数据”</strong></p></blockquote><ul><li>某一时刻关系中所有元组的集合</li><li>随时间变化</li></ul><p>📌 记忆口诀：</p><blockquote><p><strong>模式是蓝图，实例是照片</strong></p></blockquote><hr><h3 id="5️⃣-元组（Tuple）">5️⃣ 元组（Tuple）</h3><ul><li>一个元组 = 一行数据</li><li>是属性 → 值的映射</li></ul><p>数学上可理解为函数：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mo>(</mo><msub><mi>A</mi><mi>i</mi></msub><mo>)</mo><mo>→</mo><msub><mi>D</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t(A_i) \rightarrow D_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord mathit">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">→</span><span class="mord"><span class="mord mathit" style="margin-right:0.02778em;">D</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.02778em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathit">i</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span></span></p><hr><h2 id="三、属性的本质约束（非常重要）">三、属性的本质约束（非常重要）</h2><hr><h3 id="1️⃣-原子性（Atomicity）——第一范式（1NF）">1️⃣ 原子性（Atomicity）——第一范式（1NF）</h3><blockquote><p><strong>每个属性值必须是“不可再分”的</strong></p></blockquote><p>❌ 错误示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone = &#123;138..., 139...&#125;</span><br></pre></td></tr></table></figure><p>✅ 正确做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone1, phone2</span><br></pre></td></tr></table></figure><p>📌 原因：</p><ul><li>保证运算有明确语义</li><li>简化查询与比较</li></ul><p>📌 考试常问：</p><blockquote><p>“为什么关系模型要求 1NF？”</p></blockquote><hr><h3 id="2️⃣-Null-值（Null）">2️⃣ Null 值（Null）</h3><blockquote><p>Null ≠ 0<br>Null ≠ 空字符串</p></blockquote><p>Null 表示：</p><ul><li>值未知</li><li>值不存在</li><li>尚未填写</li></ul><hr><h4 id="⚠-Null-带来的三大问题（老师重点）">⚠ Null 带来的三大问题（老师重点）</h4><p>1️⃣ 比较失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary <span class="operator">=</span> <span class="keyword">null</span>   <span class="comment">-- 永远为 unknown</span></span><br></pre></td></tr></table></figure><p>2️⃣ 三值逻辑（true / false / unknown）</p><p>3️⃣ 索引可能失效（工程大忌）</p><p>👉 <strong>工程建议</strong>：</p><ul><li>尽量用 default value 替代 null</li></ul><hr><h2 id="四、关系的“无序性”（常被忽略但很重要）">四、关系的“无序性”（常被忽略但很重要）</h2><h3 id="1️⃣-元组无序">1️⃣ 元组无序</h3><ul><li>表中行没有先后顺序</li><li>存储顺序 ≠ 逻辑顺序</li></ul><hr><h3 id="2️⃣-属性无序">2️⃣ 属性无序</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>3</mn></msub><mo>)</mo><mo>=</mo><mo>(</mo><msub><mi>A</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">(A_1, A_2, A_3) = (A_3, A_1, A_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span><span class="mrel">=</span><span class="mopen">(</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">3</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mclose">)</span></span></span></span></span></p><p>👉 这就是为什么 <strong>SQL 必须写列名</strong></p><hr><h2 id="五、数据库模式与实例（Schema-vs-Instance）">五、数据库模式与实例（Schema vs Instance）</h2><h3 id="1️⃣-数据库模式（Database-Schema）">1️⃣ 数据库模式（Database Schema）</h3><ul><li>全局逻辑结构</li><li>不随时间变化</li></ul><hr><h3 id="2️⃣-数据库实例（Database-Instance）">2️⃣ 数据库实例（Database Instance）</h3><ul><li>某一时刻所有关系实例的集合</li><li>会随插入、删除、更新变化</li></ul><p>📌 考试爱问对比题</p><hr><h2 id="六、键（Keys）——关系模型的核心">六、键（Keys）——关系模型的核心</h2><hr><h3 id="1️⃣-超键（Super-Key）">1️⃣ 超键（Super Key）</h3><blockquote><p>能唯一标识元组的<strong>属性集合</strong></p></blockquote><p>形式化定义：</p><p>若</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>≠</mo><msub><mi>t</mi><mn>2</mn></msub><mo>⇒</mo><msub><mi>t</mi><mn>1</mn></msub><mo>[</mo><mi>K</mi><mo>]</mo><mo>≠</mo><msub><mi>t</mi><mn>2</mn></msub><mo>[</mo><mi>K</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">t_1 \neq t_2 \Rightarrow t_1[K] \neq t_2[K]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">≠</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mrel">⇒</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mclose">]</span><span class="mrel">≠</span><span class="mord"><span class="mord mathit">t</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">[</span><span class="mord mathit" style="margin-right:0.07153em;">K</span><span class="mclose">]</span></span></span></span></span></p><p>则 K 是超键</p><p>📌 示例：</p><ul><li>{ID}</li><li>{ID, name}</li><li>{ID, dept_name}</li></ul><p>⚠ 超键可能冗余</p><hr><h3 id="2️⃣-候选键（Candidate-Key）">2️⃣ 候选键（Candidate Key）</h3><blockquote><p><strong>最小的超键</strong></p></blockquote><ul><li>去掉任何属性就不唯一</li></ul><p>📌 instructor：</p><ul><li>{ID} ✔</li><li>{ID, name} ❌（非最小）</li></ul><hr><h3 id="3️⃣-主键（Primary-Key）">3️⃣ 主键（Primary Key）</h3><blockquote><p>从候选键中选一个作为“官方身份标识”</p></blockquote><p><strong>约束：</strong></p><ul><li>唯一</li><li>非空</li></ul><p>📌 工程经验（老师强调）：</p><ul><li>尽量用 int / float</li><li>避免 varchar / datetime</li></ul><hr><h3 id="4️⃣-主属性-非主属性">4️⃣ 主属性 &amp; 非主属性</h3><ul><li>主属性：出现在候选键中的属性</li><li>非主属性：其余</li></ul><p>📌 后续 <strong>函数依赖、范式分解</strong> 的基础</p><hr><h2 id="七、外键（Foreign-Key）与参照完整性">七、外键（Foreign Key）与参照完整性</h2><hr><h3 id="1️⃣-外键定义（极重要）">1️⃣ 外键定义（极重要）</h3><p>若：</p><ul><li>r1 中属性 X</li><li>X 是 r2 的主键</li></ul><p>则：</p><blockquote><p>X 是 <strong>r1 引用 r2 的外键</strong></p></blockquote><hr><h3 id="2️⃣-参照完整性（Referential-Integrity）">2️⃣ 参照完整性（Referential Integrity）</h3><blockquote><p><strong>外键值必须在被参照表中存在</strong></p></blockquote><p>📌 instructor.dept_name ∈ department.dept_name</p><hr><h3 id="3️⃣-数据导入顺序（实践必考）">3️⃣ 数据导入顺序（实践必考）</h3><ol><li>先插入被参照表（department）</li><li>再插入参照表（instructor）</li></ol><p>否则违反外键约束</p><hr><h2 id="八、关系代数（Relational-Algebra）">八、关系代数（Relational Algebra）</h2><blockquote><p>SQL 的<strong>数学基础</strong></p></blockquote><hr><h3 id="1️⃣-查询语言分类">1️⃣ 查询语言分类</h3><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>过程式</td><td>说明“怎么做”</td></tr><tr><td>声明式</td><td>说明“要什么”</td></tr></tbody></table><p>关系代数 = 过程式<br>SQL = 声明式（但底层会转成代数）</p><hr><h3 id="2️⃣-六个基本运算（必须会）">2️⃣ 六个基本运算（必须会）</h3><table><thead><tr><th>运算</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>选择</td><td>σ</td><td>行筛选</td></tr><tr><td>投影</td><td>π</td><td>列筛选</td></tr><tr><td>笛卡尔积</td><td>×</td><td>表组合</td></tr><tr><td>并</td><td>∪</td><td>合并</td></tr><tr><td>差</td><td>−</td><td>排除</td></tr><tr><td>重命名</td><td>ρ</td><td>改名</td></tr></tbody></table><hr><h3 id="3️⃣-选择（σ）">3️⃣ 选择（σ）</h3>\sigma_{条件}(r)<ul><li>条件是布尔表达式</li><li>支持：<ul><li>比较</li><li>逻辑组合</li><li>属性间比较</li></ul></li></ul><p>📌 SQL 对应：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-投影（π）">4️⃣ 投影（π）</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>π</mi><mrow><msub><mi>A</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>A</mi><mn>2</mn></msub></mrow></msub><mo>(</mo><mi>r</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\pi_{A_1,A_2}(r)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">π</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">1</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mpunct">,</span><span class="mord"><span class="mord mathit">A</span><span class="vlist"><span style="top:0.15em;margin-right:0.07142857142857144em;margin-left:0em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-scriptstyle scriptscriptstyle cramped"><span class="mord mathrm">2</span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mclose">)</span></span></span></span></span></p><ul><li>只保留指定列</li><li>自动去重</li></ul><p>📌 SQL 对应：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ...</span><br></pre></td></tr></table></figure><hr><h3 id="5️⃣-连接-笛卡尔积-选择">5️⃣ 连接 = 笛卡尔积 + 选择</h3><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>σ</mi><mrow><mi>r</mi><mi mathvariant="normal">.</mi><mi>A</mi><mo>=</mo><mi>s</mi><mi mathvariant="normal">.</mi><mi>B</mi></mrow></msub><mo>(</mo><mi>r</mi><mo>×</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\sigma_{r.A = s.B}(r \times s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height:0.75em;"></span><span class="strut bottom" style="height:1em;vertical-align:-0.25em;"></span><span class="base displaystyle textstyle uncramped"><span class="mord"><span class="mord mathit" style="margin-right:0.03588em;">σ</span><span class="vlist"><span style="top:0.15em;margin-right:0.05em;margin-left:-0.03588em;"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span><span class="reset-textstyle scriptstyle cramped"><span class="mord scriptstyle cramped"><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mord mathrm">.</span><span class="mord mathit">A</span><span class="mrel">=</span><span class="mord mathit">s</span><span class="mord mathrm">.</span><span class="mord mathit" style="margin-right:0.05017em;">B</span></span></span></span><span class="baseline-fix"><span class="fontsize-ensurer reset-size5 size5"><span style="font-size:0em;">​</span></span>​</span></span></span><span class="mopen">(</span><span class="mord mathit" style="margin-right:0.02778em;">r</span><span class="mbin">×</span><span class="mord mathit">s</span><span class="mclose">)</span></span></span></span></span></p><p>👉 自然连接是语法糖</p><hr><h3 id="6️⃣-查询等价与优化">6️⃣ 查询等价与优化</h3><ul><li>结果相同 ≠ 代价相同</li><li>数据库会重写查询</li></ul><p>📌 <strong>这是后面“查询优化”的起点</strong></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 关系模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自注意力机制_简读</title>
      <link href="/2025/12/16/self-attention%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/16/self-attention%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="引言：自注意力——序列建模的新范式">引言：自注意力——序列建模的新范式</h2><p>在深度学习的发展历程中，序列建模一直是极具挑战性的任务。从早期的循环神经网络（RNN）到长短期记忆网络（LSTM），研究者们不断探索如何有效捕捉序列数据中的依赖关系。然而，这些模型都存在一个根本性局限：<strong>顺序处理机制</strong>导致计算无法并行化，且难以建模长距离依赖。</p><p>自注意力（Self-Attention）机制的提出彻底改变了这一局面。它不仅解决了长距离依赖问题，还实现了高效的并行计算，成为自然语言处理、计算机视觉乃至语音处理等领域的核心技术。</p><p>本文将深入剖析自注意力机制的多个关键方面，包括其如何编码位置信息、如何应对超长序列、以及与卷积神经网络和循环神经网络的对比，为你呈现一个完整的自注意力知识图谱。</p><h2 id="位置编码：为无位置感知的自注意力注入顺序信息">位置编码：为无位置感知的自注意力注入顺序信息</h2><h3 id="问题的本质：自注意力的“位置盲”">问题的本质：自注意力的“位置盲”</h3><p>自注意力机制有一个根本特性：<strong>它对输入序列中元素的绝对位置或相对顺序没有内在感知</strong>。这是因为自注意力通过查询（Query）、键（Key）和值（Value）的交互计算注意力权重时，仅考虑内容相似性，而不考虑位置关系。</p><p>这就造成了一个有趣的现象：对于自注意力层来说，序列中第一个位置和最后一个位置在计算上是完全平等的——“天涯若比邻”，所有位置之间的距离在计算上没有差别。但在许多实际任务中，位置信息至关重要。例如在词性标注任务中，动词很少出现在句首；在语音识别中，声音信号的时序关系是关键线索。</p><h3 id="解决方案：将位置信息显式编码">解决方案：将位置信息显式编码</h3><p>为了解决这一问题，研究者们提出了<strong>位置编码（Positional Encoding）</strong>。其核心思想是为序列中的每个位置分配一个独特的向量表示，然后将这个位置向量与对应位置的输入向量相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 = 内容向量 + 位置向量</span><br></pre></td></tr></table></figure><p>这样，自注意力机制在计算时就能同时考虑内容信息和位置信息。</p><h3 id="位置编码的实现方式">位置编码的实现方式</h3><p>位置编码有多种实现方法：</p><ol><li><p><strong>正弦/余弦函数编码</strong>：这是Transformer原始论文采用的方法，使用不同频率的正弦和余弦函数生成位置向量：</p><ul><li><p>优点：可以处理任意长度的序列，且能捕捉相对位置关系</p></li><li><p>原理：不同维度使用不同频率的三角函数，使模型能够学习到相对位置关系</p></li></ul></li><li><p><strong>可学习的位置编码</strong>：将位置编码作为可训练参数，随模型一同学习</p><ul><li><p>优点：更加灵活，能够适应特定任务的需求</p></li><li><p>缺点：无法处理训练时未见过的序列长度</p></li></ul></li><li><p><strong>相对位置编码</strong>：关注元素之间的相对距离而非绝对位置</p><ul><li><p>优点：更好地泛化到不同长度的序列</p></li><li><p>应用：在诸如Transformer-XL等改进模型中使用</p></li></ul></li></ol><p>位置编码的研究仍在继续，最新研究如《Learning to Encode Position for Transformer with Continuous Dynamical Model》探索了更动态、更灵活的位置编码方法。</p><h2 id="截断自注意力：应对超长序列的计算挑战">截断自注意力：应对超长序列的计算挑战</h2><h3 id="问题的根源：二次方复杂度">问题的根源：二次方复杂度</h3><p>标准自注意力机制有一个显著的计算瓶颈：<strong>计算复杂度与序列长度的二次方成正比</strong>。具体来说，对于一个长度为L的序列，自注意力需要计算L×L的注意力矩阵，这在序列很长时会带来巨大的计算和内存开销。</p><p>例如在语音处理任务中，1秒的声音信号可能对应100个向量，5秒就是500个向量，普通的一句话就可能包含数千个向量。如此长的序列会使注意力矩阵变得极其庞大，难以处理和训练。</p><h3 id="截断自注意力：局部关注的智慧">截断自注意力：局部关注的智慧</h3><p>截断自注意力（Truncated Self-Attention）是一种有效的解决方案。其核心思想是：<strong>让每个位置只关注其周围有限范围内的其他位置，而不是整个序列</strong>。</p><p>这种设计基于一个合理的假设：在许多任务中，一个元素的语义主要受其邻近元素影响。例如在语音识别中，要识别某个位置的音素，通常只需要考虑其前后一定时间范围内的声音信号即可。</p><h3 id="实现方式与优势">实现方式与优势</h3><p>截断自注意力通过限制每个查询向量只能与一定窗口内的键向量交互来实现：</p><ul><li><p><strong>固定窗口</strong>：每个位置只关注前后k个位置</p></li><li><p><strong>动态窗口</strong>：根据内容动态决定关注范围</p></li><li><p><strong>分层注意力</strong>：结合不同粒度的注意力，先粗后细</p></li></ul><p>截断自注意力的主要优势包括：</p><ol><li><p>将计算复杂度从O(L²)降低到O(L×k)，其中k是窗口大小</p></li><li><p>大幅减少内存消耗</p></li><li><p>在某些任务上可能提高性能，因为避免了无关远程信息的干扰</p></li></ol><h2 id="自注意力与卷积神经网络：两种视觉架构的对比">自注意力与卷积神经网络：两种视觉架构的对比</h2><h3 id="图像作为向量序列：统一的数据视角">图像作为向量序列：统一的数据视角</h3><p>传统上，图像处理是卷积神经网络（CNN）的领域。但如果我们换个视角，将图像视为一个向量序列，就能用自注意力处理图像任务：</p><p>一张H×W×C的图像可以看作H×W个C维向量组成的序列，其中每个向量对应一个像素（或一个图像块）。基于这种表示，自注意力可以直接应用于图像数据，相关研究包括《Self-Attention Generative Adversarial Networks》和《End-to-End Object Detection with Transformers》。</p><h3 id="感受野：人工划定与自动学习">感受野：人工划定与自动学习</h3><p>卷积神经网络和自注意力在如何处理图像信息上有着根本区别：</p><ul><li><p><strong>卷积神经网络</strong>：每个神经元只处理局部感受野内的信息，感受野的大小和形状是<strong>人工预设</strong>的</p></li><li><p><strong>自注意力</strong>：每个位置可以与图像中任何其他位置交互，有效感受野是<strong>自动学习</strong>的</p></li></ul><p>这种差异带来一个有趣的结论：<strong>卷积神经网络实际上是自注意力的一个特例</strong>。当自注意力被约束为只关注局部区域，并且权重共享时，它就退化成了卷积操作。这一观点在论文《On the Relationship between Self-attention and Convolutional Layers》中得到了数学上的严格证明。</p><h3 id="灵活性与数据需求的平衡">灵活性与数据需求的平衡</h3><p>自注意力的灵活性既是优势也是挑战：</p><ul><li><p><strong>灵活性</strong>：自注意力能够自适应地学习不同位置之间的关系模式，不受固定几何结构的限制</p></li><li><p><strong>数据需求</strong>：更高的灵活性意味着更大的假设空间，需要更多数据来学习有效的模式</p></li></ul><p>谷歌的研究《An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale》清楚地展示了这一权衡：</p><ul><li><p>在小规模数据（1000万张图像）上，CNN表现更好</p></li><li><p>在大规模数据（3亿张图像）上，Vision Transformer超越CNN</p></li></ul><p>这一现象揭示了深度学习中一个普遍规律：<strong>更灵活的模型需要更多数据来发挥潜力</strong>。在实际应用中，可以根据数据量的大小选择合适的架构，或者将两者结合（如Conformer模型同时使用自注意力和卷积）。</p><h2 id="自注意力与循环神经网络：序列建模的范式转变">自注意力与循环神经网络：序列建模的范式转变</h2><h3 id="处理序列的两种哲学">处理序列的两种哲学</h3><p>循环神经网络（RNN）和自注意力代表了序列建模的两种不同哲学：</p><ul><li><p><strong>RNN的迭代哲学</strong>：逐步处理序列，将历史信息压缩到隐藏状态中，具有内在的顺序性</p></li><li><p><strong>自注意力的并行哲学</strong>：同时处理所有位置，通过注意力机制直接建立任意两个位置的联系</p></li></ul><p>即使是最先进的双向RNN，要捕捉长距离依赖也需要将信息“记忆”并传递很长距离，而自注意力可以“天涯若比邻”，直接建立远程连接。</p><h3 id="并行化：效率的革命性提升">并行化：效率的革命性提升</h3><p>自注意力相对于RNN最显著的优势是<strong>完全并行化</strong>：</p><ul><li><p>RNN必须顺序处理序列，每一步都依赖前一步的输出</p></li><li><p>自注意力可以同时计算所有位置的表示，极大提高了计算效率</p></li></ul><p>这一差异在现代硬件（尤其是GPU/TPU）上具有重大意义，使得训练大规模序列模型成为可能。</p><h3 id="信息流动的差异">信息流动的差异</h3><p>两种架构在信息流动路径上也存在根本差异：</p><ul><li><p>RNN的信息流动是<strong>序列化的</strong>，信息从早期位置流向后期位置需要经过多个时间步</p></li><li><p>自注意力的信息流动是<strong>全连接的</strong>，任何两个位置都可以直接交互</p></li></ul><p>这使得自注意力特别适合建模复杂的长距离依赖，而这是许多序列任务（如机器翻译、文档理解）的关键。</p><h2 id="自注意力在图数据上的应用">自注意力在图数据上的应用</h2><p>图数据（节点和边组成的结构）也可以使用自注意力处理，此时需要做适当调整：</p><ol><li><p><strong>节点作为向量</strong>：图中的每个节点可以表示为一个向量</p></li><li><p><strong>边作为注意力约束</strong>：已有的边信息可以作为先验，约束注意力计算只发生在相连的节点之间</p></li><li><p><strong>图神经网络作为受限自注意力</strong>：这种受限的自注意力本质上就是图神经网络（GNN）的一种形式</p></li></ol><p>这种方法的优势在于结合了数据驱动的关系学习和先验的结构信息，在社交网络分析、分子结构建模等领域有广泛应用。</p><h2 id="自注意力的变体与未来方向">自注意力的变体与未来方向</h2><p>随着研究的深入，出现了多种自注意力变体，旨在解决标准自注意力的各种限制：</p><ol><li><p><strong>效率优化型</strong>：如Linformer、Performer、Reformer等，通过数学近似或架构改进降低计算复杂度</p></li><li><p><strong>长序列专用型</strong>：如Longformer、BigBird等，专门处理极长序列</p></li><li><p><strong>领域适配型</strong>：针对特定任务或数据类型的定制化注意力机制</p></li></ol><p>《Long Range Arena: A Benchmark for Efficient Transformers》系统比较了各种自注意力变体，《Efficient Transformers: A Survey》则全面综述了这一领域的发展。</p><h2 id="结语：自注意力——深度学习的通用构件">结语：自注意力——深度学习的通用构件</h2><p>自注意力机制已经从自然语言处理领域的一个创新，发展成为深度学习的通用构件。它的核心价值在于：</p><ol><li><p><strong>灵活性</strong>：能够适应各种类型的数据和任务</p></li><li><p><strong>可并行性</strong>：充分利用现代计算硬件</p></li><li><p><strong>长距离建模能力</strong>：直接建立远程依赖关系</p></li><li><p><strong>可解释性</strong>：注意力权重提供了模型决策的透明视图</p></li></ol><p>然而，自注意力并非万能钥匙。它的高计算复杂度、对大规模数据的依赖以及在某些任务上的次优表现，都是需要继续研究的问题。未来的方向可能包括更高效的注意力机制、更好的位置编码方法，以及与其他架构（如CNN、GNN）的更深度融合。</p><p>自注意力的发展历程体现了深度学习研究的一个核心理念：<strong>寻找既强大又高效的通用归纳偏置</strong>。它不仅仅是一个技术工具，更是一种重新思考序列建模、关系建模乃至结构化数据建模的新范式。随着研究的不断深入，我们有理由相信，自注意力及其变体将继续推动人工智能技术的发展边界。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Self Attention </tag>
            
            <tag> 自注意力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM简读</title>
      <link href="/2025/12/16/RNN%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/16/RNN%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="本质与起源">本质与起源</h2><p>长短期记忆网络（Long Short-Term Memory，LSTM）是一种特殊的循环神经网络架构，其根本目的在于解决传统RNN在处理长序列数据时面临的<strong>长期依赖学习难题</strong>。这个问题的核心在于：当序列长度增加时，信息在时间维度上反向传播时会出现<strong>梯度动力学失衡</strong>——梯度要么指数级衰减至近乎消失，无法影响早期时间步的参数更新；要么指数级增长引发数值爆炸，导致训练崩溃。</p><p>LSTM的哲学智慧在于：<strong>将信息存储与信息处理分离</strong>。它通过引入一个独立且受保护的记忆通道，使得信息能够在时间轴上稳定传输，同时通过可学习的门控机制来决定信息的进出与留存，从而模拟人类记忆的“选择性记忆”与“选择性遗忘”过程。</p><h2 id="核心架构的深度剖析">核心架构的深度剖析</h2><h3 id="记忆元（Memory-Cell）：信息的持久化载体">记忆元（Memory Cell）：信息的持久化载体</h3><p>记忆元是LSTM的灵魂所在，它是一个贯穿时间序列的连续状态流。与传统RNN中隐藏状态不断被覆写不同，记忆元的设计允许信息以<strong>累积而非替换</strong>的方式存在。这种设计带来了两个关键优势：</p><ol><li><p><strong>梯度流的持续性</strong>：由于记忆元的更新是加法操作（旧状态的部分保留加上新输入的部分添加），梯度在反向传播时可以通过记忆元路径稳定流动，避免了传统RNN中因矩阵连乘导致的梯度指数衰减或爆炸。</p></li><li><p><strong>信息生命周期管理</strong>：记忆元中的信息可以理论上无限期保存，除非被主动遗忘。这使网络能够捕捉跨越数百甚至数千时间步的依赖关系。</p></li></ol><h3 id="门控机制的三位一体">门控机制的三位一体</h3><p>LSTM的精妙之处在于它的三个门，每个门都是一个独立的神经网络层，使用sigmoid激活函数将输入映射到[0,1]区间，实现对信息流的<strong>精细化模拟调控</strong>。</p><p><strong>遗忘门（Forget Gate）</strong> 控制历史记忆的留存比例。其设计哲学是：并非所有过去信息都值得保留。门输出值接近1表示“完全记住”，接近0表示“完全遗忘”。这里有一个重要的认知反直觉点：在LSTM的术语中，“遗忘门开启”意味着保留记忆，“关闭”意味着遗忘。这种设计源于sigmoid函数的输出特性，通常通过偏置初始化来设定默认行为（正偏置使门倾向于开启）。</p><p><strong>输入门（Input Gate）</strong> 控制新信息的准入程度。它决定当前时间步的候选信息有多少值得纳入长期记忆。候选信息本身由tanh函数生成，提供非线性变换并将值规范到[-1,1]范围。输入门与候选信息的逐元素相乘实现了对新信息的过滤和加权。</p><p><strong>输出门（Output Gate）</strong> 控制记忆对外的显露程度。记忆元内部状态经过tanh规范化后，由输出门调节最终暴露给外部网络的部分。这种设计使LSTM能够区分“内部存储”与“对外发布”，增加了信息处理的层次性。</p><h3 id="信息流动的完整动力学">信息流动的完整动力学</h3><p>记忆元的更新遵循一个物理直观的方程：<strong>新记忆 = 旧记忆 × 遗忘比例 + 新信息 × 输入比例</strong>。这种形式本质上是<strong>带门控的残差连接</strong>，它确保了：</p><ul><li><p>当遗忘门接近1且输入门接近0时，记忆几乎完全保留，新信息被阻挡</p></li><li><p>当遗忘门接近0且输入门接近1时，记忆被清空，新信息完全写入</p></li><li><p>在大多数中间状态，实现新旧信息的平滑融合</p></li></ul><p>隐藏状态的生成则是内部记忆的受限视图：记忆元状态经tanh压缩后，由输出门调制输出。这种分离使得LSTM可以存储不直接输出的中间信息，增加了网络的表征能力。</p><h2 id="训练动态与优化考量">训练动态与优化考量</h2><h3 id="梯度行为的根本改善">梯度行为的根本改善</h3><p>LSTM解决梯度消失问题的核心机制在于其<strong>加法更新路径</strong>。在反向传播时，梯度可以通过记忆元路径以近似常数的形式回溯，因为：</p><p>∂c_t/∂c_{t-1} = f_t + (其他项)</p><p>只要遗忘门f_t保持在合理范围（如接近1），这个导数就不会消失。相比之下，传统RNN的对应项是权重矩阵的连乘，极易导致梯度指数变化。</p><p>然而，LSTM并未完全消除梯度爆炸风险。门控信号本身的生成涉及权重矩阵乘法，这些路径仍可能出现大梯度。因此，<strong>梯度裁剪</strong>成为LSTM训练的标配技术，通过限制梯度范数防止参数更新步长过大。</p><h3 id="参数初始化策略">参数初始化策略</h3><p>LSTM的初始状态设定深刻影响其学习行为：</p><ul><li><p>遗忘门偏置通常初始化为正数（如+1），确保初始阶段倾向于保留记忆</p></li><li><p>输入门偏置可初始化为零或负数，避免早期过度写入</p></li><li><p>输出门偏置可初始化为零或负数，控制信息释放节奏</p></li><li><p>权重矩阵常用正交初始化或Xavier初始化，保持激活值方差稳定</p></li></ul><h3 id="正则化与结构变体">正则化与结构变体</h3><p>在LSTM中应用Dropout需要特别注意：<strong>时间步之间的Dropout会破坏序列依赖性</strong>，因此通常只在层间或垂直方向应用。循环Dropout（在隐藏状态间随机丢弃）需要精心设计以保持长期记忆能力。</p><p><strong>Peephole连接</strong>是LSTM的一个重要扩展，允许门控单元直接“窥视”记忆元状态。这使得门控决策不仅基于输入和前一隐藏状态，还能感知当前记忆内容，理论上增强了门控的精确性。其连接方式有三种变体：仅输入遗忘门查看前一时刻记忆，仅输出门查看当前记忆，或所有门都查看相应记忆。</p><h2 id="扩展生态与简化版本">扩展生态与简化版本</h2><p><strong>多层LSTM</strong>通过堆叠多个LSTM层构建深度时序模型。深层结构能够学习不同时间尺度上的特征：底层捕捉局部模式，高层整合全局依赖。层间连接可以是简单的传递，也可以加入跳跃连接缓解优化难度。</p><p><strong>双向LSTM</strong>同时考虑过去和未来上下文，通过前向和后向两个LSTM的隐藏状态拼接，获得每个时间步的完整语境表征。这在序列标注等任务中效果显著。</p><p><strong>门控循环单元（GRU）</strong> 作为LSTM的简化版本，将输入门和遗忘门合并为<strong>更新门</strong>，并取消了独立的记忆元与隐藏状态的分离。GRU的参数减少约1/3，训练速度更快，内存占用更少，在许多任务上与LSTM性能相当。其核心思想是“以新换旧”的更新策略：更新门同时控制旧状态的保留比例和新状态的写入比例。</p><h2 id="为什么LSTM有效：多重视角理解">为什么LSTM有效：多重视角理解</h2><p><strong>信息论视角</strong>：LSTM实现了可变速率的信息通道。遗忘门控制信息衰减率，输入门控制信息获取率，输出门控制信息释放率。这三个速率参数通过数据学习自适应调整，使网络在信息保存与更新间达到动态平衡。</p><p><strong>动力学系统视角</strong>：记忆元构成一个缓慢变化的动态系统，门控机制引入快变子系统。这种时间尺度分离使网络能同时捕捉快速变化的模式特征和缓慢演变的语境信息。</p><p><strong>算法视角</strong>：LSTM本质上学习了一个可微分的记忆管理算法。它通过门控函数实现了类似“if-else”的条件逻辑，但完全可微分，能够通过梯度下降端到端优化。</p><p><strong>认知科学视角</strong>：LSTM的结构与工作记忆模型有内在相似性。记忆元类似于工作记忆的存储缓冲区，门控机制类似于注意力的分配过程，输出门类似于回忆提取过程。</p><h2 id="实践中的深刻洞察">实践中的深刻洞察</h2><ol><li><p><strong>LSTM不是万能的</strong>：对于极长序列（如数千步），即使LSTM也可能出现梯度动力学问题。此时可能需要结合注意力机制或层次化处理。</p></li><li><p><strong>计算代价与收益</strong>：LSTM的4倍参数增长带来显著的表达能力和记忆容量提升，但也增加了过拟合风险。需要根据数据规模和任务复杂度权衡。</p></li><li><p><strong>时间方向的不可逆性</strong>：标准LSTM严格遵循时间因果律，这在许多时序预测任务中是优势，但也限制了某些场景下对双向上下文的同时利用。</p></li><li><p><strong>记忆与泛化的张力</strong>：LSTM的强大记忆能力可能使其过度拟合训练数据的特定时间模式，需要适当的正则化引导其学习通用时序动态。</p></li></ol><h2 id="总结升华">总结升华</h2><p>LSTM的突破性贡献在于：<strong>它将记忆本身作为可学习的对象</strong>。传统RNN将记忆视为隐藏状态演化的副产品，而LSTM明确构建了一个受保护的记忆通道，并通过可微分的门控机制赋予网络管理自身记忆的能力。</p><p>这种架构创新背后的核心洞见是：<strong>长期依赖学习的关键不是避免梯度消失，而是提供梯度流动的稳定通路</strong>。LSTM通过加法更新路径和门控调制，创造了一条梯度可以无衰减回溯的“时间高速公路”，同时又不丧失对信息流动的精细控制。</p><p>更深层地看，LSTM的成功反映了神经网络设计的一个重要原则：<strong>好的归纳偏置应该编码在架构中，而非完全依赖数据学习</strong>。LSTM的架构本身编码了“信息应该被选择性地记忆和遗忘”这一关于时序数据本质的先验知识，这使得它在有限数据下也能学习有效的长期依赖。</p><p>从RNN到LSTM的演进，标志着循环神经网络从简单的时序函数逼近器，进化为具有内在记忆管理能力的复杂动态系统。这一进化不仅解决了长期依赖的技术难题，更开辟了神经网络模拟高阶认知功能的新可能。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活感悟</title>
      <link href="/2025/12/10/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD2/"/>
      <url>/2025/12/10/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD2/</url>
      
        <content type="html"><![CDATA[<p>！！！</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Yuejin的个人介绍</title>
      <link href="/2025/12/09/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/12/09/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>我是<em>Yuejin Wu</em>，目前是BUPT本科三年级学生</p><p>专业是人工智能，还得 **考研 ** 🫥</p><p>我搭建这个<em>Yuejin's Blog</em>，记录一下我的生活，监督一下我的学习，emmm要准备考研了 😵‍💫</p><h3 id="font-color-red-简单介绍一下吧：-font"><strong><font color="red">简单介绍一下吧：</font></strong></h3><blockquote><p>我是<em>Yuejin Wu</em>, <em>BUPTer in AI</em> 🧑‍🎓</p><p>借这个博客，我将分享并同步我的学习，有太多的东西要学习：</p><ul><li>深度学习（代码好难写👨‍💻💔）</li><li>前后端开发（留条后路吧）</li><li><strong>English</strong>（我讨厌英语💩）</li><li><font color="green">考研考研考研</font> （祝我上岸吧，本校就好）🙏</li><li>再多的...下回分解吧</li></ul></blockquote><h3 id="font-color-blue-我喜欢的：-font"><strong><font color="blue">我喜欢的：</font></strong></h3><p><strong>我喜欢打篮球 🏀</strong></p><blockquote><p>我是传奇球星<em>Kobe Bryant</em>的铁杆粉丝</p><p><em>Kobe</em>粉丝的字典里没有”放弃“二字！</p><p><strong>&quot; Friends always come and go, but a champion flag will never fall ! 🏆 &quot;</strong></p><div align=left><img src="https://n.sinaimg.cn/sinacn12/211/w2048h1363/20180823/15c8-hhzsnec6055235.jpg" alt="thegreat2010!" width="600" height="400" /></div><p><strong>&quot; Second place means you are the first loser ! &quot;</strong></p><div align=left><img src="https://ts1.tc.mm.bing.net/th/id/R-C.f343e7606d3ee999bb7cca72021a3f25?rik=lnVs0YbiLAQp7A&riu=http%3a%2f%2ffile.qiumiwu.com%2fimgs%2f20200317%2f1584434559376554.jpg&ehk=4gVfPuk%2f8b4EryaVLHOjjjFlgAEaS0wuCz3XfHYua6I%3d&risl=&pid=ImgRaw&r=0" alt="thegreat2010!" width="600" height="400" /></div><p><strong>&quot; Somebody has to win, so why not be me? &quot;</strong></p><div align=left><img src="https://ts1.tc.mm.bing.net/th/id/R-C.4ac3ba3869c279ad8620c3492d3e61eb?rik=45oONH9yVyeLaQ&riu=http%3a%2f%2fimg.mp.sohu.com%2fupload%2f20171219%2f8e635a7bd4cf4ed4ae4573be8b7f9a16_th.JPG&ehk=w%2bHL%2fvomMJ2jw8XXdj087b%2bix3UAgV4WenYhYnCVXEc%3d&risl=&pid=ImgRaw&r=0" alt="thegreat2010!" width="600" height="400" /></div><p><strong><font size=5><font color="purple">Mamba Out !</font><font color="orange">  Mamba Forever!</font></font></strong></p></blockquote><p><strong>我喜欢听的歌挺多的</strong></p><p>**歌剧音乐剧🎷、流行通俗🎸我都喜欢 **</p><p><strong>钟爱<em>Lana Del Ray</em></strong></p><blockquote><p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.QkE_dEvv2a_1rfpSvc4NLwAAAA?w=166&h=180&c=7&r=0&o=7&dpr=2.2&pid=1.7&rm=3" alt="lanadelray专辑 的图像结果" style="zoom: 68.5%;" /><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.-RL4R68dMgjYkp05BCqXWQHaHa?w=185&h=187&c=7&r=0&o=7&dpr=2.2&pid=1.7&rm=3 =" alt="lanadelray专辑 的图像结果" style="zoom:50%;" /></p><p><em><strong>2023年夏至今，百听不厌，YYDS</strong></em> 🥰</p></blockquote><h3 id="font-color-broen-未来规划-font"><font color="broen">未来规划</font></h3><p>emmm 好好干 好好学 🧘‍♂️</p><p>争取读个研，进大厂，争取干算法岗</p><p>好吧，现在是北京时间 00：29 ， 2025.12.10</p><p>下次再聊，晚安~🤞</p><div align=middle><img src="https://www.bupt.edu.cn/__local/C/8E/F7/EE902059AE32E0E6325EFEE8F46_B2D41D06_CD58.png" alt="thegreat2010!" width="600" height="150" /></div>]]></content>
      
      
      <categories>
          
          <category> about </category>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI Platform部分技术栈</title>
      <link href="/2025/12/08/AIpiatform_%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2025/12/08/AIpiatform_%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>以下是为我<strong>零基础新手</strong>量身定制的<strong>容器平台技术栈学习路线</strong>。</p><h2 id="🎯-零基础学习路线图（总览）">🎯 <strong>零基础学习路线图（总览）</strong></h2><p><strong>预计周期：3-4个月（按每周10小时学习时间）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一阶段：基础认知与Linux (1-2周)</span><br><span class="line">第二阶段：Docker核心技能 (3-4周)  </span><br><span class="line">第三阶段：存储与网络基础 (2-3周)</span><br><span class="line">第四阶段：平台实战与理解 (2-3周)</span><br><span class="line">第五阶段：扩展与进阶 (持续学习)</span><br></pre></td></tr></table></figure><hr><h2 id="📘-第一阶段：基础认知与Linux-1-2周">📘 <strong>第一阶段：基础认知与Linux (1-2周)</strong></h2><h3 id="目标：建立计算机基础认知，学会基本的Linux操作"><strong>目标</strong>：建立计算机基础认知，学会基本的Linux操作</h3><p><strong>学习内容</strong>：</p><ol><li><p><strong>计算机基础概念</strong></p><ul><li>什么是操作系统、进程、内存、硬盘</li><li>什么是IP地址、端口、网络协议</li><li>[B站搜索]：“计算机基础入门” 系列视频</li></ul></li><li><p><strong>Linux基础命令（最重要！）</strong></p><ul><li>如何在命令行中移动、查看文件</li><li>如何安装软件、管理权限</li><li><strong>推荐学习资源</strong>：<ul><li>[B站]：搜索“Linux基础命令10小时”</li><li>[网站]：菜鸟教程Linux教程</li><li><strong>动手练习</strong>：在Windows上安装WSL2，或Mac使用终端</li></ul></li></ul></li></ol><p><strong>每日任务示例</strong>：</p><ul><li>Day1：学习 <code>ls</code>, <code>cd</code>, <code>pwd</code> 命令</li><li>Day2：学习 <code>mkdir</code>, <code>rm</code>, <code>cp</code> 命令</li><li>Day3：学习 <code>cat</code>, <code>vim</code>, <code>nano</code> 编辑文件</li><li>Day4：学习 <code>ps</code>, <code>top</code> 查看进程</li><li>Day5：学习 <code>chmod</code>, <code>chown</code> 权限管理</li></ul><hr><h2 id="🐳-第二阶段：Docker核心技能-3-4周">🐳 <strong>第二阶段：Docker核心技能 (3-4周)</strong></h2><h3 id="目标：掌握Docker基本使用，理解容器概念"><strong>目标</strong>：掌握Docker基本使用，理解容器概念</h3><p><strong>学习路径</strong>：</p><ol><li><p><strong>Docker是什么？（第1周）</strong></p><ul><li>看这个视频：[B站]“Docker通俗易懂解释”</li><li>安装Docker Desktop（Windows/Mac一键安装）</li><li>运行第一个容器：<code>docker run hello-world</code></li></ul></li><li><p><strong>Docker基础操作（第2周）</strong></p><ul><li>学习核心命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull     # 下载镜像</span><br><span class="line">docker run      # 运行容器</span><br><span class="line">docker ps       # 查看运行中的容器</span><br><span class="line">docker stop     # 停止容器</span><br><span class="line">docker rm       # 删除容器</span><br><span class="line">docker images   # 查看镜像</span><br></pre></td></tr></table></figure></li><li>完成一个小练习：用Docker运行一个Nginx网站</li></ul></li><li><p><strong>Dockerfile与镜像制作（第3周）</strong></p><ul><li>理解镜像和容器的关系</li><li>学习编写简单的Dockerfile</li><li>自己制作一个包含Python环境的镜像</li></ul></li><li><p><strong>数据持久化（第4周）</strong></p><ul><li>理解Volume的概念</li><li>学习将本地文件夹挂载到容器内</li><li>练习：创建一个MySQL容器，将数据保存在本地</li></ul></li></ol><p><strong>推荐资源</strong>：</p><ul><li>[视频]：B站“Docker入门到实战”</li><li>[交互式学习]：Docker官方教程（有中文）</li><li>[书籍]：《Docker入门与实践》（电子版）</li></ul><hr><h2 id="💾-第三阶段：存储与网络基础-2-3周">💾 <strong>第三阶段：存储与网络基础 (2-3周)</strong></h2><h3 id="目标：理解平台中的存储和网络设计"><strong>目标</strong>：理解平台中的存储和网络设计</h3><p><strong>学习内容</strong>：</p><ol><li><p><strong>NFS基础（第1周）</strong></p><ul><li>什么是NFS（网络文件系统）</li><li>为什么需要共享存储</li><li>简单搭建一个NFS服务体验</li></ul></li><li><p><strong>理解平台存储架构</strong></p><ul><li>重新阅读文档中的“容器磁盘 vs NFS云盘”</li><li>画图理解：容器内部 <code>/root</code> 目录是如何挂载NFS的</li><li>理解为什么conda环境可以共享</li></ul></li><li><p><strong>网络基础（第2-3周）</strong></p><ul><li>什么是IP、端口、网关</li><li>Docker网络基础：桥接网络、端口映射</li><li>理解 <code>-p 8080:80</code> 是什么意思</li><li>学习简单的网络故障排查</li></ul></li></ol><p><strong>动手实验</strong>：</p><ul><li>在本地搭建两个虚拟机，配置NFS共享</li><li>创建一个Docker容器，挂载NFS共享目录</li></ul><hr><h2 id="🏗️-第四阶段：平台实战与理解-2-3周">🏗️ <strong>第四阶段：平台实战与理解 (2-3周)</strong></h2><h3 id="目标：将所学应用到实际平台理解中"><strong>目标</strong>：将所学应用到实际平台理解中</h3><p><strong>学习步骤</strong>：</p><ol><li><p><strong>平台架构图绘制</strong></p><ul><li>根据文档，画出平台的简化架构图</li><li>标记出：用户 → Web界面 → Gateway → Host → Container → NFS</li><li>理解数据流向</li></ul></li><li><p><strong>实际操作平台</strong></p><ul><li>申请一个测试容器</li><li>在容器内安装软件（用apt）</li><li>在/root目录下创建文件，理解NFS共享</li><li>用conda创建一个Python环境</li></ul></li><li><p><strong>资源监控初识</strong></p><ul><li>学习使用 <code>htop</code>, <code>nvidia-smi</code>, <code>df -h</code> 等命令</li><li>理解平台文档中的“CPU、内存、GPU监控”</li></ul></li><li><p><strong>问题排查基础</strong></p><ul><li>容器启动失败怎么办？</li><li>网络不通怎么办？</li><li>磁盘空间不足怎么办？</li></ul></li></ol><hr><h2 id="🚀-第五阶段：扩展与进阶-持续学习">🚀 <strong>第五阶段：扩展与进阶 (持续学习)</strong></h2><h3 id="目标：深入理解平台高级特性"><strong>目标</strong>：深入理解平台高级特性</h3><p><strong>可选学习方向</strong>：</p><ol><li><strong>容器编排</strong>：学习Docker Compose、Kubernetes基础</li><li><strong>监控系统</strong>：学习Prometheus + Grafana</li><li><strong>CI/CD</strong>：学习GitLab CI或GitHub Actions</li><li><strong>安全基础</strong>：学习容器安全、权限控制</li></ol><hr><h2 id="📚-学习资源推荐（零基础友好）">📚 <strong>学习资源推荐（零基础友好）</strong></h2><h3 id="视频教程（B站）："><strong>视频教程（B站）</strong>：</h3><ol><li>【Linux】“Linux基础命令全集” - 黑马程序员</li><li>【Docker】“Docker容器技术全集” - 尚硅谷</li><li>【网络】“计算机网络基础” - 湖科大教书匠</li></ol><h3 id="网站-文档："><strong>网站/文档</strong>：</h3><ol><li><strong>菜鸟教程</strong>（<a href="http://runoob.com">runoob.com</a>）- Linux/Docker基础</li><li><strong>Docker官方文档</strong>（有中文）- 最权威</li><li><strong>MDN Web文档</strong> - 学习网络基础知识</li></ol><h3 id="实践平台："><strong>实践平台</strong>：</h3><ol><li><strong>本地</strong>：Docker Desktop + WSL2</li><li><strong>在线实验</strong>：Katacoda（免费Docker实验环境）</li><li><strong>云服务器</strong>：阿里云/腾讯云学生优惠（最低配置即可）</li></ol><hr><h2 id="🎯-具体学习计划表（前2个月）">🎯 <strong>具体学习计划表（前2个月）</strong></h2><table><thead><tr><th>周数</th><th>学习重点</th><th>每日任务（约1-2小时）</th><th>完成标志</th></tr></thead><tbody><tr><td>第1周</td><td>Linux基础</td><td>学习5个命令+练习</td><td>能在命令行中自如移动、查看文件</td></tr><tr><td>第2周</td><td>Docker安装与运行</td><td>安装Docker，运行3种不同容器</td><td>成功运行Nginx、Redis、MySQL容器</td></tr><tr><td>第3周</td><td>Docker命令精通</td><td>掌握10个核心命令</td><td>能独立管理容器生命周期</td></tr><tr><td>第4周</td><td>Dockerfile实践</td><td>编写2个Dockerfile</td><td>成功构建自定义镜像</td></tr><tr><td>第5周</td><td>数据持久化</td><td>练习Volume挂载</td><td>实现容器数据持久化保存</td></tr><tr><td>第6周</td><td>NFS基础</td><td>搭建简单NFS服务</td><td>实现两台机器文件共享</td></tr><tr><td>第7周</td><td>平台理解</td><td>画出平台架构图</td><td>能向别人解释平台工作原理</td></tr><tr><td>第8周</td><td>平台实战</td><td>在平台上完成一个任务</td><td>成功创建容器、安装软件、保存数据</td></tr></tbody></table><hr><h2 id="❓-遇到困难怎么办？">❓ <strong>遇到困难怎么办？</strong></h2><ol><li><strong>谷歌/百度是你的朋友</strong>：搜索“docker如何xxx”</li><li><strong>加入技术社区</strong>：Stack Overflow、SegmentFault、知乎</li><li><strong>问问题技巧</strong>：描述你做了什么、期望结果是什么、实际结果是什么、错误信息是什么</li><li><strong>先尝试再问</strong>：自己尝试解决30分钟，解决不了再问</li></ol><hr><h2 id="💡-最重要建议">💡 <strong>最重要建议</strong></h2><ol><li><strong>动手 &gt; 看视频 &gt; 看书</strong>：技术学习必须动手</li><li><strong>不要怕犯错</strong>：容器可以随意删除重建</li><li><strong>从简单开始</strong>：先跑起来，再理解原理</li><li><strong>定期复习</strong>：每周回顾一次学过的内容</li><li><strong>找同伴</strong>：找个一起学习的伙伴互相督促</li></ol><p><strong>现在就开始</strong>：今天就在你的电脑上安装Docker，运行 <code>docker run hello-world</code>！</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI Platform </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语Plans</title>
      <link href="/2025/12/07/English/"/>
      <url>/2025/12/07/English/</url>
      
        <content type="html"><![CDATA[<h2 id="总目标：2027考研">总目标：2027考研</h2><p>目标院校</p><blockquote><p><strong>本校就好</strong></p></blockquote><p>目标分数</p><blockquote><p>英语别拖累我就好</p></blockquote><h2 id="基本规划">基本规划</h2><h3 id="跨年之前">跨年之前</h3><ul><li>多看看外刊</li><li>多听听外语</li><li>多背背单词</li></ul><h3 id="跨年之后">跨年之后</h3><ul><li>该刷题了</li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一句话在这！</title>
      <link href="/2025/12/06/THE%20FIRST/"/>
      <url>/2025/12/06/THE%20FIRST/</url>
      
        <content type="html"><![CDATA[<h1>第一句话</h1><p>能看见我吗？！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/12/06/hello-world/"/>
      <url>/2025/12/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><p>这个是我留的礼物！！！</p><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
