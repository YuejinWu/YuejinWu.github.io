<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Intermediate-SQL 解读</title>
      <link href="/2025/12/24/DB_Intermediate%20SQL/"/>
      <url>/2025/12/24/DB_Intermediate%20SQL/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="数据库关系模式图示"><a href="#数据库关系模式图示" class="headerlink" title="数据库关系模式图示"></a>数据库关系模式图示</h3><p><strong>takes</strong> (学生选课)</p><ul><li>ID</li><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li><li>grade</li></ul><p><strong>section</strong> (课程开设)</p><ul><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li><li>building</li><li>room_no</li><li>time_slot_id</li></ul><p><strong>classroom</strong> (教室)</p><ul><li>building</li><li>room_no</li><li>capacity</li></ul><p><strong>time_slot</strong> (时间槽)</p><ul><li>time_slot_id</li><li>day</li><li>start_time</li><li>end_time</li></ul><p><strong>teaches</strong> (教师授课)</p><ul><li>ID</li><li>course_id</li><li>sec_id</li><li>semester</li><li>year</li></ul><p><strong>course</strong> (课程)</p><ul><li>course_id</li><li>title</li><li>dept_name</li><li>credits</li></ul><p><strong>prereq</strong> (先修课程)</p><ul><li>course_id</li><li>prereq_id</li></ul><p><strong>student</strong> (学生)</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>tot_cred</li></ul><p><strong>department</strong> (系)</p><ul><li>dept_name</li><li>building</li><li>budget</li></ul><p><strong>advisor</strong> (导师)</p><ul><li>s_id</li><li>i_id</li></ul><p><strong>instructor</strong> (教师)</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>salary</li></ul><hr><h2 id="4-1-连接表达式"><a href="#4-1-连接表达式" class="headerlink" title="4.1 连接表达式"></a>4.1 连接表达式</h2><ul><li><strong>定义：</strong> 连接操作接受两个关系，并返回结果作为另一个关系。</li><li><strong>定义：</strong> 连接操作是一种笛卡尔积，要求两个关系中的元组相匹配。</li><li>连接结果中的属性来源于：笛卡尔积 ✕ + 选择 ✔</li><li><strong>定义：连接条件</strong> – 定义两个关系中的哪些元组相匹配，以及结果中存在哪些属性。</li><li><strong>定义：连接类型</strong> – 定义如何处理每个关系中不与另一个关系中任何元组匹配的元组。</li></ul><table><thead><tr><th align="left">连接类型</th><th align="left">连接条件</th></tr></thead><tbody><tr><td align="left">内连接</td><td align="left">natural</td></tr><tr><td align="left">左外连接</td><td align="left">on &lt;谓词&gt;</td></tr><tr><td align="left">右外连接</td><td align="left">using ((A_1, A_2, \ldots, A_n))</td></tr><tr><td align="left">全外连接</td><td align="left"></td></tr></tbody></table><h3 id="1-自然连接操作"><a href="#1-自然连接操作" class="headerlink" title="(1) 自然连接操作"></a>(1) 自然连接操作</h3><p>考虑两个关系：</p><ul><li><p><strong>course</strong> (课程表)</p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td></tr></tbody></table></li><li><p><strong>prereq</strong> (先修课表)</p><table><thead><tr><th>course_id</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>CS-101</td></tr></tbody></table></li><li><p><strong>查询1：</strong> <code>select * from course natural join prereq</code></p></li><li><p><strong>查询2：</strong> <code>select * from course join prereq on course.course_id = prereq.course_id</code></p></li></ul><p><strong>course natural join prereq on course_id</strong> 的结果：</p><ul><li><em>CS-315的课程信息缺失</em>（因为prereq中没有CS-315）</li><li><em>CS-437的先修课信息缺失</em>（因为course中没有CS-437）</li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr></tbody></table><h3 id="2-外连接"><a href="#2-外连接" class="headerlink" title="(2) 外连接"></a>(2) 外连接</h3><ul><li><strong>定义：</strong> <strong>连接</strong>操作的扩展，用于避免信息丢失。</li><li>计算连接，然后将一个关系中不与另一个关系中任何元组匹配的元组添加到<strong>连接</strong>结果中。</li><li><strong>使用空值（null）。</strong></li></ul><h4 id="1-左外连接"><a href="#1-左外连接" class="headerlink" title="1. 左外连接"></a>1. 左外连接</h4><ul><li><code>course natural left outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr></tbody></table><ul><li><code>select * from course natural left outer join prereq</code></li></ul><h4 id="2-右外连接"><a href="#2-右外连接" class="headerlink" title="2. 右外连接"></a>2. 右外连接</h4><ul><li><code>course natural right outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table><ul><li><code>select * from course natural right outer join prereq</code></li></ul><h4 id="3-全外连接"><a href="#3-全外连接" class="headerlink" title="3. 全外连接"></a>3. 全外连接</h4><ul><li><code>select * from course natural full outer join prereq</code></li></ul><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table><h3 id="连接关系-–-示例"><a href="#连接关系-–-示例" class="headerlink" title="连接关系 – 示例"></a>连接关系 – 示例</h3><ul><li><p><strong>内连接与自然连接的区别</strong></p><ul><li><p><code>course inner join prereq on course.course_id = prereq.course_id</code></p><table><thead><tr><th>course.course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th><th>prereq.course_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td><td>BIO-301</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td><td>CS-190</td></tr></tbody></table></li><li><p><code>course left outer join prereq on course.course_id = prereq.course_id</code></p><table><thead><tr><th>course.course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th><th>prereq.course_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td><td>BIO-301</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td><td>CS-190</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td><td>null</td></tr></tbody></table></li></ul></li><li><p><code>course natural right outer join prereq</code></p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table></li><li><p><code>course full outer join prereq using (course_id)</code></p><table><thead><tr><th>course_id</th><th>title</th><th>dept_name</th><th>credits</th><th>prereq_id</th></tr></thead><tbody><tr><td>BIO-301</td><td>Genetics</td><td>Biology</td><td>4</td><td>BIO-101</td></tr><tr><td>CS-190</td><td>Game Design</td><td>Comp. Sci.</td><td>4</td><td>CS-101</td></tr><tr><td>CS-315</td><td>Robotics</td><td>Comp. Sci.</td><td>3</td><td>null</td></tr><tr><td>CS-347</td><td>null</td><td>null</td><td>null</td><td>CS-101</td></tr></tbody></table></li></ul><hr><h2 id="4-2-视图"><a href="#4-2-视图" class="headerlink" title="4.2 视图"></a>4.2 视图</h2><ul><li>并非所有用户都希望看到整个逻辑模型。<ul><li>例如，某人需要知道教师的姓名和所在系，但不需要知道其工资。</li><li>可以查看一个关系：<code>select ID, name, dept_name from instructor</code></li></ul></li><li><strong>定义：</strong> 任何<strong>不属于</strong> <strong>概念</strong>模型，但作为虚拟关系对用户<strong>可见</strong>的关系。</li><li>视图对某些用户隐藏了某些数据。</li></ul><h3 id="视图定义"><a href="#视图定义" class="headerlink" title="视图定义"></a>视图定义</h3><ul><li><strong>注意：</strong> 视图 &#x3D; 对一个或多个关系的投影。</li><li>视图作为虚拟表存在。</li><li><strong>注意：</strong> 视图被称为虚拟关系&#x2F;表。<ul><li>只有视图的定义存储在数据库系统中，视图的元组存储在基础关系中。</li><li>视图的求值被归结为定义该视图的关系代数表达式的求值。</li></ul></li><li><strong>注意：</strong> <em>with</em>子句和<em>create view</em>子句的区别。<ul><li>with子句创建一个临时表来存储查询结果，创建的临时表在SQL执行结束后被取消。</li></ul></li><li><strong>定义：物化视图</strong><ul><li>视图的定义和数据都存储在数据库系统中。</li></ul></li></ul><h3 id="视图定义语句"><a href="#视图定义语句" class="headerlink" title="视图定义语句"></a>视图定义语句</h3><ul><li><strong>定义：</strong> 使用 <strong>create view</strong> 语句定义视图。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> V <span class="keyword">as</span> <span class="operator">&lt;</span>查询表达式<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>其中 <code>&lt;查询表达式&gt;</code> 是SQL表达式。视图名称用 <code>V</code> 表示。</li><li>视图名称可用于引用该虚拟表。</li><li>视图定义与创建新关系不同。</li><li>视图定义导致保存一个表达式。</li></ul><h3 id="视图示例"><a href="#视图示例" class="headerlink" title="视图示例"></a>视图示例</h3><ul><li><p><strong>不包含工资的教师视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> faculty <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> ID, name, dept_name</span><br><span class="line">  <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ul><li>查找<em>Biology</em>系的所有教师：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> faculty</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>部门工资总额视图</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> departments_total_salary (dept_name, total_salary) <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line">  <span class="keyword">from</span> instructor</span><br><span class="line">  <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用其他视图定义的视图"><a href="#使用其他视图定义的视图" class="headerlink" title="使用其他视图定义的视图"></a>使用其他视图定义的视图</h3><ol><li>创建 <code>physics_fall_2019</code> 视图：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2019 <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course.course_id, sec_id, building, room_number</span><br><span class="line">  <span class="keyword">from</span> course, section</span><br><span class="line">  <span class="keyword">where</span> course.course_id <span class="operator">=</span> section.course_id</span><br><span class="line">    <span class="keyword">and</span> course.dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> section.semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> section.year <span class="operator">=</span> <span class="string">&#x27;2019&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>基于 <code>physics_fall_2019</code> 创建 <code>physics_fall_2019_watson</code> 视图：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2019_watson <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course_id, room_number</span><br><span class="line">  <span class="keyword">from</span> physics_fall_2019</span><br><span class="line">  <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>注意：</strong> 一个视图可以用于定义另一个视图的表达式。<ul><li><strong>定义：</strong> 如果视图关系 ( v_2 ) 用于定义视图关系 ( v_1 ) 的表达式中，则称 ( v_1 ) <strong>直接依赖于</strong> ( v_2 )。</li><li><strong>定义：</strong> 如果 ( v_1 ) 直接依赖于 ( v_2 )，或者存在从 ( v_1 ) 到 ( v_2 ) 的依赖路径，则称视图关系 ( v_1 ) <strong>依赖于</strong> 视图关系 ( v_2 )。</li><li><strong>定义：</strong> 如果视图关系 ( v ) 依赖于自身，则称其为<strong>递归的</strong>。</li></ul></li></ul><h3 id="视图展开"><a href="#视图展开" class="headerlink" title="视图展开"></a>视图展开</h3><p>展开查询或另一个视图中对视图的使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> physics_fall_2009_watson <span class="keyword">as</span></span><br><span class="line">  <span class="keyword">select</span> course_id, room_number</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> course.course_id, building, room_number</span><br><span class="line">        <span class="keyword">from</span> course, section</span><br><span class="line">        <span class="keyword">where</span> course.course_id <span class="operator">=</span> section.course_id</span><br><span class="line">          <span class="keyword">and</span> course.dept_name <span class="operator">=</span> <span class="string">&#x27;Physics&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> section.semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span></span><br><span class="line">          <span class="keyword">and</span> section.year <span class="operator">=</span> <span class="string">&#x27;2009&#x27;</span>)</span><br><span class="line">  <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h3><p>向 <code>faculty</code> 视图中插入新元组：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> faculty <span class="keyword">values</span> (<span class="string">&#x27;30765&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Music&#x27;</span>);</span><br></pre></td></tr></table></figure><p>此插入操作必须表示为向 <code>instructor</code> 关系中插入元组：<br><code>(&#39;30765&#39;, &#39;Green&#39;, &#39;Music&#39;, null)</code>。</p><hr><h2 id="4-3-事务"><a href="#4-3-事务" class="headerlink" title="4.3 事务"></a>4.3 事务</h2><ul><li><strong>定义：</strong> <strong>事务</strong>由一系列查询和&#x2F;或更新语句组成，它是一个工作<strong>单元</strong>。</li><li><strong>注意：</strong> ACID属性<ul><li>原子性、一致性、隔离性、持久性。</li><li>原子事务：要么完全执行，要么完全回滚，就像从未发生过一样。</li><li>与并发事务<strong>隔离</strong>。</li></ul></li><li><strong>注意：</strong> 当事务语句执行时，事务<strong>隐式</strong>开始。事务以以下语句结束：<ul><li><strong>Commit work.</strong> 更新永久生效。</li><li><strong>Rollback work.</strong> 所有已执行的更新被撤销。</li></ul></li></ul><h3 id="事务示例：银行账户转账"><a href="#事务示例：银行账户转账" class="headerlink" title="事务示例：银行账户转账"></a>事务示例：银行账户转账</h3><ul><li>初始状态：A&#x3D;1000，B&#x3D;2000，A+B&#x3D;3000</li><li>转账操作：A &#x3D; A - 50 &#x3D; 950；B &#x3D; B + 50 &#x3D; 2050；A+B &#x3D; 3000</li></ul><h3 id="T-SQL-事务示例"><a href="#T-SQL-事务示例" class="headerlink" title="T-SQL 事务示例"></a>T-SQL 事务示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> <span class="variable">@transfer_name</span> <span class="type">varchar</span>(<span class="number">10</span>)    <span class="comment">/* 事务变量定义 */</span></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@transfer_name</span> <span class="operator">=</span> <span class="string">&#x27;t-transfer-from-A-to-B&#x27;</span>    <span class="comment">/* 事务命名 */</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION <span class="variable">@transfer_name</span>    <span class="comment">/* 事务开始 */</span></span><br><span class="line">USE ACCOUNT    <span class="comment">/* 打开数据库 ACCOUNT */</span></span><br><span class="line">GO    <span class="comment">/* 将上述批 SQL 语句提交 SQL Server */</span></span><br><span class="line"><span class="keyword">UPDATE</span> A    <span class="comment">/* 修改 A 帐户 */</span></span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line"><span class="keyword">UPDATE</span> B    <span class="comment">/* 修改 B 帐户 */</span></span><br><span class="line"><span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">50</span></span><br><span class="line"><span class="keyword">WHERE</span> branch_name <span class="operator">=</span> <span class="string">&#x27;Brooklyn&#x27;</span></span><br><span class="line">GO</span><br><span class="line"><span class="keyword">COMMIT</span> TRANSACTION <span class="variable">@transfer_name</span>    <span class="comment">/* 事务提交 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-4-完整性约束"><a href="#4-4-完整性约束" class="headerlink" title="4.4 完整性约束"></a>4.4 完整性约束</h2><ul><li><strong>定义：</strong> 完整性约束防止数据库遭受意外破坏，确保对数据库的授权更改不会导致数据一致性的丢失。<ul><li>教师姓名不能为空。</li><li>任意两个教师不能有相同的教师ID。</li><li><code>course</code> 关系中的每个系名必须在 <code>department</code> 关系中有匹配的系名。</li></ul></li></ul><h3 id="完整性约束分类"><a href="#完整性约束分类" class="headerlink" title="完整性约束分类"></a>完整性约束分类</h3><table><thead><tr><th align="left">类型</th><th align="left">属性级</th><th align="left">元组级</th><th align="left">关系级</th></tr></thead><tbody><tr><td align="left">静态</td><td align="left">数据类型、数据格式、域约束、空值</td><td align="left">属性值间的约束，例如：映射基数约束</td><td align="left">实体完整性、参照完整性、函数依赖</td></tr><tr><td align="left">动态</td><td align="left">属性值或属性定义更新的约束</td><td align="left">属性值间的约束（例如：新旧值关系）</td><td align="left">事务约束：原子性、一致性、隔离性、持久性</td></tr></tbody></table><h3 id="完整性约束示例"><a href="#完整性约束示例" class="headerlink" title="完整性约束示例"></a>完整性约束示例</h3><ul><li><strong>例1：</strong> <code>Employee</code> 表中经理的工资不应低于1000美元。</li><li><strong>例2：</strong> 表 T (x, y, z)，其中 z &#x3D; x + y，z是从x和y派生的属性。</li><li><strong>例3：</strong> <code>student</code> 表中的学号不应为空。</li><li><strong>例4：</strong> 学生的年龄只能增加。</li><li><strong>例5：</strong> 当修改<code>employee</code>元组时，新工资需满足 <code>new.sal &gt; old.sal + 0.5 * age</code>。</li><li><strong>例6：</strong> 统计约束。在表中，经理的工资应该是工人工资的四倍以上。</li></ul><h3 id="单关系上的约束"><a href="#单关系上的约束" class="headerlink" title="单关系上的约束"></a>单关系上的约束</h3><ul><li>使用 <strong>create table</strong> 命令定义关系：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (A1 D1, A2 D2, ..., An Dn,</span><br><span class="line">                (integrity<span class="operator">-</span>constraint1),</span><br><span class="line">                ...,</span><br><span class="line">                (integrity<span class="operator">-</span>constraintk))</span><br></pre></td></tr></table></figure><ul><li><code>r</code> 是关系名。</li><li>每个 <code>Ai</code> 是关系 <code>r</code> 模式中的一个属性名。</li><li><code>Di</code> 是属性 <code>Ai</code> 域中值的数据类型。</li></ul></li><li><strong>注意：</strong> 完整性约束包括：<ul><li>primary key</li><li>not null</li><li>unique</li><li>check (P)，其中 <code>P</code> 是一个谓词。</li></ul></li></ul><h4 id="Not-Null-约束"><a href="#Not-Null-约束" class="headerlink" title="Not Null 约束"></a>Not Null 约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br><span class="line">budget <span class="type">numeric</span>(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">not null</span></span><br></pre></td></tr></table></figure><h4 id="Unique-约束"><a href="#Unique-约束" class="headerlink" title="Unique 约束"></a>Unique 约束</h4><ul><li><strong>定义：</strong> Unique 约束形式如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unique</span> (A1, A2, ..., Am)</span><br></pre></td></tr></table></figure><ul><li>属性 <code>A1, A2, ..., Am</code> 构成一个候选码。</li><li>允许候选码为空（与主键不同）。</li><li>示例：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> customer (</span><br><span class="line">  customer_id <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">  customer_name <span class="type">char</span>(<span class="number">15</span>),</span><br><span class="line">  customer_city <span class="type">char</span>(<span class="number">30</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (customer_id),</span><br><span class="line">  <span class="keyword">unique</span> (customer_name)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h4 id="Check-子句"><a href="#Check-子句" class="headerlink" title="Check 子句"></a>Check 子句</h4><ul><li>应用于关系声明和域声明。</li><li><code>check (P)</code>，其中 <code>P</code> 是一个谓词。</li><li>示例：确保 <code>semester</code> 属性值在 {‘Fall’, ‘Winter’, ‘Spring’, ‘Summer’} 中。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> section (</span><br><span class="line">  course_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">  sec_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">  semester <span class="type">varchar</span>(<span class="number">6</span>),</span><br><span class="line">  <span class="keyword">year</span> <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">  room_number <span class="type">varchar</span>(<span class="number">7</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (course_id, sec_id, semester, <span class="keyword">year</span>),</span><br><span class="line">  <span class="keyword">check</span> (semester <span class="keyword">in</span> (<span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>, <span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul><li><strong>参照完整性</strong><ul><li><strong>确保</strong>在一个关系的给定属性（外键）上出现的值，也出现在另一个关系的对应属性（主键）上。</li><li>如果 <code>Biology</code> 是出现在 <code>instructor</code> 关系元组中的一个系名，那么 <code>department</code> 关系中必须存在 <code>Biology</code> 的元组。</li></ul></li></ul><h4 id="参照完整性依赖"><a href="#参照完整性依赖" class="headerlink" title="参照完整性依赖"></a>参照完整性依赖</h4><ul><li><strong>定义：</strong> 设 ( r_1(R_1) ) 和 ( r_2(R_2) ) 是分别具有主键 ( K_1 ) 和 ( K_2 ) 的关系。<ul><li>例如：<br>  ( r_1: \text{department(dept_name, building, budget)} )<br>  ( r_2: \text{course(course_id, title, dept_name, credits)} )</li></ul></li><li>( R_2 ) 的子集 ( \alpha )（例如 dept_name）是一个<strong>外键</strong>（来自 ( r_2 )，<strong>course</strong>），引用关系 ( r_1 )（<strong>department</strong>）中的 ( K_1 )，如果对于 ( r_2 ) 中的每个元组 ( t_2 )，在 ( r_1 ) 中必须存在一个元组 ( t_1 )，使得 ( t_1[K_1] &#x3D; t_2[\alpha] )。</li><li><strong>注意：</strong> ( \alpha &#x3D; K_1 \subseteq R_2 )</li><li><strong>定义：</strong> 参照完整性约束被称为<strong>子集依赖</strong>，因为它可以写成：<br>( \prod_{\alpha}(r_2) \subseteq \prod_{K_1}(r_1) )<ul><li>例如：( \prod_{dept_name} (course) \subseteq \prod_{dept_name} (department) )</li></ul></li><li>表 ( r_2 ) 的外键 ( \alpha ) 引用被引用表 ( r_1 ) 的主键属性 ( K_1 )。</li><li><strong>注意：</strong> 良好的数据库设计应确保任何关系模式 ( R_2 ) 只能通过其外键引用其他关系模式 ( R_1 )。</li></ul><h3 id="参照完整性声明"><a href="#参照完整性声明" class="headerlink" title="参照完整性声明"></a>参照完整性声明</h3><ul><li>主键、候选键和外键可以在 <strong>create table</strong> 语句中指定：<ul><li><strong>primary key</strong> 子句列出构成主键的属性。</li><li><strong>unique</strong> 子句列出构成候选键的属性。</li><li><strong>foreign key</strong> 子句列出构成外键的属性以及外键引用的关系名。</li><li>外键引用被引用表的主键属性。</li></ul></li></ul><h3 id="参照完整性中的级联操作"><a href="#参照完整性中的级联操作" class="headerlink" title="参照完整性中的级联操作"></a>参照完整性中的级联操作</h3><ul><li><strong>简略声明：</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">  course_id <span class="type">char</span>(<span class="number">5</span>) <span class="keyword">primary key</span>,</span><br><span class="line">  title <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">references</span> department</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong>详细声明（支持级联）：</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> course (</span><br><span class="line">  ...</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">delete</span> cascade</span><br><span class="line">    <span class="keyword">on</span> <span class="keyword">update</span> cascade,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>级联的替代操作：set null, set default。</li><li>对被引用表 <code>department</code> 的删除&#x2F;更新操作将导致对引用表 <code>course</code> 的级联删除&#x2F;更新。</li></ul><h3 id="事务期间的完整性约束违反"><a href="#事务期间的完整性约束违反" class="headerlink" title="事务期间的完整性约束违反"></a>事务期间的完整性约束违反</h3><ul><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> person (</span><br><span class="line">  ID <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  name <span class="type">char</span>(<span class="number">40</span>),</span><br><span class="line">  mother <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  father <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (father) <span class="keyword">references</span> person(ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (mother) <span class="keyword">references</span> person(ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong>如何在具有主键-外键关联的两个表上修改数据？</strong></li><li><strong>如何插入元组而不引起约束违反？</strong><ul><li>在插入 <code>person</code> 之前先插入该人的父亲和母亲。</li><li>或者，先将 <code>father</code> 和 <code>mother</code> 设置为 <code>null</code>，在插入所有人之后再更新（如果 <code>father</code> 和 <code>mother</code> 属性声明为 <code>not null</code> 则不可行）。</li></ul></li></ul><hr><h2 id="4-5-数据类型和模式"><a href="#4-5-数据类型和模式" class="headerlink" title="4.5 数据类型和模式"></a>4.5 数据类型和模式</h2><h3 id="内置数据类型"><a href="#内置数据类型" class="headerlink" title="内置数据类型"></a>内置数据类型</h3><ul><li><strong>date：</strong> 日期，包含（4位）年、月、日。<ul><li>例如：<code>date &#39;2017-7-27&#39;</code></li></ul></li><li><strong>time：</strong> 一天中的时间，时、分、秒。<ul><li>例如：<code>time &#39;09:00:30.75&#39;</code></li></ul></li><li><strong>timestamp：</strong> 日期 + 一天中的时间。<ul><li>例如：<code>timestamp &#39;2017-7-27 09:00:30.75&#39;</code></li></ul></li><li><strong>interval：</strong> 时间段。<ul><li>如果 x 和 y 是 date 类型，那么 <code>x - y</code> 是一个 interval，其值是从日期 x 到日期 y 的天数。</li><li>例如：<code>interval &#39;1 day&#39; = &#39;2017-7-28&#39; – &#39;2017-7-27&#39;</code></li></ul></li></ul><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ul><li><strong><code>cast(e as t)</code></strong><ul><li>将字符串 <code>e</code> 转换为类型 <code>t</code>。</li><li>例如：<code>cast(&#39;2017-07-20&#39; as date)</code></li><li>例如：<code>cast(&#39;09:00:30.75&#39; as time)</code></li><li><pre><code class="language-sql">select cast(ID as numeric(5)) as inst_idfrom instructororder by inst_id<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">*   从日期或时间值中提取部分。</span><br><span class="line">*   对于日期或时间值 `d`，可以提取其各个字段。</span><br><span class="line">    *   例如：`extract(year from date &#x27;2017-07-20&#x27;) = 2017`</span><br><span class="line">    *   例如：`extract(timezone_hour from timestamp &#x27;2017-7-27 09:00:30.75&#x27;) = 09`</span><br><span class="line"></span><br><span class="line">### CAST/CONVERT 用于数据类型转换示例</span><br><span class="line"></span><br><span class="line">#### A. 同时使用 CAST 和 CONVERT</span><br><span class="line">每个示例都检索列表价格第一位是3的产品名称，并将 ListPrice 转换为 int。</span><br><span class="line">```sql</span><br><span class="line">-- 使用 CAST</span><br><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line">SELECT SUBSTRING(Name, 1, 30) AS ProductName, ListPrice</span><br><span class="line">FROM Production.Product</span><br><span class="line">WHERE CAST(ListPrice AS int) LIKE &#x27;3%&#x27;;</span><br><span class="line">GO</span><br><span class="line"></span><br><span class="line">-- 使用 CONVERT</span><br><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line">SELECT SUBSTRING(Name, 1, 30) AS ProductName, ListPrice</span><br><span class="line">FROM Production.Product</span><br><span class="line">WHERE CONVERT(int, ListPrice) LIKE &#x27;3%&#x27;;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><h4 id="B-使用包含算术运算符的-CAST"><a href="#B-使用包含算术运算符的-CAST" class="headerlink" title="B. 使用包含算术运算符的 CAST"></a>B. 使用包含算术运算符的 CAST</h4><p>将销售额除以佣金百分比，结果四舍五入到最接近的整数后转换为 int。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CAST</span>(ROUND(SalesYTD<span class="operator">/</span>CommissionPCT, <span class="number">0</span>) <span class="keyword">AS</span> <span class="type">int</span>) <span class="keyword">AS</span> <span class="string">&#x27;Computed&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> Sales.SalesPerson</span><br><span class="line"><span class="keyword">WHERE</span> CommissionPCT <span class="operator">!=</span> <span class="number">0</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h4 id="C-使用-CAST-进行连接"><a href="#C-使用-CAST-进行连接" class="headerlink" title="C. 使用 CAST 进行连接"></a>C. 使用 CAST 进行连接</h4><p>使用 CAST 连接非字符非二进制表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;The list price is &#x27;</span> <span class="operator">+</span> <span class="built_in">CAST</span>(ListPrice <span class="keyword">AS</span> <span class="type">varchar</span>(<span class="number">12</span>)) <span class="keyword">AS</span> ListPrice</span><br><span class="line"><span class="keyword">FROM</span> Production.Product</span><br><span class="line"><span class="keyword">WHERE</span> ListPrice <span class="keyword">BETWEEN</span> <span class="number">350.00</span> <span class="keyword">AND</span> <span class="number">400.00</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h4 id="D-使用-CAST-生成可读性更高的文本"><a href="#D-使用-CAST-生成可读性更高的文本" class="headerlink" title="D. 使用 CAST 生成可读性更高的文本"></a>D. 使用 CAST 生成可读性更高的文本</h4><p>使用 CAST 将 Name 列转换为 char(10) 列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">USE AdventureWorks;</span><br><span class="line">GO</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="built_in">CAST</span>(p.Name <span class="keyword">AS</span> <span class="type">char</span>(<span class="number">10</span>)) <span class="keyword">AS</span> Name, s.UnitPrice</span><br><span class="line"><span class="keyword">FROM</span> Sales.SalesOrderDetail s <span class="keyword">JOIN</span> Production.Product p <span class="keyword">on</span> s.ProductID <span class="operator">=</span> p.ProductID</span><br><span class="line"><span class="keyword">WHERE</span> Name <span class="keyword">LIKE</span> <span class="string">&#x27;Long-Sleeve Logo Jersey, M&#x27;</span>;</span><br><span class="line">GO</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">primary key</span> (ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>插入数据时，未指定 <code>tot_cred</code> 则使用默认值0：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student(ID, name, dept_name) <span class="keyword">values</span> (<span class="string">&#x27;12789&#x27;</span>, <span class="string">&#x27;Newman&#x27;</span>, <span class="string">&#x27;Comp.Sci&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="用户定义类型"><a href="#用户定义类型" class="headerlink" title="用户定义类型"></a>用户定义类型</h3><ul><li>使用 <code>create type</code> 子句定义用户定义类型。<ul><li>示例：<code>create type Dollars as numeric(12,2)</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> department (</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  building <span class="type">varchar</span>(<span class="number">15</span>),</span><br><span class="line">  budget Dollars</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>使用 <code>cast</code> 将一个类型的值转换为另一个域。<ul><li>例如，<code>cast(department.budget to numeric(12,2))</code>，然后表达式 <code>(department.budget + 20)</code> 可以被求值。</li></ul></li></ul><h3 id="用户定义域"><a href="#用户定义域" class="headerlink" title="用户定义域"></a>用户定义域</h3><ul><li><code>create domain</code> 构造创建用户定义的域类型。<ul><li><code>create domain person_name char(20) not null</code></li></ul></li><li>类型和域相似。域可以指定约束，例如 <code>not null</code>。</li><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain degree_level <span class="type">varchar</span>(<span class="number">10</span>)</span><br><span class="line">  <span class="keyword">constraint</span> degree_level_test</span><br><span class="line">  <span class="keyword">check</span> (<span class="keyword">value</span> <span class="keyword">in</span> (<span class="string">&#x27;Bachelors&#x27;</span>, <span class="string">&#x27;Masters&#x27;</span>, <span class="string">&#x27;Doctorate&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂检查条件和断言"><a href="#复杂检查条件和断言" class="headerlink" title="复杂检查条件和断言"></a>复杂检查条件和断言</h3><ul><li><p>一些构造如 <em>check</em> 和 <em>assertion</em> 被定义为用于指定复杂的完整性约束。</p><ul><li><strong>但是，目前大多数数据库系统不支持它们。</strong></li></ul></li><li><p><strong>复杂 Check 条件示例：</strong></p><ul><li>对于关系 <code>section</code>，每个元组中的 <code>time_slot_id</code> 实际上应该是 <code>time_slot</code> 关系中的一个时间槽标识符。此约束可以定义为：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">check</span> (time_slot_id <span class="keyword">in</span> (<span class="keyword">select</span> time_slot_id <span class="keyword">from</span> time_slot))</span><br></pre></td></tr></table></figure><ul><li>在 <code>create table</code> 中使用 <code>check</code>：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>),</span><br><span class="line">  <span class="keyword">primary key</span> (ID),</span><br><span class="line">  <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department,</span><br><span class="line">  <span class="keyword">check</span>(tot_cred <span class="operator">&gt;</span> <span class="number">0</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>断言</strong></p><ul><li>断言是表示我们希望数据库始终满足的条件的谓词。<ul><li>例如：域约束、参照完整性约束。</li></ul></li><li>断言的形式：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion <span class="operator">&lt;</span>断言名称<span class="operator">&gt;</span> <span class="keyword">check</span> <span class="operator">&lt;</span>谓词<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li><strong>同样不被大多数DBMS（如 SQL Server）支持。为什么？</strong><ul><li>当创建断言时，DBMS 测试其有效性。任何对数据库的修改只有在该断言不被违反时才被允许。</li><li>这种测试可能引入显著的开销，因此应非常谨慎地使用断言。</li></ul></li></ul></li><li><p><strong>断言示例：</strong></p><ul><li>对于 <code>student</code> 关系中的每个元组，<code>tot_cred</code> 属性的值必须等于该学生成功完成的课程的学分总和。</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> assertion credits_earned_constraint <span class="keyword">check</span></span><br><span class="line">  (<span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span> ID</span><br><span class="line">    <span class="keyword">from</span> student</span><br><span class="line">    <span class="keyword">where</span> tot_cred <span class="operator">&lt;&gt;</span></span><br><span class="line">      (<span class="keyword">select</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">       <span class="keyword">from</span> takes <span class="keyword">natural</span> <span class="keyword">join</span> course</span><br><span class="line">       <span class="keyword">where</span> student.ID <span class="operator">=</span> takes.ID</span><br><span class="line">         <span class="keyword">and</span> grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">         <span class="keyword">and</span> grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">      )</span><br><span class="line">  ))</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="4-6-SQL-中的索引定义"><a href="#4-6-SQL-中的索引定义" class="headerlink" title="4.6 SQL 中的索引定义"></a>4.6 SQL 中的索引定义</h2><ul><li>许多查询只引用表中的一小部分记录。</li><li>读取每条记录以查找具有特定值的记录是<strong>低效的</strong>。</li><li>关系属性上的<strong>索引</strong>是一种数据结构，它允许数据库系统高效地查找关系中在该属性上具有指定值的那些元组，而无需扫描关系的所有元组。</li><li>使用 <strong>create index</strong> 命令创建索引：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index <span class="operator">&lt;</span>索引名<span class="operator">&gt;</span> <span class="keyword">on</span> <span class="operator">&lt;</span>关系名<span class="operator">&gt;</span> (属性);</span><br></pre></td></tr></table></figure></li></ul><h3 id="索引定义示例"><a href="#索引定义示例" class="headerlink" title="索引定义示例"></a>索引定义示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> student (</span><br><span class="line">  ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">  dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">  tot_cred <span class="type">numeric</span>(<span class="number">3</span>,<span class="number">0</span>) <span class="keyword">default</span> <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">primary key</span> (ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index studentID_index <span class="keyword">on</span> student(ID);</span><br></pre></td></tr></table></figure><p>查询时可以利用索引高效定位记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> ID <span class="operator">=</span> <span class="string">&#x27;12345&#x27;</span></span><br></pre></td></tr></table></figure><hr><h2 id="4-7-授权"><a href="#4-7-授权" class="headerlink" title="4.7 授权"></a>4.7 授权</h2><h3 id="对数据库部分的授权形式"><a href="#对数据库部分的授权形式" class="headerlink" title="对数据库部分的授权形式"></a>对数据库部分的授权形式</h3><ul><li><strong>Read</strong> - 允许读取数据，但不允许修改。</li><li><strong>Insert</strong> - 允许插入新数据，但不允许修改现有数据。</li><li><strong>Update</strong> - 允许修改数据，但不允许删除。</li><li><strong>Delete</strong> - 允许删除数据。</li></ul><h3 id="对数据库模式修改的授权形式（第8章）"><a href="#对数据库模式修改的授权形式（第8章）" class="headerlink" title="对数据库模式修改的授权形式（第8章）"></a>对数据库模式修改的授权形式（第8章）</h3><ul><li><strong>resources</strong> - 允许创建新关系。</li><li><strong>alteration</strong> - 允许在关系中添加或删除属性。</li><li><strong>drop</strong> - 允许删除关系。</li><li><strong>index</strong> - 允许创建和删除索引。</li></ul><h3 id="授权规范"><a href="#授权规范" class="headerlink" title="授权规范"></a>授权规范</h3><ul><li>使用 <strong>grant</strong> 语句授予授权。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>关系名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">to</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>&lt;用户列表&gt;</code> 可以是：用户ID，或 <strong>public</strong>（允许所有有效用户获得授予的权限）。</li></ul></li><li>授予<strong>视图</strong>上的权限并不意味着授予对底层关系的任何权限。</li><li>权限的授予者必须已经拥有指定项目上的该权限（或者是数据库管理员）。</li></ul><h3 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h3><ul><li><strong>select</strong>：允许读取关系，或使用视图进行查询的能力。<ul><li>示例：授予用户 ( U_1, U_2, U_3 ) 对 <code>instructor</code> 关系的 select 授权：</li></ul>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> instructor <span class="keyword">to</span> U1, U2, U3</span><br></pre></td></tr></table></figure></li><li><strong>insert</strong>：插入元组的能力。</li><li><strong>update</strong>：使用 SQL update 语句更新的能力。</li><li><strong>delete</strong>：删除元组的能力。</li><li><strong>all privileges</strong>：用作所有允许权限的简写形式。</li></ul><h3 id="撤销授权"><a href="#撤销授权" class="headerlink" title="撤销授权"></a>撤销授权</h3><ul><li>使用 <strong>revoke</strong> 语句撤销授权。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="operator">&lt;</span>权限列表<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">on</span> <span class="operator">&lt;</span>关系名或视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>用户列表<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li><li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">select</span> <span class="keyword">on</span> branch <span class="keyword">from</span> U1, U2, U3</span><br></pre></td></tr></table></figure></li><li><code>&lt;权限列表&gt;</code> 可以是 <strong>all</strong>，以撤销撤销者可能持有的所有权限。</li><li>如果 <code>&lt;撤销列表&gt;</code> 包含 <strong>public</strong>，则所有用户都会失去该权限，除非他们被明确授予该权限。</li></ul><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>创建角色：<code>create role instructor;</code></li><li>将角色授予用户：<code>grant instructor to Amit;</code></li><li>可以向角色授予权限：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> takes <span class="keyword">to</span> instructor;</span><br></pre></td></tr></table></figure></li><li>角色可以授予给用户，也可以授予给其他角色：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role teaching_assistant;</span><br><span class="line"><span class="keyword">grant</span> teaching_assistant <span class="keyword">to</span> instructor;</span><br><span class="line"><span class="comment">-- Instructor 继承 teaching_assistant 的所有权限</span></span><br></pre></td></tr></table></figure></li><li>角色链：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> role dean;</span><br><span class="line"><span class="keyword">grant</span> instructor <span class="keyword">to</span> dean;</span><br><span class="line"><span class="keyword">grant</span> dean <span class="keyword">to</span> Satoshi;</span><br></pre></td></tr></table></figure></li></ul><h3 id="视图上的授权"><a href="#视图上的授权" class="headerlink" title="视图上的授权"></a>视图上的授权</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> geo_instructor <span class="keyword">as</span></span><br><span class="line">  (<span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">   <span class="keyword">from</span> instructor</span><br><span class="line">   <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Geology&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">select</span> <span class="keyword">on</span> geo_instructor <span class="keyword">to</span> geo_staff;</span><br></pre></td></tr></table></figure><ul><li>假设 <code>geo_staff</code> 成员执行：<code>select * from geo_instructor;</code></li><li>如果发生以下情况会怎样？<ul><li><code>geo_staff</code> 对 <code>instructor</code> 没有权限？</li><li>视图创建者对 <code>instructor</code> 没有某些权限？</li></ul></li></ul><h3 id="其他授权特性"><a href="#其他授权特性" class="headerlink" title="其他授权特性"></a>其他授权特性</h3><ul><li><strong>references</strong> 权限用于创建外键。<ul><li><code>grant reference (dept_name) on department to Mariano;</code></li><li>为什么需要这个？</li></ul></li><li><strong>权限转移</strong><ul><li><code>grant select on department to Amit with grant option;</code></li></ul></li><li><strong>级联撤销</strong><ul><li><code>revoke select on department from Amit, Satoshi cascade;</code></li></ul></li><li><strong>限制撤销</strong><ul><li><code>revoke select on department from Amit, Satoshi restrict;</code></li></ul></li></ul><p><strong>等等。</strong> 更多细节请阅读第4.6节。</p><hr><h2 id="实验要求与讨论"><a href="#实验要求与讨论" class="headerlink" title="实验要求与讨论"></a>实验要求与讨论</h2><h3 id="实验要求：外键关联与级联操作"><a href="#实验要求：外键关联与级联操作" class="headerlink" title="实验要求：外键关联与级联操作"></a>实验要求：外键关联与级联操作</h3><ul><li><strong>平台：</strong> openGauss</li><li><strong>任务：</strong> 定义两张表间的无级联修改和有级联修改的外键关联。判断当增&#x2F;删&#x2F;改一张表中的主键、外键值时，DBMS 的反应。</li></ul><h3 id="数据库系统设计时，是否使用外键？"><a href="#数据库系统设计时，是否使用外键？" class="headerlink" title="数据库系统设计时，是否使用外键？"></a>数据库系统设计时，是否使用外键？</h3><ul><li>外键反映了不同数据项间的逻辑关联和约束关系，是一种客观存在。<ul><li>例如：<code>department</code> 表和 <code>course</code> 表中的 <code>dept_name</code>。</li></ul></li><li>对外键的处理方式反映了对这种数据相互间关系的处理态度，需要根据实际情况而定，考虑数据完整性、处理效率等多种因素。<ul><li>并非简单的“需要外键”或“不设外键”。</li></ul></li></ul><h4 id="方式1：设置数据库表的外键"><a href="#方式1：设置数据库表的外键" class="headerlink" title="方式1：设置数据库表的外键"></a>方式1：设置数据库表的外键</h4><ul><li><strong>优点</strong><ul><li>DBMS 自动维护数据间的关联、约束关系。</li></ul></li><li><strong>缺点</strong><ul><li>数据导入、增删改时，多个表间的相互关联保证了数据一致性和完整性，但影响到整体数据处理效率（额外的 DBMS 处理开销）。</li><li>例如：插入一条 <code>dept_name</code> 不存在的 <code>course</code> 元组，失败，并影响前面已经成功插入的数据——局部错误影响整体。</li></ul></li></ul><h4 id="方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性"><a href="#方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性" class="headerlink" title="方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性"></a>方式2：不设置外键，由应用程序在业务逻辑层维护数据一致性、完整性</h4><ul><li><strong>优点</strong><ul><li>1）避免局部错误影响整体进度；</li><li>2）业务逻辑层的数据一致性处理速度可以比较快，例如将数据提至内存中批量处理。</li></ul></li><li><strong>缺点</strong>：对应用层业务处理程序设计的额外要求。</li><li>上述两种方式用在对数据一致性完整性要求高的场景下，例如银行。</li></ul><h4 id="方式3：不设置外键，业务层应用逻辑也不处理数据间一致性"><a href="#方式3：不设置外键，业务层应用逻辑也不处理数据间一致性" class="headerlink" title="方式3：不设置外键，业务层应用逻辑也不处理数据间一致性"></a>方式3：不设置外键，业务层应用逻辑也不处理数据间一致性</h4><ul><li>牺牲数据的正确性，换取数据处理的效率。</li><li>例如：大数据应用场景下，对数据精度、正确性要求不高。</li></ul><h3 id="LTE-网络数据库课程实验讨论"><a href="#LTE-网络数据库课程实验讨论" class="headerlink" title="LTE 网络数据库课程实验讨论"></a>LTE 网络数据库课程实验讨论</h3><ul><li><code>tbMRData</code>、<code>tbATUData</code> 表中的主小区、邻小区 ID 对应于 <code>tbCell</code> 中的小区标识 <code>Sector_ID</code>。</li><li><strong>实际应用中，不建议</strong>在 <code>tbMRData</code>、<code>tbATUData</code> 与 <code>tbCell</code> 之间建立外键。否则，两表间由于强行的外键约束，可能带来低效的数据处理。<ul><li><strong>例1：</strong> 向 <code>tbMRData</code>、<code>tbATUData</code> 中大批量导入数据时，插入的某条测量报告数据中的某些主小区、邻小区没有出现在 <code>tbCell</code> 表中，导致本条以及前面各条已成功插入的测量报告均插入失败。</li><li><strong>例2：</strong> 当 <code>tbCell</code> 中某个小区修改名字时，在（数据量非常大，例如 T 级别，上亿条）<code>tbMRData</code>、<code>tbATUData</code> 表中以该小区作为主、邻小区的测量报告也必须随之修改。</li></ul></li><li><strong>现网环境中不一致的原因：</strong><ul><li><code>tbMRData</code>、<code>tbATUData</code> 中的测量报告的测量范围超出 <code>tbCell</code> 的范围，有些测量报告的主小区、邻小区没有出现在 <code>tbCell</code> 表中。</li><li><code>tbCell</code> 表中的小区数据有可能被修改，导致与 <code>tbMRData</code>、<code>tbATUData</code> 中的测量报告不一致。</li></ul></li></ul><h3 id="LTE-网络数据库实验要求"><a href="#LTE-网络数据库实验要求" class="headerlink" title="LTE 网络数据库实验要求"></a>LTE 网络数据库实验要求</h3><ol><li>在建表、数据导入阶段，<strong>先不要建立</strong> <code>tbMRData</code>、<code>tbATUData</code> 与 <code>tbCell</code> 间的外键。</li><li>数据导入完成后，再建立表间外键关联，观察：<ul><li>是否能建立？</li><li>如果建立，<code>tbCell</code> 中主键值的变化对 <code>tbMRData</code>、<code>tbATUData</code> 的影响，或反之。</li></ul></li><li>在已建立的表中增加外键的方法，参见具体 DBMS 平台用户手册。</li></ol><hr><h2 id="附录-4-1-T-SQL-中的-CREATE-TABLE"><a href="#附录-4-1-T-SQL-中的-CREATE-TABLE" class="headerlink" title="附录 4-1: T-SQL 中的 CREATE TABLE"></a>附录 4-1: T-SQL 中的 CREATE TABLE</h2><p>（此处详细语法结构图展示了 T-SQL 中 CREATE TABLE 语句的复杂选项，包括列定义、约束、物理存储选项（分区、文件组）、索引类型（聚集&#x2F;非聚集）等，强调了物理设计层面的考量。具体语法细节可参考 SQL Server 文档。）</p><hr><h2 id="本章内容总结（大纲）"><a href="#本章内容总结（大纲）" class="headerlink" title="本章内容总结（大纲）"></a>本章内容总结（大纲）</h2><p><strong>I. SQL 数据类型和模式 (4.5)</strong></p><ul><li>日期和时间类型</li><li>类型转换和格式化函数</li><li>默认值</li><li>大对象类型，用户定义类型</li><li>create table 扩展，生成唯一键值</li><li>模式、目录、环境</li></ul><p><strong>II. 连接表达式 (4.1) (用于多表访问)</strong></p><ul><li>自然连接</li><li>连接条件</li><li>外连接</li><li>连接类型和条件</li></ul><p><strong>III. 视图 (4.2)</strong></p><ul><li>定义、查询、更新</li><li>物化视图</li></ul><p><strong>IV. 事务 (4.3)</strong></p><ul><li>定义、示例</li></ul><p><strong>V. 完整性约束 (4.4)</strong></p><ul><li>not null, unique, check</li><li>参照完整性</li><li>复杂检查约束和断言</li><li>为约束命名，事务期间的约束违反</li></ul><p><strong>VI. SQL 中的索引定义 (4.6)</strong></p><p><strong>VII. 授权 (4.7)</strong></p><ul><li>grant&#x2F;revoke, 角色</li></ul><p><strong>实验：</strong> 完整性约束</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Advanced-SQL课件详解</title>
      <link href="/2025/12/24/DB_AdvancedSQL/"/>
      <url>/2025/12/24/DB_AdvancedSQL/</url>
      
        <content type="html"><![CDATA[<h2 id="章节标题与大纲"><a href="#章节标题与大纲" class="headerlink" title="章节标题与大纲"></a>章节标题与大纲</h2><h3 id="第五章：高级SQL"><a href="#第五章：高级SQL" class="headerlink" title="第五章：高级SQL"></a>第五章：高级SQL</h3><p><strong>授课时间</strong>：2025年10月<br><strong>授课单位</strong>：计算机学院</p><h3 id="本章大纲"><a href="#本章大纲" class="headerlink" title="本章大纲"></a>本章大纲</h3><p>本章旨在深入探讨超越基础SQL操作的高级特性，重点涵盖以下三个核心领域：</p><ol><li><strong>从编程语言访问SQL</strong>：探讨如何在Java、C等通用编程语言中执行SQL语句，实现应用程序与数据库系统的交互。</li><li><strong>函数和存储过程</strong>：学习在数据库服务器端创建可重用的程序化逻辑单元，包括标量函数和存储过程。</li><li><strong>触发器</strong>：掌握基于事件-条件-动作模型的数据库自动化响应机制，用于维护数据完整性和执行业务规则。</li></ol><h2 id="从编程语言访问SQL（概述与架构）"><a href="#从编程语言访问SQL（概述与架构）" class="headerlink" title="从编程语言访问SQL（概述与架构）"></a>从编程语言访问SQL（概述与架构）</h2><h3 id="5-1-从编程语言访问SQL"><a href="#5-1-从编程语言访问SQL" class="headerlink" title="5.1 从编程语言访问SQL"></a>5.1 从编程语言访问SQL</h3><h4 id="5-1-0-数据库应用系统（DBAS）架构回顾"><a href="#5-1-0-数据库应用系统（DBAS）架构回顾" class="headerlink" title="5.1.0 数据库应用系统（DBAS）架构回顾"></a>5.1.0 数据库应用系统（DBAS）架构回顾</h4><p>数据库应用系统是由<strong>用户</strong>、<strong>应用程序</strong>、**数据库管理系统（DBMS）<strong>和</strong>数据库（DB）<strong>共同构成的完整体系。应用程序作为用户与数据库之间的桥梁，需要通过特定的</strong>应用程序编程接口（API）**与数据库服务器进行交互。这一交互过程通常遵循以下步骤：</p><ol><li>建立与数据库服务器的连接。</li><li>通过连接向服务器发送SQL命令（查询或更新）。</li><li>对于查询操作，以一次一个元组的方式，将结果集提取到应用程序的变量中进行后续处理。</li></ol><h4 id="5-1-1-两种主要的访问范式"><a href="#5-1-1-两种主要的访问范式" class="headerlink" title="5.1.1 两种主要的访问范式"></a>5.1.1 两种主要的访问范式</h4><p>从编程语言访问SQL主要有两种实现途径，它们在集成方式和执行时机上存在根本区别：</p><ol><li><p><strong>动态SQL</strong></p><ul><li><strong>定义</strong>：在通用编程语言中，程序在<strong>运行时</strong>动态地构建SQL查询字符串，并通过API函数调用（如JDBC、ODBC）将该字符串提交给数据库服务器执行，然后处理返回的结果。</li><li><strong>核心特征</strong>：<ul><li><strong>灵活性高</strong>：SQL语句可以根据程序逻辑和用户输入动态生成。</li><li><strong>显式控制</strong>：程序员需手动管理连接、语句执行、结果获取和资源释放的全生命周期。</li></ul></li><li><strong>主流技术标准</strong>：<ul><li><strong>JDBC</strong>：专为Java语言设计的数据库连接API标准。</li><li><strong>ODBC</strong>：一种开放的、与语言和数据库无关的调用级接口标准，广泛用于C、C++等语言。</li></ul></li></ul></li><li><p><strong>嵌入式SQL</strong></p><ul><li><strong>定义</strong>：将SQL语句直接<strong>编写</strong>在宿主语言（如C、COBOL）的源代码中。在编译程序之前，先由一个<strong>预处理器</strong>扫描源代码，将这些嵌入式SQL语句转换为对数据库运行时库的特定函数调用。随后，再由宿主语言的编译器进行编译。</li><li><strong>核心特征</strong>：<ul><li><strong>编译时确定</strong>：SQL语句在编译期是可见的，可进行早期语法检查和优化。</li><li><strong>编程模型更贴近SQL</strong>：使用游标（Cursor）机制处理多行结果集，语法上更接近直接的SQL交互。</li><li><strong>底层依赖动态SQL</strong>：最终生成的函数调用实质上利用了动态SQL的API（如ODBC）来完成数据库通信。</li></ul></li></ul></li></ol><h2 id="JDBC详解（基础与核心流程）"><a href="#JDBC详解（基础与核心流程）" class="headerlink" title="JDBC详解（基础与核心流程）"></a>JDBC详解（基础与核心流程）</h2><h3 id="5-1-2-JDBC（Java-Database-Connectivity）"><a href="#5-1-2-JDBC（Java-Database-Connectivity）" class="headerlink" title="5.1.2 JDBC（Java Database Connectivity）"></a>5.1.2 JDBC（Java Database Connectivity）</h3><h4 id="特性与用途"><a href="#特性与用途" class="headerlink" title="特性与用途"></a>特性与用途</h4><p>JDBC是Java平台中用于执行SQL语句的一套标准API。它不仅支持数据的查询与更新，还提供了检索数据库<strong>元数据</strong>的能力，例如查询数据库中有哪些表、表中各列的名称和数据类型等。</p><p>JDBC建立了一套标准的通信模型：</p><ol><li>打开一个数据库连接。</li><li>创建一个<code>Statement</code>（语句）对象。</li><li>使用该<code>Statement</code>对象发送SQL查询并获取结果。</li><li>利用Java的异常处理机制来管理操作中可能出现的错误。</li></ol><h4 id="JDBC核心代码示例与逐步解析"><a href="#JDBC核心代码示例与逐步解析" class="headerlink" title="JDBC核心代码示例与逐步解析"></a>JDBC核心代码示例与逐步解析</h4><p>以下是一个完整的JDBC方法示例，演示了连接数据库、执行插入和查询操作的全过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String userId, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// === 步骤 1：加载数据库驱动程序（JDBC 4.0+ 可省略）===</span></span><br><span class="line">        <span class="comment">// 此步骤告知Java运行时环境所要使用的JDBC驱动实现类。</span></span><br><span class="line">        <span class="comment">// 注意：自JDBC 4.0（Java 6）起，驱动可自动加载，此语句常可省略。</span></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 2：建立数据库连接 ===</span></span><br><span class="line">        <span class="comment">// 使用DriverManager的getConnection方法，传入数据库URL、用户名和密码。</span></span><br><span class="line">        <span class="comment">// URL格式因数据库厂商而异。本例连接一个Oracle数据库。</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>, <span class="comment">// 数据库URL</span></span><br><span class="line">            userId, <span class="comment">// 用户名</span></span><br><span class="line">            passwd  <span class="comment">// 密码</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 3：创建语句对象 ===</span></span><br><span class="line">        <span class="comment">// 通过Connection对象创建一个Statement对象，用于执行静态SQL语句。</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4a：执行数据更新操作（INSERT, UPDATE, DELETE）===</span></span><br><span class="line">        <span class="comment">// 使用executeUpdate方法，它返回受影响的行数。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.executeUpdate(</span><br><span class="line">                <span class="string">&quot;insert into instructor values(&#x27;77987&#x27;, &#x27;Kim&#x27;, &#x27;Physics&#x27;, 98000)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            <span class="comment">// 捕获并处理可能发生的SQL异常（如主键冲突、违反约束等）</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 4b：执行数据查询操作 ===</span></span><br><span class="line">        <span class="comment">// 使用executeQuery方法执行SELECT语句，返回一个ResultSet（结果集）对象。</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;select dept_name, avg(salary) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from instructor &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by dept_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 5：遍历并处理结果集 ===</span></span><br><span class="line">        <span class="comment">// ResultSet的next()方法将游标移动到下一行。首次调用移至第一行。</span></span><br><span class="line">        <span class="comment">// 当没有更多行时返回false。</span></span><br><span class="line">        <span class="keyword">while</span> (rset.next()) &#123;</span><br><span class="line">            <span class="comment">// 使用getString(列名)和getFloat(列索引)等方法获取当前行的列值。</span></span><br><span class="line">            <span class="comment">// 列索引从1开始。</span></span><br><span class="line">            System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>) + <span class="string">&quot; &quot;</span> + rset.getFloat(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 6：清理资源（至关重要！）===</span></span><br><span class="line">        <span class="comment">// 必须按顺序关闭ResultSet、Statement和Connection，以释放数据库和系统资源。</span></span><br><span class="line">        <span class="comment">// 实际开发中应使用try-with-resources语句确保资源被关闭。</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;JDBC Driver not found: &quot;</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">        <span class="comment">// 捕获连接、语句创建等过程中更广泛的SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;SQLException : &quot;</span> + sqle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 捕获其他非SQL异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Exception : &quot;</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键点解析"><a href="#关键点解析" class="headerlink" title="关键点解析"></a>关键点解析</h4><ol><li><strong><code>Class.forName()</code></strong>：此语句显式加载特定的JDBC驱动类。这是JDBC 3.0及之前版本的规范做法。在JDBC 4.0及以上版本（Java 6+），只要驱动JAR包在类路径中，驱动管理器可以自动发现并加载驱动，因此这行代码常可省略。</li><li><strong><code>DriverManager.getConnection()</code></strong>：这是建立连接的工厂方法。数据库URL的格式是驱动特定的。<code>jdbc:oracle:thin:@db.yale.edu:1521:univdb</code> 表示使用Oracle的“thin”驱动，连接主机<code>db.yale.edu</code>上端口1521的服务<code>univdb</code>。</li><li><strong><code>Statement.executeUpdate()</code> vs <code>executeQuery()</code></strong>：<ul><li><code>executeUpdate()</code>：用于执行会修改数据库内容的SQL语句（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>CREATE TABLE</code>, <code>DROP TABLE</code>等），返回一个整数，表示受影响的行数。</li><li><code>executeQuery()</code>：专门用于执行<code>SELECT</code>语句，返回一个<code>ResultSet</code>对象。</li></ul></li><li><strong><code>ResultSet</code>处理</strong>：<ul><li>结果集初始时游标位于第一行<strong>之前</strong>。</li><li><code>next()</code>方法将游标向前移动一行，并返回一个布尔值，指示新行是否有效。</li><li>可以使用列名（字符串）或列索引（从1开始）来获取列值。<code>getString(1)</code>和<code>getString(“dept_name”)</code>是等价的（假设<code>dept_name</code>是<code>SELECT</code>子句中的第一个元素）。</li></ul></li><li><strong>异常处理</strong>：几乎所有JDBC操作都可能抛出<code>SQLException</code>，必须妥善处理。通常使用<code>try-catch</code>块来捕获，并至少记录错误信息。</li><li><strong>资源管理</strong>：<code>Connection</code>、<code>Statement</code>和<code>ResultSet</code>都是持有昂贵底层资源（如数据库连接、服务器游标）的对象。<strong>必须</strong>在使用完毕后显式调用<code>close()</code>方法将其关闭，以防止资源泄漏。推荐使用Java 7引入的<code>try-with-resources</code>语法实现自动关闭。</li></ol><h4 id="处理空值（Null-Values）"><a href="#处理空值（Null-Values）" class="headerlink" title="处理空值（Null Values）"></a>处理空值（Null Values）</h4><p>从<code>ResultSet</code>中读取数据时，如果某列的值为SQL <code>NULL</code>，则<code>getXXX()</code>方法会返回对应Java类型的默认值（如0、<code>false</code>、<code>null</code>）。为了准确区分数据库中的<code>NULL</code>和默认值，可以使用<code>ResultSet.wasNull()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (rs.wasNull()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Got null value for column &#x27;a&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC高级特性（预编译语句、元数据、事务控制）"><a href="#JDBC高级特性（预编译语句、元数据、事务控制）" class="headerlink" title="JDBC高级特性（预编译语句、元数据、事务控制）"></a>JDBC高级特性（预编译语句、元数据、事务控制）</h2><h3 id="5-1-2-1-预编译语句（PreparedStatement）"><a href="#5-1-2-1-预编译语句（PreparedStatement）" class="headerlink" title="5.1.2.1 预编译语句（PreparedStatement）"></a>5.1.2.1 预编译语句（PreparedStatement）</h3><p>预编译语句是<code>Statement</code>接口的一个更强大、更安全、通常也更高效的子接口。</p><ul><li><p><strong>工作原理</strong>：SQL语句在创建<code>PreparedStatement</code>对象时即被发送到数据库进行<strong>预编译</strong>。语句中的变量部分用占位符<code>?</code>表示。之后，每次执行只需为这些<code>?</code>传入具体的参数值即可。</p></li><li><p><strong>优势</strong>：</p><ol><li><strong>性能</strong>：对于需要重复执行多次（仅参数不同）的SQL语句，数据库只需编译一次，后续执行直接使用编译好的执行计划，效率显著提升。</li><li><strong>安全</strong>：有效防止<strong>SQL注入攻击</strong>。因为参数值是通过<code>setXXX()</code>方法传递的，而不是拼接到SQL字符串中，数据库会将其视为纯粹的数据，而非可执行代码的一部分。</li><li><strong>可读性与维护性</strong>：将SQL逻辑与参数值分离，代码更清晰。</li></ol></li><li><p><strong>创建与使用示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建PreparedStatement，使用?作为参数占位符</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into instructor values(?, ?, ?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设置参数值。索引从1开始。</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>);      <span class="comment">// 设置第一个?为ID</span></span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);      <span class="comment">// 设置第二个?为name</span></span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);    <span class="comment">// 设置第三个?为dept_name</span></span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);          <span class="comment">// 设置第四个?为salary</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 执行更新。注意：这里没有SQL字符串参数。</span></span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 重用同一个PreparedStatement插入另一条记录，只需重新设置变化的参数</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>); <span class="comment">// 仅修改ID</span></span><br><span class="line">pStmt.executeUpdate();       <span class="comment">// 再次执行</span></span><br></pre></td></tr></table></figure><p><strong>关键说明</strong>：前四个<code>setXXX</code>语句仅仅是为<code>INSERT</code>语句的参数赋值，并没有触发数据库的插入操作。真正的插入是在调用<code>executeUpdate()</code>时执行的。这允许在批量操作中高效地复用同一个<code>PreparedStatement</code>对象。</p></li></ul><h3 id="5-1-2-2-元数据特性（Metadata）"><a href="#5-1-2-2-元数据特性（Metadata）" class="headerlink" title="5.1.2.2 元数据特性（Metadata）"></a>5.1.2.2 元数据特性（Metadata）</h3><p>元数据是“关于数据的数据”。JDBC提供了访问两类元数据的接口：</p><ol><li><p><strong>结果集元数据（<code>ResultSetMetaData</code>）</strong>：获取关于特定查询结果的结构信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM department&quot;</span>);</span><br><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Column &quot;</span> + i + <span class="string">&quot;:&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;  Name: &quot;</span> + rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Type: &quot;</span> + rsmd.getColumnTypeName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;  Display Size: &quot;</span> + rsmd.getColumnDisplaySize(i));</span><br><span class="line">    <span class="comment">// 还有其他方法，如isNullable, isAutoIncrement等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用途</strong>：动态处理未知结构的查询结果，常用于通用查询工具或报表生成器。</p></li><li><p><strong>数据库元数据（<code>DatabaseMetaData</code>）</strong>：获取关于整个数据库的目录信息，如所有表、列、主键、外键等。</p><ul><li><strong>获取表的所有列</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getColumns参数: 目录, 模式, 表名模式, 列名模式</span></span><br><span class="line"><span class="comment">// null 表示“所有目录”， &quot;%&quot; 表示“所有”（类似于SQL的LIKE）</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">columns</span> <span class="operator">=</span> dbmd.getColumns(<span class="literal">null</span>, <span class="string">&quot;univdb&quot;</span>, <span class="string">&quot;department&quot;</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (columns.next()) &#123;</span><br><span class="line">    System.out.println(</span><br><span class="line">        columns.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>) + <span class="string">&quot; - &quot;</span> +</span><br><span class="line">        columns.getString(<span class="string">&quot;TYPE_NAME&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>获取表的主键信息</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// getPrimaryKeys参数: 目录, 模式, 表名</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">pks</span> <span class="operator">=</span> dmd.getPrimaryKeys(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;department&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pks.next()) &#123;</span><br><span class="line">    <span class="comment">// KEY_SEQ表示该列在主键中的顺序（针对复合主键）</span></span><br><span class="line">    System.out.println(<span class="string">&quot;PK Sequence: &quot;</span> + pks.getString(<span class="string">&quot;KEY_SEQ&quot;</span>) +</span><br><span class="line">                       <span class="string">&quot;, Column: &quot;</span> + pks.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="5-1-2-3-事务控制（Transaction-Control）"><a href="#5-1-2-3-事务控制（Transaction-Control）" class="headerlink" title="5.1.2.3 事务控制（Transaction Control）"></a>5.1.2.3 事务控制（Transaction Control）</h3><p>默认情况下，JDBC连接处于<strong>自动提交模式</strong>：每条SQL语句都被视为一个独立的事务，并在执行后立即自动提交。</p><ul><li><strong>问题</strong>：对于包含多个更新操作的逻辑单元（如银行转账），自动提交会导致原子性无法保证。如果中间某条语句失败，之前已提交的更改无法自动撤销。</li><li><strong>解决方案</strong>：手动管理事务。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 关闭自动提交</span></span><br><span class="line">    conn.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 执行一系列更新操作</span></span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance - 100 WHERE id = &#x27;A&#x27;&quot;</span>);</span><br><span class="line">    stmt.executeUpdate(<span class="string">&quot;UPDATE account SET balance = balance + 100 WHERE id = &#x27;B&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 如果全部成功，手动提交事务</span></span><br><span class="line">    conn.commit();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="comment">// 4. 如果发生任何异常，回滚事务，撤销所有未提交的更改</span></span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">            <span class="comment">// 处理回滚异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理原异常e</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 5. 恢复自动提交模式（可选，但建议）</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="literal">null</span>) conn.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// 处理异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="5-1-2-4-调用函数和存储过程"><a href="#5-1-2-4-调用函数和存储过程" class="headerlink" title="5.1.2.4 调用函数和存储过程"></a>5.1.2.4 调用函数和存储过程</h3><p>使用<code>CallableStatement</code>接口调用数据库中的存储函数和存储过程。</p><ul><li><strong>调用函数</strong>（有返回值）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;? = call function_name(?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt1</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;? = call get_dept_count(?)&#125;&quot;</span>);</span><br><span class="line">cStmt1.registerOutParameter(<span class="number">1</span>, Types.INTEGER); <span class="comment">// 注册第一个?为输出参数（返回值）</span></span><br><span class="line">cStmt1.setString(<span class="number">2</span>, <span class="string">&quot;Comp. Sci.&quot;</span>); <span class="comment">// 设置第二个?为输入参数</span></span><br><span class="line">cStmt1.execute();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cStmt1.getInt(<span class="number">1</span>); <span class="comment">// 获取返回值</span></span><br></pre></td></tr></table></figure></li><li><strong>调用过程</strong>（无返回值或通过OUT参数返回）：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;call procedure_name(?, ?)&#125; 语法</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt2</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;call adjust_salary(?, ?)&#125;&quot;</span>);</span><br><span class="line">cStmt2.setString(<span class="number">1</span>, <span class="string">&quot;10101&quot;</span>);</span><br><span class="line">cStmt2.setInt(<span class="number">2</span>, <span class="number">5000</span>);</span><br><span class="line">cStmt2.execute();</span><br></pre></td></tr></table></figure></li></ul><h2 id="ODBC详解"><a href="#ODBC详解" class="headerlink" title="ODBC详解"></a>ODBC详解</h2><h3 id="5-1-3-ODBC（Open-Database-Connectivity）"><a href="#5-1-3-ODBC（Open-Database-Connectivity）" class="headerlink" title="5.1.3 ODBC（Open Database Connectivity）"></a>5.1.3 ODBC（Open Database Connectivity）</h3><p>ODBC是一个由微软主导制定的开放数据库互连标准，它提供了一个与编程语言和数据库管理系统均无关的调用级API。</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>ODBC采用分层驱动架构：</p><ol><li><strong>应用程序</strong>：调用标准的ODBC API函数。</li><li><strong>ODBC驱动程序管理器</strong>：作为应用程序的入口点，负责加载、卸载驱动程序，并将应用程序的ODBC调用分派给正确的驱动程序。</li><li><strong>ODBC驱动程序</strong>：由各个数据库厂商提供，负责将标准的ODBC函数调用转换为特定数据库的网络协议或本地API调用（如调用Oracle的OCI库、SQL Server的TDS协议等）。</li><li><strong>数据源</strong>：通过ODBC管理器配置的、指向特定数据库服务器的连接定义（DSN，Data Source Name）。</li></ol><h4 id="ODBC-C语言编程示例与逐步解析"><a href="#ODBC-C语言编程示例与逐步解析" class="headerlink" title="ODBC C语言编程示例与逐步解析"></a>ODBC C语言编程示例与逐步解析</h4><p>以下C程序片段展示了使用ODBC API连接数据库、执行查询并获取结果的完整流程，包含详细的步骤注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// === 步骤 0：声明变量 ===</span></span><br><span class="line">    RETCODE error;           <span class="comment">// 用于接收每个ODBC API调用的返回码（SQL_SUCCESS, SQL_ERROR等）</span></span><br><span class="line">    HENV env;                <span class="comment">// 环境句柄，代表ODBC的上下文环境</span></span><br><span class="line">    HDBC conn;               <span class="comment">// 连接句柄，代表一个数据库连接</span></span><br><span class="line">    HSTMT stmt;              <span class="comment">// 语句句柄，代表一个SQL语句</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 1：分配环境句柄 ===</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 2：分配连接句柄 ===</span></span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 3：建立连接 ===</span></span><br><span class="line">    <span class="comment">// SQLConnect参数：连接句柄，服务器名，用户名，密码。</span></span><br><span class="line">    <span class="comment">// SQL_NTS 表示前一个参数是以空字符结尾的字符串。</span></span><br><span class="line">    SQLConnect(conn,</span><br><span class="line">               <span class="string">&quot;db.yale.edu&quot;</span>, SQL_NTS,  <span class="comment">// 服务器</span></span><br><span class="line">               <span class="string">&quot;avi&quot;</span>, SQL_NTS,          <span class="comment">// 用户名</span></span><br><span class="line">               <span class="string">&quot;avipasswd&quot;</span>, SQL_NTS);   <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 4：分配语句句柄 ===</span></span><br><span class="line">    SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 5：准备并执行SQL语句 ===</span></span><br><span class="line">    <span class="type">char</span> *sqlquery = <span class="string">&quot;select dept_name, sum(salary) from instructor group by dept_name&quot;</span>;</span><br><span class="line">    <span class="comment">// SQLExecDirect直接执行一个SQL字符串。</span></span><br><span class="line">    error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// === 步骤 6：将结果列绑定到C程序变量 ===</span></span><br><span class="line">        <span class="type">char</span> deptname[<span class="number">80</span>];     <span class="comment">// 用于接收dept_name的缓冲区</span></span><br><span class="line">        <span class="type">float</span> salary;          <span class="comment">// 用于接收sum(salary)的变量</span></span><br><span class="line">        SQLINTEGER lenOut1, lenOut2; <span class="comment">// 用于接收字符串实际长度（可为NULL指示符）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// SQLBindCol将结果集的列与程序变量关联。</span></span><br><span class="line">        <span class="comment">// 参数：语句句柄，列号（从1开始），C变量类型，变量地址，缓冲区长度，长度/指示符缓冲区地址。</span></span><br><span class="line">        SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="keyword">sizeof</span>(deptname), &amp;lenOut1);</span><br><span class="line">        SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2); <span class="comment">// 长度0用于非字符串类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// === 步骤 7：循环获取每一行结果 ===</span></span><br><span class="line">        <span class="comment">// SQLFetch将游标移动到下一行，并将已绑定的列数据提取到对应的C变量中。</span></span><br><span class="line">        <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">            <span class="comment">// 检查指示符，判断数据是否为NULL。如果lenOut1 == SQL_NULL_DATA，则deptname无效。</span></span><br><span class="line">            <span class="keyword">if</span> (lenOut1 != SQL_NULL_DATA) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Department: %s, Total Salary: %g\n&quot;</span>, deptname, salary);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理错误：可以使用SQLError函数获取详细的错误信息。</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Query execution failed.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// === 步骤 8：清理资源（逆序释放）===</span></span><br><span class="line">    SQLFreeStmt(stmt, SQL_DROP);   <span class="comment">// 释放语句句柄</span></span><br><span class="line">    SQLDisconnect(conn);          <span class="comment">// 断开连接</span></span><br><span class="line">    SQLFreeConnect(conn);         <span class="comment">// 释放连接句柄</span></span><br><span class="line">    SQLFreeEnv(env);              <span class="comment">// 释放环境句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关于连接时长的重要说明"><a href="#关于连接时长的重要说明" class="headerlink" title="关于连接时长的重要说明"></a>关于连接时长的重要说明</h4><p>在实际生产环境中，数据库服务器或网络设备通常会对客户端连接设置<strong>超时限制</strong>（例如，非活动连接60秒后自动断开）。如果应用程序执行一个非常耗时的SQL查询，其执行时间超过了连接的超时设置，那么该查询可能会被服务器强行终止，导致操作失败。</p><ul><li><strong>注意事项</strong>：使用默认连接设置时，必须确保任何单个数据库操作都不会超过系统的默认连接超时时长。</li><li><strong>解决方案</strong>：ODBC API（如<code>SQLSetConnectAttr</code>）或连接字符串参数通常允许应用程序<strong>调整连接超时或查询超时设置</strong>。在开发需要执行长时间操作的应用程序时，必须合理配置这些超时参数，以保证操作的顺利完成。</li></ul><h2 id="嵌入式SQL详解"><a href="#嵌入式SQL详解" class="headerlink" title="嵌入式SQL详解"></a>嵌入式SQL详解</h2><h3 id="5-1-4-嵌入式SQL"><a href="#5-1-4-嵌入式SQL" class="headerlink" title="5.1.4 嵌入式SQL"></a>5.1.4 嵌入式SQL</h3><h4 id="SQL的使用方式分类"><a href="#SQL的使用方式分类" class="headerlink" title="SQL的使用方式分类"></a>SQL的使用方式分类</h4><ol><li><strong>交互式SQL</strong>：用户通过数据库系统提供的命令行界面或图形工具直接输入并执行SQL语句，主要用于数据定义（DDL）和即席查询（DML）。</li><li><strong>动态SQL</strong>：如前所述的JDBC&#x2F;ODBC，在程序运行时动态构建和执行SQL字符串。</li><li><strong>嵌入式SQL</strong>：将SQL语句<strong>直接嵌入</strong>到C、COBOL、Fortran等宿主语言的源代码中，在程序<strong>编译前</strong>通过预处理器进行转换。</li></ol><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><strong>宿主语言</strong>：嵌入SQL语句的通用编程语言（如C）。</li><li><strong>预处理器</strong>：一个专门的工具，它扫描包含嵌入式SQL的源代码文件，识别出所有SQL语句，将它们转换为对数据库运行时库（通常基于ODBC或类似接口）的函数调用，并生成一个纯宿主语言的中间文件供编译器编译。</li><li><strong>优点</strong>：结合了SQL强大的数据操作能力和宿主语言的计算、流程控制及输入&#x2F;输出能力，适用于编写复杂的数据处理应用程序。</li></ul><h4 id="语法要素与示例"><a href="#语法要素与示例" class="headerlink" title="语法要素与示例"></a>语法要素与示例</h4><ul><li><strong>语句标识</strong>：所有嵌入式SQL语句都以<code>EXEC SQL</code>开头，以宿主语言特定的结束符结尾（C语言中常用分号<code>;</code>，COBOL中用<code>END-EXEC</code>）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL &lt;SQL语句&gt;;</span><br></pre></td></tr></table></figure></li><li><strong>连接数据库</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CONNECT TO server USER user_name USING password;</span><br></pre></td></tr></table></figure></li><li><strong>共享变量（宿主变量）</strong>：<ul><li>宿主语言的变量可以在嵌入式SQL语句中使用，以<strong>冒号（<code>:</code>）</strong> 作为前缀，以便与SQL自身的列名区分。</li><li>这些共享变量必须在专门的<code>DECLARE SECTION</code>中声明。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;  <span class="comment">// 宿主变量</span></span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>];         <span class="comment">// 用于接收ID</span></span><br><span class="line">    <span class="type">char</span> sn[<span class="number">20</span>];        <span class="comment">// 用于接收name</span></span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 从用户输入或其他地方为credit_amount赋值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL SELECT ID, name INTO :si, :sn</span><br><span class="line">         FROM student</span><br><span class="line">         WHERE tot_cred &gt; :credit_amount; <span class="comment">// 在WHERE子句中使用宿主变量</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="游标（Cursor）：处理多行结果集的关键机制"><a href="#游标（Cursor）：处理多行结果集的关键机制" class="headerlink" title="游标（Cursor）：处理多行结果集的关键机制"></a>游标（Cursor）：处理多行结果集的关键机制</h4><p>当嵌入式SQL查询可能返回多行结果时，无法直接用<code>INTO</code>子句将多行赋值给有限的宿主变量。此时必须使用<strong>游标</strong>。</p><ol><li><p><strong>声明游标</strong>：将游标与一个查询关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name</span><br><span class="line">    FROM student</span><br><span class="line">    WHERE tot_cred &gt; :credit_amount;</span><br></pre></td></tr></table></figure></li><li><p><strong>打开游标</strong>：执行游标关联的查询。此时，DBMS会准备结果集（可能物化到一个临时区域），游标定位在结果集第一行<strong>之前</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL OPEN c;</span><br></pre></td></tr></table></figure><p><strong>重要</strong>：打开游标时，查询中引用的宿主变量（如<code>:credit_amount</code>）的值被“定格”使用。后续修改该宿主变量不会影响已打开的游标结果。</p></li><li><p><strong>提取数据</strong>：将游标向前推进一行，并将该行数据提取到指定的宿主变量中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line"><span class="comment">// 每次FETCH后，需要检查SQL通信区（SQLCA）中的返回码，判断是否成功提取到数据或已到达结果集末尾。</span></span><br></pre></td></tr></table></figure></li><li><p><strong>关闭游标</strong>：释放与游标相关的数据库资源（如临时存储空间、锁等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure></li></ol><p><strong>完整游标使用循环示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;</span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>], sn[<span class="number">20</span>];</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 获取credit_amount的值 ...</span></span><br><span class="line"></span><br><span class="line">EXEC SQL DECLARE c CURSOR FOR</span><br><span class="line">    SELECT ID, name FROM student WHERE tot_cred &gt; :credit_amount;</span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c;</span><br><span class="line"><span class="comment">// 使用SQLCODE（SQLCA中的一个变量）检查状态。0表示成功，100表示无更多数据。</span></span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c INTO :si, :sn;</span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Student: %s, Name: %s\n&quot;</span>, si, sn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c;</span><br></pre></td></tr></table></figure><h4 id="通过游标进行定位更新或删除"><a href="#通过游标进行定位更新或删除" class="headerlink" title="通过游标进行定位更新或删除"></a>通过游标进行定位更新或删除</h4><p>游标不仅可以读取数据，还可以用于更新或删除“当前”行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个用于更新的游标，必须使用FOR UPDATE子句</span></span><br><span class="line">EXEC SQL DECLARE c_upd CURSOR FOR</span><br><span class="line">    SELECT * FROM instructor WHERE dept_name = <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">    FOR UPDATE OF salary; <span class="comment">// 指定可更新的列</span></span><br><span class="line"></span><br><span class="line">EXEC SQL OPEN c_upd;</span><br><span class="line"><span class="keyword">while</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">    EXEC SQL FETCH c_upd INTO ...; <span class="comment">// 将整行数据提取到对应的宿主变量</span></span><br><span class="line">    <span class="keyword">if</span> (SQLCODE == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 更新当前游标指向的行</span></span><br><span class="line">        EXEC SQL UPDATE instructor</span><br><span class="line">                 SET salary = salary + <span class="number">1000</span></span><br><span class="line">                 WHERE CURRENT OF c_upd; <span class="comment">// 关键：定位更新</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EXEC SQL CLOSE c_upd;</span><br></pre></td></tr></table></figure><h2 id="SQL函数与存储过程"><a href="#SQL函数与存储过程" class="headerlink" title="SQL函数与存储过程"></a>SQL函数与存储过程</h2><h3 id="5-2-函数与存储过程"><a href="#5-2-函数与存储过程" class="headerlink" title="5.2 函数与存储过程"></a>5.2 函数与存储过程</h3><p>SQL允许在数据库服务器端创建命名的、可重用的程序化模块：<strong>函数</strong>和<strong>存储过程</strong>。它们可以用SQL语言自身编写，也可以用外部编程语言（如C、Java）编写。</p><ul><li><strong>外部语言函数&#x2F;过程</strong>：适用于处理复杂计算或特定数据类型（如图像、几何对象）。例如，用C编写一个函数来判断两个多边形是否重叠。</li><li><strong>表值函数</strong>：一种特殊函数，可以返回一个关系（表）作为结果。</li><li><strong>SQL的编程扩展</strong>：SQL-99标准引入了丰富的程序化构造，如变量声明、条件语句（IF-THEN-ELSE）、循环（LOOP, WHILE）和赋值，使得用纯SQL编写复杂逻辑成为可能。</li></ul><h4 id="5-2-1-SQL标量函数示例"><a href="#5-2-1-SQL标量函数示例" class="headerlink" title="5.2.1 SQL标量函数示例"></a>5.2.1 SQL标量函数示例</h4><p>创建一个返回指定部门教师人数的函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_count(dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>; <span class="comment">-- 声明局部变量</span></span><br><span class="line">    <span class="comment">-- 将查询结果赋值给局部变量</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count.dept_name;</span><br><span class="line">    <span class="keyword">RETURN</span> d_count; <span class="comment">-- 返回结果</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>使用函数</strong>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在查询中像内置函数一样调用</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, budget</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h4 id="5-2-2-SQL存储过程示例"><a href="#5-2-2-SQL存储过程示例" class="headerlink" title="5.2.2 SQL存储过程示例"></a>5.2.2 SQL存储过程示例</h4><p>将上述功能改写为存储过程。存储过程通常通过<code>OUT</code>参数返回结果，并且不包含<code>RETURN</code>语句（除非是返回状态码）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">IN</span> dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>), <span class="comment">-- 输入参数</span></span><br><span class="line">    <span class="keyword">OUT</span> d_count <span class="type">INTEGER</span>       <span class="comment">-- 输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong>：</p><ul><li>从另一个SQL过程或脚本中调用：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">CALL</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>, d_count);</span><br></pre></td></tr></table></figure></li><li>从嵌入式SQL中调用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXEC SQL BEGIN DECLARE SECTION;</span><br><span class="line">    integer d_count;</span><br><span class="line">    <span class="type">char</span> dept_name[] = <span class="string">&quot;Physics&quot;</span>;</span><br><span class="line">EXEC SQL END DECLARE SECTION;</span><br><span class="line">EXEC SQL CALL <span class="title function_">dept_count_proc</span><span class="params">(:dept_name, :d_count)</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-3-优势与存储"><a href="#5-2-3-优势与存储" class="headerlink" title="5.2.3 优势与存储"></a>5.2.3 优势与存储</h4><p>函数和存储过程在创建时被<strong>编译和优化</strong>，生成执行计划并存储在数据库的系统目录中（如图所示，在SQL Server中位于“可编程性”下的“函数”和“存储过程”节点）。应用程序只需调用其名称，无需再次进行语法分析和优化，因此具有以下优点：</p><ul><li><strong>性能提升</strong>：减少重复编译开销。</li><li><strong>减少网络流量</strong>：将复杂运算放在服务器端，只传递参数和结果。</li><li><strong>代码重用与封装</strong>：业务逻辑集中存储在数据库，多个应用可共享，确保一致性，便于维护。</li><li><strong>增强安全性</strong>：可以通过授权控制用户对过程和函数的执行权限，而不直接暴露底层表。</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="5-3-触发器"><a href="#5-3-触发器" class="headerlink" title="5.3 触发器"></a>5.3 触发器</h3><h4 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h4><ul><li><strong>定义</strong>：触发器是存储在数据库中的一种特殊类型的存储过程，它<strong>自动执行</strong>，以作为对数据库中特定表进行数据修改（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）的“副作用”。</li><li><strong>本质</strong>：一种基于<strong>事件-条件-动作</strong>模型的完整性维护和业务规则执行机制。<ul><li><strong>事件</strong>：什么操作（增、删、改）会触发它。</li><li><strong>条件</strong>：（可选）触发后，在什么条件下才执行动作。</li><li><strong>动作</strong>：当事件发生且条件满足时要执行的SQL语句（补救措施或额外操作）。</li></ul></li><li><strong>历史</strong>：触发器概念在SQL-99标准中正式引入，但很多数据库厂商在此前就已通过非标准语法提供了支持。<strong>注意</strong>：不同DBMS的触发器语法细节（尤其是引用新旧行、语句级触发）可能存在差异。</li></ul><h4 id="5-3-2-触发事件与动作"><a href="#5-3-2-触发事件与动作" class="headerlink" title="5.3.2 触发事件与动作"></a>5.3.2 触发事件与动作</h4><ul><li><strong>触发事件</strong>：可以是<code>INSERT</code>、<code>DELETE</code>或<code>UPDATE</code>。</li><li><strong>更新触发器的粒度</strong>：对于<code>UPDATE</code>触发器，可以限定只在特定列被更新时才触发。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes <span class="comment">-- 只在grade列被更新时触发</span></span><br></pre></td></tr></table></figure></li><li><strong>引用新旧行值</strong>：<ul><li><code>REFERENCING OLD ROW AS</code>：用于在<code>DELETE</code>和<code>UPDATE</code>触发器中引用<strong>修改前</strong>的旧行数据。</li><li><code>REFERENCING NEW ROW AS</code>：用于在<code>INSERT</code>和<code>UPDATE</code>触发器中引用<strong>修改后</strong>的新行数据（对于<code>INSERT</code>，旧行不存在；对于<code>DELETE</code>，新行不存在）。</li></ul></li><li><strong>触发时机</strong>：<code>BEFORE</code>或<code>AFTER</code>。<ul><li><code>BEFORE</code>触发器：在约束检查<strong>之前</strong>、操作实际修改数据<strong>之前</strong>执行。常用于数据清洗、转换或执行额外约束。</li><li><code>AFTER</code>触发器：在操作已成功执行、约束检查通过<strong>之后</strong>执行。常用于审计、维护衍生数据或执行级联操作。</li></ul></li></ul><h4 id="5-3-3-行级触发器示例详解"><a href="#5-3-3-行级触发器示例详解" class="headerlink" title="5.3.3 行级触发器示例详解"></a>5.3.3 行级触发器示例详解</h4><ol><li><p><strong><code>BEFORE</code>触发器示例：数据清洗</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> setnull_trigger BEFORE <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>) <span class="comment">-- 触发条件：新成绩为空字符串</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">SET</span> nrow.grade <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 动作：在插入前将其设为NULL</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>逻辑</strong>：当更新<code>takes</code>表的<code>grade</code>列时，如果新值是空字符串，则在数据真正写入表之前，将其更改为<code>NULL</code>。</li><li><strong>关键</strong>：因为是<code>INSERT</code>或<code>UPDATE</code>操作，所以可以引用<code>NEW ROW</code>。<code>BEFORE</code>触发器有能力修改即将被写入的<code>NEW ROW</code>的值。</li></ul></li><li><p><strong><code>AFTER</code>触发器示例：维护复杂的参照完整性</strong><br>假设我们有不使用外键约束，或用触发器实现比外键更复杂规则的需求。</p><ul><li><p><strong>示例1：插入<code>section</code>时检查<code>time_slot_id</code>是否存在</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>; <span class="comment">-- 动作：回滚整个插入事务</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：试图插入一条<code>section</code>记录，其<code>time_slot_id</code>为‘3-5节’，但<code>timeslot</code>表中并无此时间段定义。</li><li><strong>动作</strong>：<code>ROLLBACK</code>会撤销导致触发器激活的整个<code>INSERT</code>事务，阻止非法数据进入。</li></ul></li><li><p><strong>示例2：删除<code>timeslot</code>时，确保不被<code>section</code>引用</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> timeslot</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (</span><br><span class="line">    <span class="comment">-- 条件1：被删除的time_slot_id是表中该ID的最后一条记录</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot)</span><br><span class="line">    <span class="keyword">AND</span></span><br><span class="line">    <span class="comment">-- 条件2：并且该ID仍在section表中被引用</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> section)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：删除<code>timeslot</code>表中关于‘1-2节’的最后一条记录，但<code>section</code>表中仍有课程安排使用‘1-2节’。</li><li><strong>逻辑</strong>：<code>WHEN</code>子句中的条件确保只在删除某个<code>time_slot_id</code>的<strong>最后一个</strong>实例，且该ID仍被参照时，才触发回滚。这比简单的外键<code>ON DELETE RESTRICT</code>更精细。</li></ul></li></ul></li><li><p><strong><code>AFTER</code>触发器示例：自动维护派生属性（冗余数据）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">      <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> credits</span><br><span class="line">        <span class="keyword">FROM</span> course</span><br><span class="line">        <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> student.ID <span class="operator">=</span> nrow.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>场景</strong>：学生一门课的成绩从不及格(‘F’)或空，更新为及格（非‘F’且非空）。</li><li><strong>条件</strong>：<code>WHEN</code>子句精确捕捉了这种“状态转变”。</li><li><strong>动作</strong>：根据<code>nrow.course_id</code>找到课程学分，累加到对应学生(<code>nrow.ID</code>)的总学分<code>tot_cred</code>中。这是一个典型的用触发器维护数据一致性的例子。</li></ul></li></ol><h4 id="5-3-4-语句级触发器"><a href="#5-3-4-语句级触发器" class="headerlink" title="5.3.4 语句级触发器"></a>5.3.4 语句级触发器</h4><p>行级触发器（<code>FOR EACH ROW</code>）对受影响的每一行都执行一次动作。如果一条语句更新了1000行，则触发器动作会执行1000次。</p><ul><li><strong>语句级触发器</strong>：使用<code>FOR EACH STATEMENT</code>（默认），整个触发事件（一条SQL语句）只触发一次动作，无论该语句影响了多少行。</li><li><strong>引用过渡表</strong>：使用<code>REFERENCING OLD TABLE AS</code> 或 <code>REFERENCING NEW TABLE AS</code> 来引用包含所有被影响行的旧值或新值的<strong>临时表</strong>（称为过渡表）。</li><li><strong>优点</strong>：当触发动作不依赖于单行数据，或需要对所有受影响行进行聚合操作时，语句级触发器<strong>效率高得多</strong>。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> log_salary_update AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> instructor</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> old_vals</span><br><span class="line">            <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> new_vals</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="comment">-- 将本次批量更新的摘要记录到审计表</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> salary_audit(update_time, avg_increase)</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>, <span class="built_in">AVG</span>(new_vals.salary <span class="operator">-</span> old_vals.salary)</span><br><span class="line">    <span class="keyword">FROM</span> old_vals, new_vals</span><br><span class="line">    <span class="keyword">WHERE</span> old_vals.ID <span class="operator">=</span> new_vals.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-3-5-何时应避免使用触发器"><a href="#5-3-5-何时应避免使用触发器" class="headerlink" title="5.3.5 何时应避免使用触发器"></a>5.3.5 何时应避免使用触发器</h4><p>尽管触发器功能强大，但在现代数据库系统中，许多传统的触发器应用场景已有更好替代方案：</p><ol><li><p><strong>维护汇总数据（如部门总薪资）</strong>：</p><ul><li><strong>旧方式</strong>：在<code>instructor</code>表上设置<code>AFTER INSERT/UPDATE/DELETE</code>触发器，实时更新<code>department</code>表的一个<code>total_salary</code>字段。</li><li><strong>现代方式</strong>：使用<strong>物化视图</strong>。数据库系统自动维护物化视图的更新，通常比手动编写的触发器更高效、可靠。</li></ul></li><li><p><strong>数据库复制</strong>：</p><ul><li><strong>旧方式</strong>：用触发器将变更记录到“增量表”（change&#x2F;delta relations），再由独立进程读取并应用到副本。</li><li><strong>现代方式</strong>：使用数据库内置的<strong>复制技术</strong>（如基于日志的复制、逻辑复制）。这些功能更健壮，对性能影响更小。</li></ul></li><li><p><strong>简单的数据验证</strong>：</p><ul><li><strong>首选</strong>：应尽量使用声明式的<strong>完整性约束</strong>（<code>NOT NULL</code>, <code>UNIQUE</code>, <code>CHECK</code>, <code>FOREIGN KEY</code>）。约束更易于声明、理解和维护，并由DBMS优化执行。</li></ul></li><li><p><strong>过度复杂的业务逻辑</strong>：</p><ul><li><strong>问题</strong>：将大量核心业务逻辑放入触发器，会造成“逻辑黑洞”，使得数据变更行为难以理解和调试，也增加了应用与数据库的耦合度。</li><li><strong>建议</strong>：核心业务逻辑应放在应用层或中间件，数据库主要负责数据存储和基础完整性。触发器仅用于处理与数据本身紧密相关、原子性的规则。</li></ul></li></ol><h2 id="本章总结与展望"><a href="#本章总结与展望" class="headerlink" title="本章总结与展望"></a>本章总结与展望</h2><h3 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h3><p>第五章“高级SQL”系统性地讲解了将SQL与程序设计及数据库内部自动化逻辑相结合的高级技术。</p><ol><li><strong>从编程语言访问SQL</strong>：掌握了<strong>动态SQL</strong>（JDBC, ODBC）和<strong>嵌入式SQL</strong>两种集成范式。理解了连接管理、预编译语句、事务控制、元数据访问等核心编程接口，能够构建健壮的数据库应用程序。</li><li><strong>函数与存储过程</strong>：学会了在数据库服务器端创建可重用的程序单元，封装业务逻辑，提升性能、安全性和代码可维护性。</li><li><strong>触发器</strong>：深入理解了基于<strong>事件-条件-动作</strong>模型的自动化机制。能够设计行级和语句级触发器，用于实现复杂的完整性约束、审计跟踪和衍生数据维护。同时，也认识到应优先使用声明式约束和现代数据库内置功能，谨慎而有选择地使用触发器。</li></ol><h3 id="后续章节展望（简要提及）"><a href="#后续章节展望（简要提及）" class="headerlink" title="后续章节展望（简要提及）"></a>后续章节展望（简要提及）</h3><p>本章末尾指出，高级SQL的主题还包含其他重要内容，将在后续可能展开：</p><ul><li><strong>5.4 递归查询</strong>：用于处理具有层次结构或图结构的数据（如组织结构、物料清单BOM）。</li><li><strong>5.5 高级聚合函数</strong>：超越<code>SUM</code>、<code>AVG</code>，如<code>ROLLUP</code>、<code>CUBE</code>、<code>GROUPING SETS</code>用于多维分析，以及窗口函数（<code>OVER</code>子句）用于行间计算。</li><li><strong>5.6 流程化函数</strong>：可能指更复杂的流程控制语句在SQL程序中的应用。</li></ul><hr><p><strong>结束</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高级SQL 简读</title>
      <link href="/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/24/DB_%E9%AB%98%E7%BA%A7SQL%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章：从编程语言访问-SQL"><a href="#第一章：从编程语言访问-SQL" class="headerlink" title="第一章：从编程语言访问 SQL"></a>第一章：从编程语言访问 SQL</h2><h3 id="1-1-概述：数据库应用系统架构"><a href="#1-1-概述：数据库应用系统架构" class="headerlink" title="1.1 概述：数据库应用系统架构"></a>1.1 概述：数据库应用系统架构</h3><p>数据库应用系统 (DBAS) 由用户 (Users)、应用程序 (Application Programs)、数据库管理系统 (DBMS) 和数据库 (DB) 四部分组成。应用程序需要与数据库服务器进行交互，这通常通过应用程序编程接口 (API) 实现。一个典型的交互流程包括：</p><ol><li>连接数据库服务器。</li><li>向数据库服务器发送 SQL 命令。</li><li>将查询结果集中的元组逐个提取到程序变量中进行处理。</li></ol><h3 id="1-2-访问-SQL-的两种主要途径"><a href="#1-2-访问-SQL-的两种主要途径" class="headerlink" title="1.2 访问 SQL 的两种主要途径"></a>1.2 访问 SQL 的两种主要途径</h3><h4 id="1-2-1-动态-SQL"><a href="#1-2-1-动态-SQL" class="headerlink" title="1.2.1 动态 SQL"></a>1.2.1 动态 SQL</h4><ul><li><strong>定义</strong>：在通用编程语言（如 Java、C、C++）中，程序将 SQL 查询动态构建为字符串，然后通过 API 函数提交给数据库并获取结果。</li><li><strong>特点</strong>：<ul><li>查询在运行时构建和发送，非常灵活。</li><li>需要在程序中显式处理连接、语句执行和结果集获取。</li></ul></li><li><strong>主流技术</strong>：<ul><li><strong>JDBC</strong>：用于 Java 语言的数据库连接标准。</li><li><strong>ODBC</strong>：一种开放的、与语言无关的数据库连接标准，支持 C、C++ 等多种语言。</li></ul></li></ul><h4 id="1-2-2-嵌入式-SQL"><a href="#1-2-2-嵌入式-SQL" class="headerlink" title="1.2.2 嵌入式 SQL"></a>1.2.2 嵌入式 SQL</h4><ul><li><strong>定义</strong>：将 SQL 语句直接嵌入到宿主语言（如 C、COBOL）的源代码中。在编译时，由预处理器将这些 SQL 语句转换为特定数据库 API 的函数调用。</li><li><strong>特点</strong>：<ul><li>SQL 语句在编译时确定，可进行早期语法检查和优化。</li><li>编程模型更接近原生 SQL，通常通过游标处理结果集。</li><li>最终实现依赖于底层的动态 SQL 机制。</li></ul></li></ul><h3 id="1-3-JDBC-详解"><a href="#1-3-JDBC-详解" class="headerlink" title="1.3 JDBC 详解"></a>1.3 JDBC 详解</h3><p>JDBC 是 Java 数据库连接的标准 API，它提供了一套用于执行 SQL 语句、检索结果以及访问数据库元数据的接口。</p><h4 id="1-3-1-JDBC-核心编程模型"><a href="#1-3-1-JDBC-核心编程模型" class="headerlink" title="1.3.1 JDBC 核心编程模型"></a>1.3.1 JDBC 核心编程模型</h4><p>一个典型的 JDBC 程序包含以下步骤，如示例代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">JDBCexample</span><span class="params">(String userid, String passwd)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 加载数据库驱动程序 (JDBC 4+ 可省略)</span></span><br><span class="line">        Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br><span class="line">        <span class="comment">// 2. 建立数据库连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(</span><br><span class="line">            <span class="string">&quot;jdbc:oracle:thin:@db.yale.edu:1521:univdb&quot;</span>,</span><br><span class="line">            userid, passwd);</span><br><span class="line">        <span class="comment">// 3. 创建语句对象</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line">        <span class="comment">// 4a. 执行数据更新操作</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stmt.executeUpdate(</span><br><span class="line">                <span class="string">&quot;insert into instructor values(&#x27;77987&#x27;, &#x27;Kim&#x27;, &#x27;Physics&#x27;, 98000)&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException sqle) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Could not insert tuple. &quot;</span> + sqle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4b. 执行查询并处理结果集</span></span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rset</span> <span class="operator">=</span> stmt.executeQuery(</span><br><span class="line">            <span class="string">&quot;select dept_name, avg(salary) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from instructor &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by dept_name&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (rset.next()) &#123;</span><br><span class="line">            System.out.println(rset.getString(<span class="string">&quot;dept_name&quot;</span>) + <span class="string">&quot; &quot;</span> + rset.getFloat(<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 清理资源</span></span><br><span class="line">        stmt.close();</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception sqle) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Exception: &quot;</span> + sqle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-2-关键组件与步骤解析"><a href="#1-3-2-关键组件与步骤解析" class="headerlink" title="1.3.2 关键组件与步骤解析"></a>1.3.2 关键组件与步骤解析</h4><ol><li><strong>加载驱动</strong>：<code>Class.forName()</code> 用于显式加载 JDBC 驱动类。自 JDBC 4.0 (Java 6) 起，支持驱动自动发现，此步骤可省略。</li><li><strong>建立连接</strong>：通过 <code>DriverManager.getConnection(url, user, password)</code> 获取 <code>Connection</code> 对象。URL 格式因数据库而异。</li><li><strong>创建语句</strong>：使用 <code>Connection.createStatement()</code> 创建 <code>Statement</code> 对象，用于发送静态 SQL 语句。</li><li><strong>执行语句</strong>：<ul><li><strong>更新操作</strong>：使用 <code>executeUpdate()</code> 执行 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CREATE TABLE</code> 等语句，返回受影响的行数。</li><li><strong>查询操作</strong>：使用 <code>executeQuery()</code> 执行 <code>SELECT</code> 语句，返回一个 <code>ResultSet</code> 对象。</li></ul></li><li><strong>处理结果集</strong>：<ul><li><code>ResultSet.next()</code> 方法将游标移动到下一行，如果有数据则返回 <code>true</code>。</li><li>使用 <code>getString(columnLabel/Index)</code>、<code>getInt()</code>、<code>getFloat()</code> 等方法获取当前行的列值。</li><li>可以使用列名（字符串）或列索引（从1开始）指定列。</li></ul></li><li><strong>处理空值</strong>：可以使用 <code>ResultSet.wasNull()</code> 方法检查上一次 <code>getXXX()</code> 调用读取的值是否为 SQL <code>NULL</code>。</li><li><strong>异常处理</strong>：使用 <code>try-catch</code> 块捕获 <code>SQLException</code>。</li><li><strong>资源关闭</strong>：必须显式关闭 <code>ResultSet</code>、<code>Statement</code> 和 <code>Connection</code> 对象以释放数据库资源。现代 Java 可使用 <code>try-with-resources</code> 语法自动管理。</li></ol><h4 id="1-3-3-预编译语句"><a href="#1-3-3-预编译语句" class="headerlink" title="1.3.3 预编译语句"></a>1.3.3 预编译语句</h4><p>为了提升性能和安全（防止SQL注入），应使用 <code>PreparedStatement</code>。</p><ul><li><strong>原理</strong>：SQL 语句被预编译并存储在数据库中，其中参数用 <code>?</code> 占位。执行时只需传入参数值。</li><li><strong>优点</strong>：高效（多次执行同一模板语句时无需重复编译）、安全（参数值会被正确转义）。</li><li><strong>示例</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into instructor values(?,?,?,?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pStmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88877&quot;</span>); <span class="comment">// 设置第一个?的值，索引从1开始</span></span><br><span class="line">pStmt.setString(<span class="number">2</span>, <span class="string">&quot;Perry&quot;</span>);</span><br><span class="line">pStmt.setString(<span class="number">3</span>, <span class="string">&quot;Finance&quot;</span>);</span><br><span class="line">pStmt.setInt(<span class="number">4</span>, <span class="number">125000</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br><span class="line"><span class="comment">// 重用同一PreparedStatement插入另一条记录</span></span><br><span class="line">pStmt.setString(<span class="number">1</span>, <span class="string">&quot;88878&quot;</span>);</span><br><span class="line">pStmt.executeUpdate();</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-4-元数据检索"><a href="#1-3-4-元数据检索" class="headerlink" title="1.3.4 元数据检索"></a>1.3.4 元数据检索</h4><p>JDBC 允许程序动态探查数据库的结构。</p><ul><li><strong>结果集元数据</strong> (<code>ResultSetMetaData</code>)：获取查询结果的列信息。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"><span class="type">int</span> <span class="variable">columnCount</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Column name: &quot;</span> + rsmd.getColumnName(i));</span><br><span class="line">    System.out.println(<span class="string">&quot;Column type: &quot;</span> + rsmd.getColumnTypeName(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>数据库元数据</strong> (<code>DatabaseMetaData</code>)：获取数据库整体信息，如表、列、主键等。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"><span class="comment">// 获取指定表的所有列信息</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> dbmd.getColumns(<span class="literal">null</span>, <span class="string">&quot;univdb&quot;</span>, <span class="string">&quot;department&quot;</span>, <span class="string">&quot;%&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    System.out.println(rs.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>) + <span class="string">&quot;: &quot;</span> + rs.getString(<span class="string">&quot;TYPE_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取指定表的主键信息</span></span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">pkRs</span> <span class="operator">=</span> dbmd.getPrimaryKeys(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;department&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (pkRs.next()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;PK Seq: &quot;</span> + pkRs.getString(<span class="string">&quot;KEY_SEQ&quot;</span>) +</span><br><span class="line">                       <span class="string">&quot;, Column: &quot;</span> + pkRs.getString(<span class="string">&quot;COLUMN_NAME&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-5-事务控制"><a href="#1-3-5-事务控制" class="headerlink" title="1.3.5 事务控制"></a>1.3.5 事务控制</h4><p>默认情况下，JDBC 处于自动提交模式，每条 SQL 语句都是一个独立的事务。</p><ul><li><strong>手动管理事务</strong>：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">conn.setAutoCommit(<span class="literal">false</span>); <span class="comment">// 关闭自动提交</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 执行多条更新语句</span></span><br><span class="line">    stmt.executeUpdate(...);</span><br><span class="line">    stmt.executeUpdate(...);</span><br><span class="line">    conn.commit(); <span class="comment">// 提交事务</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    conn.rollback(); <span class="comment">// 发生错误时回滚</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    conn.setAutoCommit(<span class="literal">true</span>); <span class="comment">// 恢复自动提交</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-6-调用存储过程和函数"><a href="#1-3-6-调用存储过程和函数" class="headerlink" title="1.3.6 调用存储过程和函数"></a>1.3.6 调用存储过程和函数</h4><p>使用 <code>CallableStatement</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt1</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;? = call some_function(?)&#125;&quot;</span>);</span><br><span class="line">cStmt1.registerOutParameter(<span class="number">1</span>, Types.INTEGER); <span class="comment">// 注册输出参数</span></span><br><span class="line">cStmt1.setInt(<span class="number">2</span>, <span class="number">100</span>); <span class="comment">// 设置输入参数</span></span><br><span class="line">cStmt1.execute();</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> cStmt1.getInt(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用存储过程</span></span><br><span class="line"><span class="type">CallableStatement</span> <span class="variable">cStmt2</span> <span class="operator">=</span> conn.prepareCall(<span class="string">&quot;&#123;call some_procedure(?,?)&#125;&quot;</span>);</span><br><span class="line">cStmt2.setString(<span class="number">1</span>, <span class="string">&quot;param1&quot;</span>);</span><br><span class="line">cStmt2.setInt(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">cStmt2.execute();</span><br></pre></td></tr></table></figure><h3 id="1-4-ODBC-详解"><a href="#1-4-ODBC-详解" class="headerlink" title="1.4 ODBC 详解"></a>1.4 ODBC 详解</h3><p>ODBC 是一个与编程语言和数据库无关的调用级接口标准。</p><h4 id="1-4-1-ODBC-架构"><a href="#1-4-1-ODBC-架构" class="headerlink" title="1.4.1 ODBC 架构"></a>1.4.1 ODBC 架构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用程序 → ODBC API → ODBC 驱动程序管理器 → 特定DB的ODBC驱动 → 数据库</span><br></pre></td></tr></table></figure><ul><li><strong>驱动程序管理器</strong>：负责加载、卸载驱动程序，并作为应用程序的入口点。</li><li><strong>驱动程序</strong>：由数据库厂商提供，负责将标准的 ODBC 调用转换为特定数据库的通信协议。</li></ul><h4 id="1-4-2-ODBC-C-语言编程示例"><a href="#1-4-2-ODBC-C-语言编程示例" class="headerlink" title="1.4.2 ODBC C 语言编程示例"></a>1.4.2 ODBC C 语言编程示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sqlext.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    RETCODE error; <span class="comment">// 返回码</span></span><br><span class="line">    HENV env;      <span class="comment">// 环境句柄</span></span><br><span class="line">    HDBC conn;     <span class="comment">// 连接句柄</span></span><br><span class="line">    HSTMT stmt;    <span class="comment">// 语句句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分配环境句柄</span></span><br><span class="line">    SQLAllocEnv(&amp;env);</span><br><span class="line">    <span class="comment">// 2. 分配连接句柄</span></span><br><span class="line">    SQLAllocConnect(env, &amp;conn);</span><br><span class="line">    <span class="comment">// 3. 建立连接</span></span><br><span class="line">    SQLConnect(conn, <span class="string">&quot;db.yale.edu&quot;</span>, SQL_NTS, <span class="string">&quot;avi&quot;</span>, SQL_NTS, <span class="string">&quot;avipasswd&quot;</span>, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 分配语句句柄</span></span><br><span class="line">    SQLAllocStmt(conn, &amp;stmt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 执行SQL语句</span></span><br><span class="line">    <span class="type">char</span> *sqlquery = <span class="string">&quot;select dept_name, sum(salary) from instructor group by dept_name&quot;</span>;</span><br><span class="line">    error = SQLExecDirect(stmt, sqlquery, SQL_NTS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error == SQL_SUCCESS) &#123;</span><br><span class="line">        <span class="comment">// 6. 绑定结果列到C变量</span></span><br><span class="line">        <span class="type">char</span> deptname[<span class="number">80</span>];</span><br><span class="line">        <span class="type">float</span> salary;</span><br><span class="line">        SQLINTEGER lenOut1, lenOut2;</span><br><span class="line">        SQLBindCol(stmt, <span class="number">1</span>, SQL_C_CHAR, deptname, <span class="number">80</span>, &amp;lenOut1);</span><br><span class="line">        SQLBindCol(stmt, <span class="number">2</span>, SQL_C_FLOAT, &amp;salary, <span class="number">0</span>, &amp;lenOut2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 逐行获取结果</span></span><br><span class="line">        <span class="keyword">while</span> (SQLFetch(stmt) == SQL_SUCCESS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot; %s %g\n&quot;</span>, deptname, salary);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 清理资源</span></span><br><span class="line">    SQLFreeStmt(stmt, SQL_DROP);</span><br><span class="line">    SQLDisconnect(conn);</span><br><span class="line">    SQLFreeConnect(conn);</span><br><span class="line">    SQLFreeEnv(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-3-连接时长管理"><a href="#1-4-3-连接时长管理" class="headerlink" title="1.4.3 连接时长管理"></a>1.4.3 连接时长管理</h4><ul><li>实际数据库平台对客户端连接时长有限制（如默认60秒）。</li><li>如果 SQL 查询执行时间超过连接时长，操作会被强行终止。</li><li>可通过 ODBC API (<code>SQLSetConnectAttr</code>) 或连接字符串参数调整连接超时设置，以确保长时间操作顺利完成。</li></ul><h3 id="1-5-嵌入式-SQL-详解"><a href="#1-5-嵌入式-SQL-详解" class="headerlink" title="1.5 嵌入式 SQL 详解"></a>1.5 嵌入式 SQL 详解</h3><h4 id="1-5-1-基本概念"><a href="#1-5-1-基本概念" class="headerlink" title="1.5.1 基本概念"></a>1.5.1 基本概念</h4><ul><li><strong>宿主语言</strong>：嵌入 SQL 语句的通用编程语言，如 C、COBOL。</li><li><strong>工作原理</strong>：源代码通过预处理器，将嵌入式 SQL 语句转换为对数据库运行时库的函数调用，然后再由宿主语言编译器编译。</li><li><strong>优点</strong>：结合了 SQL 强大的数据操作能力和宿主语言的计算、流程控制能力。</li></ul><h4 id="1-5-2-语法与示例"><a href="#1-5-2-语法与示例" class="headerlink" title="1.5.2 语法与示例"></a>1.5.2 语法与示例</h4><ul><li><strong>声明共享变量</strong>：宿主语言变量需在特殊声明节中声明，并在 SQL 语句前加冒号 (<code>:</code>) 引用。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">    <span class="type">int</span> credit_amount;</span><br><span class="line">    <span class="type">char</span> si[<span class="number">5</span>];</span><br><span class="line">    <span class="type">char</span> sn[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br></pre></td></tr></table></figure></li><li><strong>连接数据库</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CONNECT</span> <span class="keyword">TO</span> server <span class="keyword">USER</span> user_name <span class="keyword">USING</span> password;</span><br></pre></td></tr></table></figure></li><li><strong>静态 SQL 查询与游标</strong>：当查询返回多行结果时，必须使用游标。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 声明游标</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> c <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> ID, name <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> tot_cred <span class="operator">&gt;</span> :credit_amount;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 打开游标（执行查询）</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 循环获取数据</span><br><span class="line">while (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> :si, :sn;</span><br><span class="line">    if (sqlca.sqlcode <span class="operator">!=</span> <span class="number">0</span>) break; <span class="operator">/</span><span class="operator">/</span> 使用 SQLCA 检查状态</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 处理 si, sn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 关闭游标</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></table></figure></li><li><strong>通过游标更新数据</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">DECLARE</span> c <span class="keyword">CURSOR</span> <span class="keyword">FOR</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> instructor <span class="keyword">WHERE</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span></span><br><span class="line">    <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="operator">/</span><span class="operator">/</span> 声明为可更新游标</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">OPEN</span> c;</span><br><span class="line">while (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">FETCH</span> c <span class="keyword">INTO</span> ...;</span><br><span class="line">    if (no_more_data) break;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 更新当前游标指向的行</span><br><span class="line">    <span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">UPDATE</span> instructor</span><br><span class="line">             <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">1000</span></span><br><span class="line">             <span class="keyword">WHERE</span> <span class="keyword">CURRENT</span> <span class="keyword">OF</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CLOSE</span> c;</span><br></pre></td></tr></table></figure></li></ul><h2 id="第二章：SQL-函数与存储过程"><a href="#第二章：SQL-函数与存储过程" class="headerlink" title="第二章：SQL 函数与存储过程"></a>第二章：SQL 函数与存储过程</h2><h3 id="2-1-SQL-函数"><a href="#2-1-SQL-函数" class="headerlink" title="2.1 SQL 函数"></a>2.1 SQL 函数</h3><p>函数是接受参数、执行计算并返回一个标量值的命名程序单元。</p><h4 id="2-1-1-创建-SQL-标量函数"><a href="#2-1-1-创建-SQL-标量函数" class="headerlink" title="2.1.1 创建 SQL 标量函数"></a>2.1.1 创建 SQL 标量函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一个返回指定部门教师人数的函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> dept_count(dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>))</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count.dept_name;</span><br><span class="line">    <span class="keyword">RETURN</span> d_count;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>说明</strong>：<ul><li><code>RETURNS</code> 指定返回值的类型。</li><li><code>BEGIN ... END</code> 定义函数体。</li><li><code>DECLARE</code> 用于声明局部变量。</li><li><code>SELECT ... INTO</code> 将查询结果赋值给变量。</li><li><code>RETURN</code> 语句返回值。</li></ul></li></ul><h4 id="2-1-2-使用-SQL-函数"><a href="#2-1-2-使用-SQL-函数" class="headerlink" title="2.1.2 使用 SQL 函数"></a>2.1.2 使用 SQL 函数</h4><p>函数可以在 SQL 语句中像内置函数一样使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询教师人数超过12人的院系及其预算</span></span><br><span class="line"><span class="keyword">SELECT</span> dept_name, budget</span><br><span class="line"><span class="keyword">FROM</span> department</span><br><span class="line"><span class="keyword">WHERE</span> dept_count(dept_name) <span class="operator">&gt;</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-SQL-存储过程"><a href="#2-2-SQL-存储过程" class="headerlink" title="2.2 SQL 存储过程"></a>2.2 SQL 存储过程</h3><p>存储过程与函数类似，但通常不直接返回值，而是通过输出参数返回结果，并且可以执行更复杂的操作，包括数据修改。</p><h4 id="2-2-1-创建存储过程"><a href="#2-2-1-创建存储过程" class="headerlink" title="2.2.1 创建存储过程"></a>2.2.1 创建存储过程</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> dept_count_proc(</span><br><span class="line">    <span class="keyword">IN</span> dept_name <span class="type">VARCHAR</span>(<span class="number">20</span>),   <span class="comment">-- 输入参数</span></span><br><span class="line">    <span class="keyword">OUT</span> d_count <span class="type">INTEGER</span>         <span class="comment">-- 输出参数</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> d_count</span><br><span class="line">    <span class="keyword">FROM</span> instructor</span><br><span class="line">    <span class="keyword">WHERE</span> instructor.dept_name <span class="operator">=</span> dept_count_proc.dept_name;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-调用存储过程"><a href="#2-2-2-调用存储过程" class="headerlink" title="2.2.2 调用存储过程"></a>2.2.2 调用存储过程</h4><ul><li><strong>从嵌入式 SQL 中调用</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">BEGIN</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line">    <span class="type">integer</span> d_count;</span><br><span class="line">    <span class="type">char</span> dept_name[] <span class="operator">=</span> &quot;Physics&quot;;</span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">END</span> <span class="keyword">DECLARE</span> SECTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">EXEC</span> <span class="keyword">SQL</span> <span class="keyword">CALL</span> dept_count_proc(:dept_name, :d_count);</span><br></pre></td></tr></table></figure></li><li><strong>从动态 SQL (JDBC&#x2F;CallableStatement) 中调用</strong>：如前文 JDBC 部分所示。</li><li><strong>从 SQL 脚本或其他过程中调用</strong>：  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> d_count <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">CALL</span> dept_count_proc(<span class="string">&#x27;Physics&#x27;</span>, d_count);</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-优势与存储"><a href="#2-3-优势与存储" class="headerlink" title="2.3 优势与存储"></a>2.3 优势与存储</h3><ul><li><strong>预编译与优化</strong>：函数和存储过程在创建时即被编译和优化，生成执行计划并存储在数据库字典中。</li><li><strong>性能提升</strong>：应用程序调用时无需重复进行语法分析、优化，直接执行，效率高。</li><li><strong>减少网络流量</strong>：将复杂逻辑在数据库端执行，只返回结果，避免了大量中间数据的传输。</li><li><strong>代码重用与封装</strong>：业务逻辑被封装在数据库中，可供多个应用程序共享，保证一致性。</li></ul><h2 id="第三章：触发器"><a href="#第三章：触发器" class="headerlink" title="第三章：触发器"></a>第三章：触发器</h2><h3 id="3-1-触发器概述"><a href="#3-1-触发器概述" class="headerlink" title="3.1 触发器概述"></a>3.1 触发器概述</h3><h4 id="3-1-1-定义与模型"><a href="#3-1-1-定义与模型" class="headerlink" title="3.1.1 定义与模型"></a>3.1.1 定义与模型</h4><p>触发器是一种特殊的存储过程，它<strong>自动响应</strong>数据库表上的特定数据修改事件（<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>），并根据预定义的条件执行相应的动作。</p><ul><li><strong>事件</strong>：引发触发器执行的操作（插入、更新、删除）。</li><li><strong>条件</strong>：（可选）一个布尔表达式，当条件为真时，触发器动作才执行。</li><li><strong>动作</strong>：触发器要执行的一系列 SQL 语句，用于实现数据检查、完整性维护或业务逻辑。</li></ul><h4 id="3-1-2-语法概览"><a href="#3-1-2-语法概览" class="headerlink" title="3.1.2 语法概览"></a>3.1.2 语法概览</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> trigger_name</span><br><span class="line">&#123;BEFORE <span class="operator">|</span> AFTER&#125; &#123;<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="keyword">OF</span> column_list&#125;</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br><span class="line">[<span class="keyword">REFERENCING</span> &#123;<span class="keyword">OLD</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] old_name <span class="operator">|</span> <span class="keyword">NEW</span> [<span class="type">ROW</span>] [<span class="keyword">AS</span>] new_name</span><br><span class="line">             <span class="operator">|</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] old_table_name <span class="operator">|</span> <span class="keyword">NEW</span> <span class="keyword">TABLE</span> [<span class="keyword">AS</span>] new_table_name&#125;]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">EACH</span> &#123;<span class="type">ROW</span> <span class="operator">|</span> STATEMENT&#125;]</span><br><span class="line">[<span class="keyword">WHEN</span> (<span class="keyword">condition</span>)]</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="comment">-- 触发动作体 (SQL 语句)</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="3-2-行级触发器"><a href="#3-2-行级触发器" class="headerlink" title="3.2 行级触发器"></a>3.2 行级触发器</h3><p>行级触发器对受事件影响的每一行都执行一次触发动作。</p><h4 id="3-2-1-引用新旧行值"><a href="#3-2-1-引用新旧行值" class="headerlink" title="3.2.1 引用新旧行值"></a>3.2.1 引用新旧行值</h4><p>在触发器体内，可以引用被修改行的旧值和新值。</p><ul><li><code>REFERENCING OLD ROW AS</code>：用于 <code>DELETE</code> 和 <code>UPDATE</code> 操作，引用修改前的行。</li><li><code>REFERENCING NEW ROW AS</code>：用于 <code>INSERT</code> 和 <code>UPDATE</code> 操作，引用修改后的行。</li></ul><h4 id="3-2-2-应用示例"><a href="#3-2-2-应用示例" class="headerlink" title="3.2.2 应用示例"></a>3.2.2 应用示例</h4><ol><li><p><strong>数据清洗（<code>BEFORE</code> 触发器）</strong>：在插入或更新前修正数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> setnull_trigger BEFORE <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>)  <span class="comment">-- 当新成绩为空字符串时</span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">SET</span> nrow.grade <span class="operator">=</span> <span class="keyword">NULL</span>; <span class="comment">-- 将其设置为 NULL</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><em>说明：此触发器在 <code>takes</code> 表的 <code>grade</code> 列被更新前触发。如果新值是空字符串，则将其改为 <code>NULL</code>。<code>BEFORE</code> 触发器可以修改即将写入数据库的新值。</em></p></li><li><p><strong>维护参照完整性（复杂检查）</strong>：实现比外键约束更复杂的关联规则。</p><ul><li><strong>示例1：插入<code>section</code>时检查<code>time_slot_id</code>有效性</strong>。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check1 AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> section</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>; <span class="comment">-- 回滚整个插入事务</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>  <em>说明：当尝试插入一个<code>time_slot_id</code>不在<code>timeslot</code>表中的<code>section</code>记录时，事务被回滚。</em></li><li><strong>示例2：删除<code>timeslot</code>时防止孤立引用</strong>。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> timeslot_check2 AFTER <span class="keyword">DELETE</span> <span class="keyword">ON</span> timeslot</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (</span><br><span class="line">    <span class="comment">-- 被删除的time_slot_id是timeslot表中该ID的最后一条记录</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> timeslot)</span><br><span class="line">    <span class="keyword">AND</span></span><br><span class="line">    <span class="comment">-- 并且该ID仍在section表中被引用</span></span><br><span class="line">    orow.time_slot_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> time_slot_id <span class="keyword">FROM</span> section)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure>  <em>说明：防止删除一个正在被<code>section</code>表使用的<code>time_slot_id</code>，且确保它是该ID的最后一个实例。</em></li></ul></li><li><p><strong>维护派生数据（自动更新）</strong>：保持数据间的一致性。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> credits_earned AFTER <span class="keyword">UPDATE</span> <span class="keyword">OF</span> grade <span class="keyword">ON</span> takes</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">NEW</span> <span class="type">ROW</span> <span class="keyword">AS</span> nrow</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="type">ROW</span> <span class="keyword">AS</span> orow</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">WHEN</span> (nrow.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">AND</span> nrow.grade <span class="keyword">IS</span> <span class="keyword">NOT NULL</span></span><br><span class="line">      <span class="keyword">AND</span> (orow.grade <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span> <span class="keyword">OR</span> orow.grade <span class="keyword">IS</span> <span class="keyword">NULL</span>))</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">UPDATE</span> student</span><br><span class="line">    <span class="keyword">SET</span> tot_cred <span class="operator">=</span> tot_cred <span class="operator">+</span> (</span><br><span class="line">        <span class="keyword">SELECT</span> credits</span><br><span class="line">        <span class="keyword">FROM</span> course</span><br><span class="line">        <span class="keyword">WHERE</span> course.course_id <span class="operator">=</span> nrow.course_id</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> student.ID <span class="operator">=</span> nrow.ID;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p><em>说明：当学生某门课的成绩从不通过(<code>F</code>)或空变为通过（非<code>F</code>且非空）时，自动将该课程的学分累加到学生的总学分(<code>tot_cred</code>)中。</em></p></li></ol><h3 id="3-3-语句级触发器"><a href="#3-3-语句级触发器" class="headerlink" title="3.3 语句级触发器"></a>3.3 语句级触发器</h3><p>语句级触发器在每个触发事件（<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）上只执行一次，无论该语句影响了多少行。</p><ul><li><strong>语法</strong>：使用 <code>FOR EACH STATEMENT</code>（这是默认值）。</li><li><strong>引用过渡表</strong>：可以使用 <code>REFERENCING OLD TABLE AS</code> 或 <code>REFERENCING NEW TABLE AS</code> 来引用被该语句影响的所有行的旧值或新值的集合（过渡表）。</li><li><strong>适用场景</strong>：当触发动作不依赖于具体每一行的数据，或者需要对所有受影响的行进行批量操作时，语句级触发器比行级触发器更高效。  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> log_salary_change AFTER <span class="keyword">UPDATE</span> <span class="keyword">ON</span> instructor</span><br><span class="line"><span class="keyword">REFERENCING</span> <span class="keyword">OLD</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> old_table</span><br><span class="line">            <span class="keyword">NEW</span> <span class="keyword">TABLE</span> <span class="keyword">AS</span> new_table</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> STATEMENT</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">ATOMIC</span></span><br><span class="line">    <span class="keyword">INSERT INTO</span> salary_audit_log(change_time, old_avg, new_avg)</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">           <span class="built_in">AVG</span>(old_table.salary),</span><br><span class="line">           <span class="built_in">AVG</span>(new_table.salary)</span><br><span class="line">    <span class="keyword">FROM</span> old_table, new_table; <span class="comment">-- 注意：过渡表需在FROM子句中引用</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-触发器的适用与不适用场景"><a href="#3-4-触发器的适用与不适用场景" class="headerlink" title="3.4 触发器的适用与不适用场景"></a>3.4 触发器的适用与不适用场景</h3><h4 id="3-4-1-适用场景"><a href="#3-4-1-适用场景" class="headerlink" title="3.4.1 适用场景"></a>3.4.1 适用场景</h4><ul><li><strong>实现复杂的业务规则或完整性约束</strong>，这些约束无法通过标准的 <code>CHECK</code>、<code>UNIQUE</code>、<code>FOREIGN KEY</code> 约束来表达。</li><li><strong>审计与日志记录</strong>：自动记录数据变更（谁、何时、改了哪些数据）。</li><li><strong>维护衍生或汇总数据</strong>（尽管现在有更好的选择，见下文）。</li><li><strong>数据同步与复制</strong>（在早期技术中）。</li></ul><h4 id="3-4-2-不适用-慎用场景（现代最佳实践）"><a href="#3-4-2-不适用-慎用场景（现代最佳实践）" class="headerlink" title="3.4.2 不适用&#x2F;慎用场景（现代最佳实践）"></a>3.4.2 不适用&#x2F;慎用场景（现代最佳实践）</h4><ol><li><strong>维护汇总数据</strong>：<ul><li><strong>旧方式</strong>：用触发器在每次数据变更时更新汇总表（如部门总工资）。</li><li><strong>现代方式</strong>：使用 <strong>物化视图</strong>。数据库系统可以自动、高效地维护物化视图的更新，通常比手写触发器更可靠、性能更好。</li></ul></li><li><strong>数据库复制</strong>：<ul><li><strong>旧方式</strong>：用触发器将变更记录到“增量表”，再由其他进程应用。</li><li><strong>现代方式</strong>：使用数据库内置的<strong>复制功能</strong>（如日志传输、逻辑复制），这些功能更健壮、对性能影响更小。</li></ul></li><li><strong>简单的数据有效性检查</strong>：<ul><li><strong>首选</strong>：应尽量使用声明式的<strong>完整性约束</strong>（<code>NOT NULL</code>, <code>CHECK</code>, <code>FOREIGN KEY</code>）。约束更易于声明、理解和维护，且通常由 DBMS 更高效地执行。</li></ul></li><li><strong>过度复杂的业务逻辑</strong>：<ul><li><strong>问题</strong>：将大量复杂逻辑放入触发器可能导致“逻辑黑洞”，使得数据变更行为难以理解和调试，也增加了应用与数据库的耦合度。</li><li><strong>建议</strong>：考虑将核心业务逻辑放在应用层或中间件，数据库主要负责数据存储和基本完整性。</li></ul></li></ol><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h3><p>触发器是基于事件-条件-动作模型的强大工具，是实现复杂数据完整性规则和自动化业务逻辑的有效手段。然而，在现代数据库系统中，应优先考虑使用声明式约束和内置功能（如物化视图、复制）来满足需求。当必须使用触发器时，应谨慎设计，确保其逻辑清晰、高效，并做好充分文档记录，以避免维护的复杂性。</p><hr><h2 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h2><p>第五章“高级SQL”将SQL的能力从单纯的数据查询操作扩展到与应用程序的深度集成以及数据库内部的程序化逻辑。</p><ol><li><strong>SQL与编程语言集成</strong>：掌握了通过<strong>JDBC</strong> (Java)、<strong>ODBC</strong> (C&#x2F;C++) 和<strong>嵌入式SQL</strong>从应用程序中连接、查询和操作数据库的核心模式与技术细节。理解连接管理、事务控制、预编译语句和元数据访问是构建健壮数据库应用的基础。</li><li><strong>数据库端程序化逻辑</strong>：学会了在数据库服务器内部创建可重用的逻辑单元——<strong>函数</strong>（返回标量值）和<strong>存储过程</strong>（执行操作，可通过参数返回结果）。它们提高了代码复用性、减少了网络开销，并允许将业务逻辑封装在数据层。</li><li><strong>自动化响应机制</strong>：深入理解了<strong>触发器</strong>这一基于事件-条件-动作模型的强大工具。能够创建行级和语句级触发器，用于实现复杂的数据完整性约束、自动维护衍生数据、记录审计日志等。同时，也认识到应优先使用声明式约束和现代数据库内置功能，仅在必要时谨慎使用触发器。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Intro-to-SQL 简读</title>
      <link href="/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/22/DB_SQL%20%E8%AF%AD%E8%A8%80%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SQL概述（Overview-of-SQL）"><a href="#一、SQL概述（Overview-of-SQL）" class="headerlink" title="一、SQL概述（Overview of SQL）"></a>一、SQL概述（Overview of SQL）</h2><h3 id="1-1-SQL的基本概念"><a href="#1-1-SQL的基本概念" class="headerlink" title="1.1 SQL的基本概念"></a>1.1 SQL的基本概念</h3><p><strong>SQL (Structured Query Language)</strong> 是一种结构化查询语言，是使用最广泛的数据库查询语言。它已经扩展到其他领域，例如大数据（BigData）处理。</p><h3 id="1-2-SQL的组成部分"><a href="#1-2-SQL的组成部分" class="headerlink" title="1.2 SQL的组成部分"></a>1.2 SQL的组成部分</h3><p>SQL由以下几个主要部分组成：</p><p><strong>1. DML（数据操作语言 - Data Manipulation Language）</strong></p><ul><li>查询&#x2F;检索信息的能力</li><li>对元组进行选择、插入、删除、更新操作</li><li>主要命令：SELECT, INSERT, DELETE, UPDATE</li></ul><p><strong>2. DDL（数据定义语言 - Data Definition Language）</strong></p><ul><li>对模式、视图和索引进行定义、删除、修改</li><li>主要命令：CREATE, DROP, ALTER</li></ul><p><strong>3. 完整性约束（Integrity Constraints）</strong></p><ul><li>指定完整性约束的命令</li></ul><p><strong>4. 视图定义（View Definition）</strong></p><ul><li>定义视图的命令</li></ul><p><strong>5. 事务控制（Transaction Control）</strong></p><ul><li>指定事务开始和结束的命令</li><li>主要命令：BEGIN TRANSACTION, COMMIT, ROLLBACK</li></ul><p><strong>6. 嵌入式SQL和动态SQL</strong></p><ul><li>嵌入在编程语言中的SQL语句</li></ul><p><strong>7. 授权（Authorization）</strong></p><ul><li>主要命令：GRANT, REVOKE</li></ul><hr><h2 id="二、SQL数据定义（DDL）"><a href="#二、SQL数据定义（DDL）" class="headerlink" title="二、SQL数据定义（DDL）"></a>二、SQL数据定义（DDL）</h2><h3 id="2-1-DDL的功能"><a href="#2-1-DDL的功能" class="headerlink" title="2.1 DDL的功能"></a>2.1 DDL的功能</h3><p>DDL允许对关系进行以下规范：</p><ul><li>每个关系的模式（schema）</li><li>与每个属性关联的值类型</li><li>完整性约束（如 age&gt;0）</li><li>为每个关系维护的索引</li><li>每个关系的安全和授权信息</li><li>每个关系在磁盘上的物理存储结构</li></ul><h3 id="2-2-域类型（Domain-Types）"><a href="#2-2-域类型（Domain-Types）" class="headerlink" title="2.2 域类型（Domain Types）"></a>2.2 域类型（Domain Types）</h3><p><strong>基本数据类型：</strong></p><ol><li><p><strong>char(n)</strong> - 固定长度字符串，用户指定长度n</p></li><li><p><strong>varchar(n)</strong> - 可变长度字符串，用户指定最大长度n</p></li><li><p><strong>int</strong> - 整数（依赖于机器）</p></li><li><p><strong>smallint</strong> - 小整数（整数的机器依赖子集）</p></li><li><p>numeric(p,d)</p><p> - 定点数</p><ul><li>p：精度（总位数）</li><li>d：小数点右侧的位数</li><li>例如：numeric(3,1) 可以精确存储 44.5</li></ul></li></ol><p><strong>日期和时间类型：</strong></p><ol><li><strong>date</strong> - 日期，包含年（4位）、月、日<ul><li>例如：date ‘2001-07-27’</li></ul></li><li><strong>time</strong> - 时间，包含小时、分钟、秒<ul><li>例如：time ‘09:00:30’ 或 time ‘09:00:30.75’</li></ul></li><li><strong>timestamp</strong> - 日期加时间<ul><li>例如：timestamp ‘2001-7-27 09:00:30.75’</li></ul></li><li><strong>interval</strong> - 时间间隔<ul><li>两个日期&#x2F;时间&#x2F;时间戳相减得到间隔值</li><li>例如：interval ‘1’ day</li><li>间隔值可以加到日期&#x2F;时间&#x2F;时间戳值上</li></ul></li></ol><p><strong>空值处理：</strong></p><ul><li>所有域类型都允许空值（NULL）</li><li>声明属性为 NOT NULL 可以禁止该属性为空值</li></ul><p><strong>用户自定义类型：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> domain person<span class="operator">-</span>name <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">not null</span></span><br></pre></td></tr></table></figure><h3 id="2-3-创建表（Create-Table）"><a href="#2-3-创建表（Create-Table）" class="headerlink" title="2.3 创建表（Create Table）"></a>2.3 创建表（Create Table）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> r (</span><br><span class="line">    A1 D1,</span><br><span class="line">    A2 D2,</span><br><span class="line">    ...,</span><br><span class="line">    An Dn,</span><br><span class="line">    (integrity<span class="operator">-</span>constraint1),</span><br><span class="line">    ...,</span><br><span class="line">    (integrity<span class="operator">-</span>constraintk)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>r 是关系名称</li><li>Ai 是属性名</li><li>Di 是属性Ai的数据类型</li></ul><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor (</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="2-4-完整性约束（Integrity-Constraints）"><a href="#2-4-完整性约束（Integrity-Constraints）" class="headerlink" title="2.4 完整性约束（Integrity Constraints）"></a>2.4 完整性约束（Integrity Constraints）</h3><p><strong>主要约束类型：</strong></p><ol><li><strong>primary key (A1, …, An)</strong> - 主键约束</li><li><strong>foreign key (Am, …, An) references r</strong> - 外键约束</li><li><strong>not null</strong> - 非空约束</li></ol><p><strong>完整示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> instructor (</span><br><span class="line">    ID <span class="type">char</span>(<span class="number">5</span>),</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not null</span>,</span><br><span class="line">    dept_name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    salary <span class="type">numeric</span>(<span class="number">8</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">primary key</span> (ID),</span><br><span class="line">    <span class="keyword">foreign key</span> (dept_name) <span class="keyword">references</span> department</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>复合主键示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create table</span> takes (</span><br><span class="line">    ID <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">    course_id <span class="type">varchar</span>(<span class="number">8</span>),</span><br><span class="line">    <span class="keyword">year</span> <span class="type">numeric</span>(<span class="number">4</span>,<span class="number">0</span>),</span><br><span class="line">    grade <span class="type">varchar</span>(<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">primary key</span> (ID, course_id, <span class="keyword">year</span>),</span><br><span class="line">    <span class="keyword">foreign key</span> (ID) <span class="keyword">references</span> student,</span><br><span class="line">    <span class="keyword">foreign key</span> (course_id, <span class="keyword">year</span>) <span class="keyword">references</span> section</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="2-5-模式更新（Schema-Updates）"><a href="#2-5-模式更新（Schema-Updates）" class="headerlink" title="2.5 模式更新（Schema Updates）"></a>2.5 模式更新（Schema Updates）</h3><p><strong>删除表：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> r</span><br></pre></td></tr></table></figure><p><strong>添加属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> r <span class="keyword">add</span> A D</span><br></pre></td></tr></table></figure><ul><li>A 是要添加的属性名</li><li>D 是属性的域</li><li>所有现有元组的新属性值被赋为 NULL</li><li>例如：<code>alter table student add age integer</code></li></ul><p><strong>删除属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter table</span> r <span class="keyword">drop</span> A</span><br></pre></td></tr></table></figure><ul><li>A 是要删除的属性名</li><li>例如：<code>alter table student drop age</code></li><li>注意：许多数据库不支持删除属性</li></ul><p><strong>性能考虑：</strong></p><ul><li>表中的元组按行存储</li><li>添加属性或删除表会导致昂贵的记录修改和移动操作</li><li>NoSQL数据库和大数据系统采用列式存储以优化此类操作</li></ul><hr><h2 id="三、SQL查询基本结构"><a href="#三、SQL查询基本结构" class="headerlink" title="三、SQL查询基本结构"></a>三、SQL查询基本结构</h2><h3 id="3-1-基本查询形式"><a href="#3-1-基本查询形式" class="headerlink" title="3.1 基本查询形式"></a>3.1 基本查询形式</h3><p><strong>标准SQL查询结构：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> A1, A2, ..., An</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>Ai 表示属性</li><li>ri 表示关系</li><li>P 是谓词（条件）</li><li>查询结果是一个关系</li></ul><p><strong>等价的关系代数表达式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">πA1, A2, ..., An(σP(r1 × r2 × ... × rm))</span><br></pre></td></tr></table></figure><h3 id="3-2-SELECT子句详解"><a href="#3-2-SELECT子句详解" class="headerlink" title="3.2 SELECT子句详解"></a>3.2 SELECT子句详解</h3><p><strong>基本功能：</strong></p><ul><li>SELECT子句列出属性，对应关系代数的投影操作</li></ul><p><strong>示例1：查询所有教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>大小写不敏感：</strong></p><ul><li>Name ≡ NAME ≡ name</li></ul><p><strong>去除重复（DISTINCT）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>保留重复（ALL）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">all</span> dept_name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><ul><li>ALL是默认选项</li></ul><p><strong>使用星号（*）选择所有属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p>⚠️ <strong>实际应用中应避免使用*，可能导致索引失效</strong></p><p><strong>字面量（Literal）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 无FROM子句</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;437&#x27;</span>  <span class="comment">-- 结果：单列单行，值为437</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;437&#x27;</span> <span class="keyword">as</span> FOO  <span class="comment">-- 给列命名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有FROM子句</span></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;A&#x27;</span></span><br><span class="line"><span class="keyword">from</span> instructor  <span class="comment">-- 结果：N行（instructor表的行数），每行值为&#x27;A&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>算术表达式：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span></span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用AS重命名</span></span><br><span class="line"><span class="keyword">select</span> ID, name, salary<span class="operator">/</span><span class="number">12</span> <span class="keyword">as</span> monthly_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><h3 id="3-3-WHERE子句详解"><a href="#3-3-WHERE子句详解" class="headerlink" title="3.3 WHERE子句详解"></a>3.3 WHERE子句详解</h3><p><strong>基本功能：</strong></p><ul><li>WHERE子句指定结果必须满足的条件</li><li>对应关系代数的选择谓词</li></ul><p><strong>逻辑连接词：</strong></p><ul><li>AND（与）</li><li>OR（或）</li><li>NOT（非）</li></ul><p><strong>比较运算符：</strong></p><ul><li>&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;, &lt;&gt;（不等于）</li></ul><p><strong>示例1：单条件查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例2：复合条件查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span> <span class="keyword">and</span> salary <span class="operator">&gt;</span> <span class="number">70000</span></span><br></pre></td></tr></table></figure><p><strong>BETWEEN运算符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找工资在90000到100000之间的教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">between</span> <span class="number">90000</span> <span class="keyword">and</span> <span class="number">100000</span></span><br><span class="line"><span class="comment">-- 等价于：salary &gt;= 90000 and salary &lt;= 100000</span></span><br></pre></td></tr></table></figure><p><strong>元组比较运算符：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> (instructor.ID, dept_name) <span class="operator">=</span> (teaches.ID, <span class="string">&#x27;Biology&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-4-FROM子句详解"><a href="#3-4-FROM子句详解" class="headerlink" title="3.4 FROM子句详解"></a>3.4 FROM子句详解</h3><p><strong>基本功能：</strong></p><ul><li>FROM子句列出关系</li><li>对应关系代数的笛卡尔积操作</li></ul><p><strong>笛卡尔积：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br></pre></td></tr></table></figure><ul><li>生成每个instructor-teaches配对</li><li>包含两个关系的所有属性</li><li>对于共同属性（如ID），在结果表中使用关系名重命名（instructor.ID）</li></ul><p>⚠️ <strong>重要注意事项：</strong> 当FROM子句包含多个关系时：</p><ul><li><strong>必须在WHERE子句中加入连接条件</strong></li><li>防止产生代价高昂的多表笛卡尔积操作</li><li>频繁执行的SQL查询，FROM子句的表个数不要过多（<strong>不超过4个表</strong>）</li><li>如需查询涉及≥4张表，考虑将这些表的数据进行合并</li></ul><p><strong>连接查询示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找所有教过课的教师姓名和课程ID</span></span><br><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加部门筛选</span></span><br><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">    <span class="keyword">and</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-5-自然连接（Natural-Join）"><a href="#3-5-自然连接（Natural-Join）" class="headerlink" title="3.5 自然连接（Natural Join）"></a>3.5 自然连接（Natural Join）</h3><p><strong>语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">natural</span> <span class="keyword">join</span> teaches</span><br><span class="line"><span class="keyword">where</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>对比传统连接：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name, course_id</span><br><span class="line"><span class="keyword">from</span> instructor, teaches</span><br><span class="line"><span class="keyword">where</span> instructor.ID <span class="operator">=</span> teaches.ID</span><br><span class="line">    <span class="keyword">and</span> instructor.dept_name <span class="operator">=</span> <span class="string">&#x27;Art&#x27;</span></span><br></pre></td></tr></table></figure><p>自然连接自动匹配两个关系中所有同名属性。</p><hr><h2 id="四、SQL查询的计算过程"><a href="#四、SQL查询的计算过程" class="headerlink" title="四、SQL查询的计算过程"></a>四、SQL查询的计算过程</h2><h3 id="4-1-完整的SELECT语法"><a href="#4-1-完整的SELECT语法" class="headerlink" title="4.1 完整的SELECT语法"></a>4.1 完整的SELECT语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;<span class="keyword">ALL</span> <span class="operator">|</span> <span class="keyword">DISTINCT</span>&#125; &#123;<span class="operator">&lt;</span><span class="keyword">column</span> expression<span class="operator">&gt;</span>&#125;</span><br><span class="line"><span class="keyword">from</span> &#123;<span class="operator">&lt;</span>table_name <span class="keyword">or</span> view_name<span class="operator">&gt;</span>&#125;</span><br><span class="line">[<span class="keyword">where</span> <span class="operator">&lt;</span>conditional expression <span class="number">1</span><span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>column_name <span class="number">1</span><span class="operator">&gt;</span></span><br><span class="line">    [<span class="keyword">having</span> <span class="operator">&lt;</span>conditional expression <span class="number">2</span><span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>column_name <span class="number">2</span><span class="operator">&gt;</span> &#123;<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="4-2-查询执行顺序"><a href="#4-2-查询执行顺序" class="headerlink" title="4.2 查询执行顺序"></a>4.2 查询执行顺序</h3><p><strong>1. FROM和WHERE阶段：</strong></p><ul><li>从FROM子句列出的基表或视图中选择满足WHERE条件的元组</li><li>从这些元组中选择属性，形成结果表</li></ul><p><strong>2. GROUP BY和聚合函数阶段：</strong></p><ul><li>根据条件表达式对结果表进行分组</li><li>对每个组执行组&#x2F;聚合函数</li><li>输出每个组作为结果</li></ul><p><strong>3. HAVING阶段：</strong></p><ul><li>对分组结果进行筛选</li><li>输出满足条件的组</li></ul><p><strong>4. ORDER BY阶段：</strong></p><ul><li>对结果表或组按降序或升序排序</li></ul><hr><h2 id="五、其他基本操作"><a href="#五、其他基本操作" class="headerlink" title="五、其他基本操作"></a>五、其他基本操作</h2><h3 id="5-1-重命名操作（RENAME）"><a href="#5-1-重命名操作（RENAME）" class="headerlink" title="5.1 重命名操作（RENAME）"></a>5.1 重命名操作（RENAME）</h3><p><strong>使用AS子句重命名关系和属性：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">old</span><span class="operator">-</span>name <span class="keyword">as</span> <span class="keyword">new</span><span class="operator">-</span>name</span><br></pre></td></tr></table></figure><p><strong>示例：找出所有工资高于计算机科学系教师的教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name <span class="keyword">as</span> TeacherName</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary </span><br><span class="line">    <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>使用元组变量（tuple variable）T和S区分同一关系的不同实例</li><li>AS关键字是可选的：<code>instructor as T ≡ instructor T</code></li></ul><p><strong>为什么需要元组变量？</strong></p><ul><li>涉及对instructor关系中salary属性的不同值的比较</li><li>利用T和S区分不同的instructor实例</li><li>实现了对同一属性的不同值的比较</li></ul><h3 id="5-2-字符串操作"><a href="#5-2-字符串操作" class="headerlink" title="5.2 字符串操作"></a>5.2 字符串操作</h3><p><strong>模式匹配运算符LIKE：</strong></p><p><strong>特殊字符：</strong></p><ol><li><strong>百分号（%）</strong> - 匹配任意子串</li><li><strong>下划线（_）</strong> - 匹配任意单个字符</li></ol><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找姓名中包含&quot;dar&quot;的所有教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%dar%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 匹配字符串&quot;100%&quot;</span></span><br><span class="line"><span class="keyword">like</span> <span class="string">&#x27;100\%&#x27;</span> <span class="keyword">escape</span> <span class="string">&#x27;\&#x27;</span></span><br><span class="line"><span class="comment">-- 使用反斜杠作为转义字符</span></span><br></pre></td></tr></table></figure><p><strong>模式示例：</strong></p><ul><li><code>&#39;Intro%&#39;</code> - 匹配以”Intro”开头的任意字符串</li><li><code>&#39;%Comp%&#39;</code> - 匹配包含”Comp”作为子串的任意字符串</li><li><code>&#39;___&#39;</code> - 匹配恰好三个字符的字符串</li><li><code>&#39;___%&#39;</code> - 匹配至少三个字符的字符串</li></ul><p><strong>注意：模式是大小写敏感的</strong></p><p><strong>其他字符串操作：</strong></p><ul><li>连接（使用”||”）</li><li>大小写转换</li><li>查找字符串长度</li><li>提取子串等</li></ul><h3 id="5-3-结果排序（ORDER-BY）"><a href="#5-3-结果排序（ORDER-BY）" class="headerlink" title="5.3 结果排序（ORDER BY）"></a>5.3 结果排序（ORDER BY）</h3><p><strong>基本排序：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 按字母顺序列出所有教师姓名</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><p><strong>指定排序方向：</strong></p><ul><li><strong>DESC</strong> - 降序</li><li><strong>ASC</strong> - 升序（默认）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p><strong>多属性排序：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_name, name</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 不同属性不同排序方向</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> dept_name <span class="keyword">asc</span>, name <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>性能警告：</strong> 避免使用数据库的ORDER BY操作对大数据文件进行排序，这可能导致严重的性能问题。</p><hr><h2 id="六、集合操作（Set-Operations）"><a href="#六、集合操作（Set-Operations）" class="headerlink" title="六、集合操作（Set Operations）"></a>六、集合操作（Set Operations）</h2><h3 id="6-1-基本集合操作"><a href="#6-1-基本集合操作" class="headerlink" title="6.1 基本集合操作"></a>6.1 基本集合操作</h3><p>SQL支持三种集合操作：</p><ul><li><strong>UNION</strong> - 并集（∪）</li><li><strong>INTERSECT</strong> - 交集（∩）</li><li><strong>EXCEPT</strong> - 差集（−）</li></ul><p><strong>特点：</strong></p><ul><li>自动消除重复</li><li>要保留重复，使用：UNION ALL, INTERSECT ALL, EXCEPT ALL</li></ul><h3 id="6-2-UNION（并集）"><a href="#6-2-UNION（并集）" class="headerlink" title="6.2 UNION（并集）"></a>6.2 UNION（并集）</h3><p><strong>示例：查找2017年秋季或2018年春季开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><h3 id="6-3-INTERSECT（交集）"><a href="#6-3-INTERSECT（交集）" class="headerlink" title="6.3 INTERSECT（交集）"></a>6.3 INTERSECT（交集）</h3><p><strong>示例：查找既在2017年秋季又在2018年春季开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">intersect</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><h3 id="6-4-EXCEPT（差集）"><a href="#6-4-EXCEPT（差集）" class="headerlink" title="6.4 EXCEPT（差集）"></a>6.4 EXCEPT（差集）</h3><p><strong>示例：查找2017年秋季开设但2018年春季没有开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span>)</span><br><span class="line"><span class="keyword">except</span></span><br><span class="line">(<span class="keyword">select</span> course_id </span><br><span class="line"> <span class="keyword">from</span> section </span><br><span class="line"> <span class="keyword">where</span> sem <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="七、空值处理（NULL-Values）"><a href="#七、空值处理（NULL-Values）" class="headerlink" title="七、空值处理（NULL Values）"></a>七、空值处理（NULL Values）</h2><h3 id="7-1-NULL的含义"><a href="#7-1-NULL的含义" class="headerlink" title="7.1 NULL的含义"></a>7.1 NULL的含义</h3><p>NULL表示：</p><ul><li>未知值（unknown value）</li><li>值不存在（value does not exist）</li></ul><h3 id="7-2-算术运算与NULL"><a href="#7-2-算术运算与NULL" class="headerlink" title="7.2 算术运算与NULL"></a>7.2 算术运算与NULL</h3><p>任何涉及NULL的算术表达式结果都是NULL</p><ul><li>例如：5 + null &#x3D; null</li></ul><h3 id="7-3-检查NULL值"><a href="#7-3-检查NULL值" class="headerlink" title="7.3 检查NULL值"></a>7.3 检查NULL值</h3><p>使用 <strong>IS NULL</strong> 谓词：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找工资为NULL的所有教师</span></span><br><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure><h3 id="7-4-比较运算与NULL"><a href="#7-4-比较运算与NULL" class="headerlink" title="7.4 比较运算与NULL"></a>7.4 比较运算与NULL</h3><p>SQL将涉及NULL的任何比较结果视为<strong>未知（unknown）</strong></p><ul><li>5 &lt; null → unknown</li><li>null &lt;&gt; null → unknown</li><li>null &#x3D; null → unknown</li></ul><h3 id="7-5-布尔运算与UNKNOWN"><a href="#7-5-布尔运算与UNKNOWN" class="headerlink" title="7.5 布尔运算与UNKNOWN"></a>7.5 布尔运算与UNKNOWN</h3><p><strong>AND运算：</strong></p><ul><li>true AND unknown &#x3D; unknown</li><li>false AND unknown &#x3D; false</li><li>unknown AND unknown &#x3D; unknown</li></ul><p><strong>OR运算：</strong></p><ul><li>unknown OR true &#x3D; true</li><li>unknown OR false &#x3D; unknown</li><li>unknown OR unknown &#x3D; unknown</li></ul><p><strong>WHERE子句处理：</strong></p><ul><li>如果WHERE子句的谓词求值为unknown，则视为false</li></ul><p>⚠️ <strong>实际应用建议：</strong> 避免引入属性NULL值，防止索引失效；使用默认值（default value）替代。</p><hr><h2 id="八、聚合函数（Aggregate-Functions）"><a href="#八、聚合函数（Aggregate-Functions）" class="headerlink" title="八、聚合函数（Aggregate Functions）"></a>八、聚合函数（Aggregate Functions）</h2><h3 id="8-1-基本聚合函数"><a href="#8-1-基本聚合函数" class="headerlink" title="8.1 基本聚合函数"></a>8.1 基本聚合函数</h3><p>聚合函数对列的值进行操作，但返回单个值：</p><ol><li><strong>avg</strong> - 平均值</li><li><strong>min</strong> - 最小值</li><li><strong>max</strong> - 最大值</li><li><strong>sum</strong> - 求和</li><li><strong>count</strong> - 计数</li></ol><h3 id="8-2-聚合函数语法"><a href="#8-2-聚合函数语法" class="headerlink" title="8.2 聚合函数语法"></a>8.2 聚合函数语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;A1, A2, ..., Ai&#125;, ag_fun(Ai<span class="operator">+</span><span class="number">1</span>), ..., ag_fun(Ai<span class="operator">+</span>k)</span><br><span class="line"><span class="keyword">from</span> r1, r2, ..., rm</span><br><span class="line"><span class="keyword">where</span> P1</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> A1, A2, ..., Ai</span><br><span class="line">    [<span class="keyword">having</span> P2]]</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>P1 定义在 r1, r2, …, rm 的所有属性上</li><li>P2 定义在 A1, A2, …, Ai 上，作为GROUP BY的约束</li></ul><h3 id="8-3-基本聚合示例"><a href="#8-3-基本聚合示例" class="headerlink" title="8.3 基本聚合示例"></a>8.3 基本聚合示例</h3><p><strong>示例1：计算平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Comp. Sci.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例2：计算教师数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> teaches</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span></span><br></pre></td></tr></table></figure><p><strong>示例3：计算元组数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> course</span><br></pre></td></tr></table></figure><h3 id="8-4-GROUP-BY子句"><a href="#8-4-GROUP-BY子句" class="headerlink" title="8.4 GROUP BY子句"></a>8.4 GROUP BY子句</h3><p><strong>功能：</strong> 将结果按指定属性分组</p><p><strong>示例：查找每个系的平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure><p><strong>重要规则：</strong> SELECT子句中在聚合函数外的属性必须出现在GROUP BY列表中</p><p><strong>错误示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 错误！ID不在GROUP BY中</span></span><br><span class="line"><span class="keyword">select</span> dept_name, ID, <span class="built_in">avg</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br></pre></td></tr></table></figure><p><strong>NULL值处理：</strong> 除了count(*)外，所有聚合操作都忽略聚合属性上的NULL值元组</p><h3 id="8-5-HAVING子句"><a href="#8-5-HAVING子句" class="headerlink" title="8.5 HAVING子句"></a>8.5 HAVING子句</h3><p><strong>功能：</strong> 对分组形成后的结果应用条件</p><p><strong>示例：查找平均工资超过42000的所有系的名称和平均工资</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line"><span class="keyword">having</span> <span class="built_in">avg</span>(salary) <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><p><strong>WHERE vs HAVING：</strong></p><ul><li><strong>WHERE</strong> - 在形成分组<strong>之前</strong>应用谓词</li><li><strong>HAVING</strong> - 在形成分组<strong>之后</strong>应用谓词</li></ul><hr><h2 id="九、嵌套子查询（Nested-Subqueries）"><a href="#九、嵌套子查询（Nested-Subqueries）" class="headerlink" title="九、嵌套子查询（Nested Subqueries）"></a>九、嵌套子查询（Nested Subqueries）</h2><h3 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a>9.1 基本概念</h3><p>子查询是嵌套在另一个查询中的SELECT-FROM-WHERE表达式。</p><p><strong>可以出现的位置：</strong></p><ol><li><strong>FROM子句：</strong> ri可以被任何有效的子查询替换</li><li><strong>WHERE子句：</strong> P可以被表达式替换：<code>B &lt;operation&gt; (subquery)</code></li><li><strong>SELECT子句：</strong> Ai可以被生成单个值的子查询替换</li></ol><p>⚠️ <strong>优化建议：</strong> 从SQL优化角度，避免使用低效的嵌套查询，改为FROM子句中的多表连接，便于DBMS查询优化。</p><h3 id="9-2-集合成员资格（Set-Membership）"><a href="#9-2-集合成员资格（Set-Membership）" class="headerlink" title="9.2 集合成员资格（Set Membership）"></a>9.2 集合成员资格（Set Membership）</h3><p><strong>IN运算符：</strong></p><p><strong>示例1：查找2009年秋季和2010年春季都开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">    <span class="keyword">and</span> course_id <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>NOT IN运算符：</strong></p><p><strong>示例2：查找2009年秋季开设但2010年春季未开设的课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> course_id</span><br><span class="line"><span class="keyword">from</span> section</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2009</span></span><br><span class="line">    <span class="keyword">and</span> course_id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> course_id</span><br><span class="line">        <span class="keyword">from</span> section</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2010</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p><strong>执行过程：</strong></p><ol><li>从头至尾依次扫描section中每一行</li><li>对每一行：<ul><li>判断其semester、year是否满足查询条件</li><li>执行嵌入在WHERE子句中的SELECT查询</li><li>判断本行的course_id是否在结果集合中</li></ul></li></ol><p>⚠️ <strong>性能问题：</strong></p><ul><li>嵌入式查询可能执行效率较低</li><li>被嵌入的SELECT子句可能多次重复执行</li><li>实际应用中应尽量避免membership等嵌入式查询</li></ul><p><strong>改进方案（多表连接）：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 低效的嵌套查询</span></span><br><span class="line"><span class="keyword">select</span> SECTOR_ID, PHYCELLID</span><br><span class="line"><span class="keyword">from</span> tbPCIAssignment</span><br><span class="line"><span class="keyword">where</span> EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span> <span class="keyword">and</span> ASSIGN_ID<span class="operator">=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">and</span> SECTOR_ID <span class="keyword">in</span> (</span><br><span class="line">        <span class="keyword">select</span> N_SECTOR_ID</span><br><span class="line">        <span class="keyword">from</span> tbAdjCell</span><br><span class="line">        <span class="keyword">where</span> S_SECTOR_ID<span class="operator">=</span><span class="string">&#x27;58617-1&#x27;</span> <span class="keyword">and</span> N_EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 高效的多表连接</span></span><br><span class="line"><span class="keyword">select</span> A.SECTOR_ID, A.PHYCELLID</span><br><span class="line"><span class="keyword">from</span> tbPCIAssignment <span class="keyword">as</span> A, tbAdjCell <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">where</span> A.EARFCN<span class="operator">=</span><span class="string">&#x27;38400&#x27;</span> </span><br><span class="line">    <span class="keyword">and</span> A.ASSIGN_ID<span class="operator">=</span><span class="number">0</span></span><br><span class="line">    <span class="keyword">and</span> A.SECTOR_ID<span class="operator">=</span>B.N_SECTOR_ID</span><br><span class="line">    <span class="keyword">and</span> B.S_SECTOR_ID<span class="operator">=</span><span class="string">&#x27;58617-1&#x27;</span></span><br></pre></td></tr></table></figure><p>根据课件中的SQL Server执行计划，性能比为 <strong>77:23</strong>（嵌套查询更慢）</p><p><strong>其他IN用法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 名字不是&quot;Mozart&quot;也不是&quot;Einstein&quot;的教师</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;Mozart&#x27;</span>, <span class="string">&#x27;Einstein&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 元组IN</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> ID)</span><br><span class="line"><span class="keyword">from</span> takes</span><br><span class="line"><span class="keyword">where</span> (course_id, semester, <span class="keyword">year</span>) <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> course_id, semester, <span class="keyword">year</span></span><br><span class="line">    <span class="keyword">from</span> teaches</span><br><span class="line">    <span class="keyword">where</span> teaches.ID <span class="operator">=</span> <span class="number">10101</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-3-集合比较-SOME子句"><a href="#9-3-集合比较-SOME子句" class="headerlink" title="9.3 集合比较 - SOME子句"></a>9.3 集合比较 - SOME子句</h3><p><strong>示例：查找工资高于生物系至少一名教师的教师姓名</strong></p><p><strong>方法1：使用元组变量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> T.name</span><br><span class="line"><span class="keyword">from</span> instructor <span class="keyword">as</span> T, instructor <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> T.salary <span class="operator">&gt;</span> S.salary </span><br><span class="line">    <span class="keyword">and</span> S.dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>方法2：使用SOME</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">some</span> (</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>SOME的定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &lt;comp&gt; some r ⟺ ∃t ∈ r such that (F &lt;comp&gt; t)</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;comp&gt;</code> 可以是：&lt;, &lt;&#x3D;, &gt;, &gt;&#x3D;, &#x3D;, &lt;&gt;</p><p><strong>示例：</strong></p><ul><li><code>(5 &lt; some {0, 5, 6})</code> &#x3D; true（因为5 &lt; 6）</li><li><code>(5 &lt; some {0, 5})</code> &#x3D; false</li><li><code>(5 = some {0, 5})</code> &#x3D; true（因为5 &#x3D; 5）</li><li><code>(5 ≠ some {0, 5})</code> &#x3D; true（因为5 ≠ 0）</li></ul><p><strong>重要等价关系：</strong></p><ul><li><code>(= some)</code> ≡ <code>in</code></li><li>但是 <code>(&lt;&gt; some)</code> ≠ <code>not in</code></li></ul><h3 id="9-4-集合比较-ALL子句"><a href="#9-4-集合比较-ALL子句" class="headerlink" title="9.4 集合比较 - ALL子句"></a>9.4 集合比较 - ALL子句</h3><p><strong>示例：查找工资高于生物系所有教师的教师姓名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span> (</span><br><span class="line">    <span class="keyword">select</span> salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>ALL的定义：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F &lt;comp&gt; all r ⟺ ∀t ∈ r (F &lt;comp&gt; t)</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><ul><li><code>(5 &lt; all {0, 5, 6})</code> &#x3D; false（因为5不小于5）</li><li><code>(5 &lt; all {6, 10, 4})</code> &#x3D; false（因为5不小于4）</li><li><code>(5 = all {4, 5})</code> &#x3D; false</li><li><code>(5 ≠ all {4, 6})</code> &#x3D; true（5不等于4且5不等于6）</li></ul><p><strong>重要等价关系：</strong></p><ul><li><code>(&lt;&gt; all)</code> ≡ <code>not in</code></li><li>但是 <code>(= all)</code> ≠ <code>in</code></li></ul><h3 id="9-5-测试空关系-EXISTS"><a href="#9-5-测试空关系-EXISTS" class="headerlink" title="9.5 测试空关系 - EXISTS"></a>9.5 测试空关系 - EXISTS</h3><p><strong>EXISTS构造：</strong> 如果参数子查询非空，则返回true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exists r ⟺ r ≠ ∅</span><br><span class="line">not exists r ⟺ r = ∅</span><br></pre></td></tr></table></figure><p><strong>集合包含：</strong></p><ul><li>X − Y &#x3D; ∅ ⟺ X ⊆ Y</li><li>X ⊆ Y ⟺ (X − Y) &#x3D; ∅ ⟺ not exists (X except Y)</li></ul><p><strong>示例1：查找2017年秋季和2018年春季都开设的所有课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> course_id</span><br><span class="line"><span class="keyword">from</span> section <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Fall&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">    <span class="keyword">and</span> <span class="keyword">exists</span> (</span><br><span class="line">        <span class="keyword">select</span> <span class="operator">*</span></span><br><span class="line">        <span class="keyword">from</span> section <span class="keyword">as</span> T</span><br><span class="line">        <span class="keyword">where</span> semester <span class="operator">=</span> <span class="string">&#x27;Spring&#x27;</span> <span class="keyword">and</span> <span class="keyword">year</span> <span class="operator">=</span> <span class="number">2018</span></span><br><span class="line">            <span class="keyword">and</span> S.course_id <span class="operator">=</span> T.course_id</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><ul><li><strong>相关名（Correlation name）</strong> - 外部查询中的变量S</li><li><strong>相关子查询（Correlated subquery）</strong> - 内部查询</li></ul><h3 id="9-6-NOT-EXISTS的使用"><a href="#9-6-NOT-EXISTS的使用" class="headerlink" title="9.6 NOT EXISTS的使用"></a>9.6 NOT EXISTS的使用</h3><p><strong>示例：查找选修了生物系开设的所有课程的学生</strong></p><p><strong>思路：</strong></p><ul><li>X &#x3D; 生物系开设的所有课程</li><li>Y &#x3D; 某个特定学生选修的所有课程</li><li>判断Y是否包含X（即 X ⊆ Y）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> S.ID, S.name</span><br><span class="line"><span class="keyword">from</span> student <span class="keyword">as</span> S</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    (<span class="keyword">select</span> course_id</span><br><span class="line">     <span class="keyword">from</span> course</span><br><span class="line">     <span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Biology&#x27;</span>)</span><br><span class="line">    <span class="keyword">except</span></span><br><span class="line">    (<span class="keyword">select</span> T.course_id</span><br><span class="line">     <span class="keyword">from</span> takes <span class="keyword">as</span> T</span><br><span class="line">     <span class="keyword">where</span> S.ID <span class="operator">=</span> T.ID)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-7-测试重复元组-UNIQUE"><a href="#9-7-测试重复元组-UNIQUE" class="headerlink" title="9.7 测试重复元组 - UNIQUE"></a>9.7 测试重复元组 - UNIQUE</h3><p><strong>UNIQUE测试：</strong> 检查子查询结果中是否有重复元组</p><p><strong>示例：查找2017年最多开设一次的所有课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> T.course_id</span><br><span class="line"><span class="keyword">from</span> course <span class="keyword">as</span> T</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">unique</span> (</span><br><span class="line">    <span class="keyword">select</span> R.course_id</span><br><span class="line">    <span class="keyword">from</span> section <span class="keyword">as</span> R</span><br><span class="line">    <span class="keyword">where</span> T.course_id <span class="operator">=</span> R.course_id</span><br><span class="line">        <span class="keyword">and</span> R.year <span class="operator">=</span> <span class="number">2017</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="9-8-FROM子句中的子查询"><a href="#9-8-FROM子句中的子查询" class="headerlink" title="9.8 FROM子句中的子查询"></a>9.8 FROM子句中的子查询</h3><p><strong>示例：查找平均工资超过42000美元的系的平均教师工资</strong></p><p><strong>方法1：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, avg_salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">)</span><br><span class="line"><span class="keyword">where</span> avg_salary <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><p><strong>方法2：给派生关系命名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name, avg_salary</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name, <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">) <span class="keyword">as</span> dept_avg(dept_name, avg_salary)</span><br><span class="line"><span class="keyword">where</span> avg_salary <span class="operator">&gt;</span> <span class="number">42000</span></span><br></pre></td></tr></table></figure><h3 id="9-9-WITH子句（推荐使用）"><a href="#9-9-WITH子句（推荐使用）" class="headerlink" title="9.9 WITH子句（推荐使用）"></a>9.9 WITH子句（推荐使用）</h3><p><strong>功能：</strong> WITH子句提供了一种定义临时关系的方法，该关系仅在包含WITH子句的查询中可用。</p><p><strong>优点：</strong> 将复杂查询分解为若干步，每个视图定义一个中间计算结果，逻辑清晰。</p><p><strong>示例1：查找所有预算最高的系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> max_budget(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">max</span>(budget)</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> department.name</span><br><span class="line"><span class="keyword">from</span> department, max_budget</span><br><span class="line"><span class="keyword">where</span> department.budget <span class="operator">=</span> max_budget.value</span><br></pre></td></tr></table></figure><p><strong>示例2：查找总工资大于所有系平均总工资的系</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> dept_total(dept_name, <span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> dept_name, <span class="built_in">sum</span>(salary)</span><br><span class="line"><span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> dept_name</span><br><span class="line">),</span><br><span class="line">dept_total_avg(<span class="keyword">value</span>) <span class="keyword">as</span> (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(<span class="keyword">value</span>)</span><br><span class="line"><span class="keyword">from</span> dept_total</span><br><span class="line">)</span><br><span class="line"><span class="keyword">select</span> dept_name</span><br><span class="line"><span class="keyword">from</span> dept_total, dept_total_avg</span><br><span class="line"><span class="keyword">where</span> dept_total.value <span class="operator">&gt;</span> dept_total_avg.value</span><br></pre></td></tr></table></figure><h3 id="9-10-标量子查询（Scalar-Subquery）"><a href="#9-10-标量子查询（Scalar-Subquery）" class="headerlink" title="9.10 标量子查询（Scalar Subquery）"></a>9.10 标量子查询（Scalar Subquery）</h3><p><strong>定义：</strong> 标量子查询是期望返回单个值的子查询</p><p><strong>示例：列出所有系及其教师数量</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> dept_name,</span><br><span class="line">    (<span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line">     <span class="keyword">from</span> instructor</span><br><span class="line">     <span class="keyword">where</span> department.dept_name <span class="operator">=</span> instructor.dept_name)</span><br><span class="line">    <span class="keyword">as</span> num_instructors</span><br><span class="line"><span class="keyword">from</span> department</span><br></pre></td></tr></table></figure><hr><h2 id="十、数据库修改（Database-Modification）"><a href="#十、数据库修改（Database-Modification）" class="headerlink" title="十、数据库修改（Database Modification）"></a>十、数据库修改（Database Modification）</h2><h3 id="10-1-删除操作（DELETE）"><a href="#10-1-删除操作（DELETE）" class="headerlink" title="10.1 删除操作（DELETE）"></a>10.1 删除操作（DELETE）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r</span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p><strong>示例1：删除所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br></pre></td></tr></table></figure><p><strong>示例2：删除财务系的所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Finance&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>示例3：删除Watson楼中系的所有教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span> dept_name</span><br><span class="line">    <span class="keyword">from</span> department</span><br><span class="line">    <span class="keyword">where</span> building <span class="operator">=</span> <span class="string">&#x27;Watson&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例4：删除工资低于平均工资的教师</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> instructor</span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>执行顺序问题：</strong></p><ul><li>删除元组时，平均工资会改变</li><li>解决方案：<ol><li>首先计算avg(salary)并找到所有要删除的元组</li><li>然后删除所有找到的元组（不重新计算平均值或重新测试元组）</li></ol></li></ul><h3 id="10-2-插入操作（INSERT）"><a href="#10-2-插入操作（INSERT）" class="headerlink" title="10.2 插入操作（INSERT）"></a>10.2 插入操作（INSERT）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> r</span><br><span class="line"><span class="keyword">values</span> (v1, v2, ..., vn)</span><br></pre></td></tr></table></figure><p><strong>示例1：添加新课程</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> course</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;CS-437&#x27;</span>, <span class="string">&#x27;Database Systems&#x27;</span>, <span class="string">&#x27;Comp. Sci.&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 等价写法</span></span><br><span class="line"><span class="keyword">insert into</span> course (course_id, title, dept_name, credits)</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;CS-437&#x27;</span>, <span class="string">&#x27;Database Systems&#x27;</span>, <span class="string">&#x27;Comp. Sci.&#x27;</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong>示例2：插入NULL值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student</span><br><span class="line"><span class="keyword">values</span> (<span class="string">&#x27;3003&#x27;</span>, <span class="string">&#x27;Green&#x27;</span>, <span class="string">&#x27;Finance&#x27;</span>, <span class="keyword">null</span>)</span><br></pre></td></tr></table></figure><p><strong>示例3：从查询结果插入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将音乐系中获得超过144学分的每个学生</span></span><br><span class="line"><span class="comment">-- 聘为音乐系教师，工资为18000美元</span></span><br><span class="line"><span class="keyword">insert into</span> instructor</span><br><span class="line"><span class="keyword">select</span> ID, name, dept_name, <span class="number">18000</span></span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> dept_name <span class="operator">=</span> <span class="string">&#x27;Music&#x27;</span> <span class="keyword">and</span> total_cred <span class="operator">&gt;</span> <span class="number">144</span></span><br></pre></td></tr></table></figure><p><strong>重要特性：</strong> SELECT-FROM-WHERE语句在将其结果插入关系之前完全求值。否则像下面的查询会导致问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> table1 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table1</span><br></pre></td></tr></table></figure><h3 id="10-3-更新操作（UPDATE）"><a href="#10-3-更新操作（UPDATE）" class="headerlink" title="10.3 更新操作（UPDATE）"></a>10.3 更新操作（UPDATE）</h3><p><strong>基本语法：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> r</span><br><span class="line"><span class="keyword">set</span> A <span class="operator">=</span> <span class="keyword">value</span></span><br><span class="line"><span class="keyword">where</span> P</span><br></pre></td></tr></table></figure><p><strong>示例1：给所有教师加薪5%</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br></pre></td></tr></table></figure><p><strong>示例2：条件更新</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给工资低于70000的教师加薪5%</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> <span class="number">70000</span></span><br></pre></td></tr></table></figure><p><strong>示例3：使用子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给工资低于平均工资的教师加薪5%</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">avg</span>(salary)</span><br><span class="line">    <span class="keyword">from</span> instructor</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>示例4：多条件更新的顺序问题</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 工资超过100000的教师加薪3%，其他加薪5%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方案1：两个UPDATE语句（顺序很重要！）</span></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line"><span class="keyword">where</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span>;</span><br><span class="line"><span class="comment">-- 如果顺序相反，初始工资为99999的教师会被加薪两次</span></span><br></pre></td></tr></table></figure><h3 id="10-4-条件更新-CASE语句"><a href="#10-4-条件更新-CASE语句" class="headerlink" title="10.4 条件更新 - CASE语句"></a>10.4 条件更新 - CASE语句</h3><p><strong>更好的解决方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> instructor</span><br><span class="line"><span class="keyword">set</span> salary <span class="operator">=</span> <span class="keyword">case</span></span><br><span class="line">    <span class="keyword">when</span> salary <span class="operator">&lt;=</span> <span class="number">100000</span> <span class="keyword">then</span> salary <span class="operator">*</span> <span class="number">1.05</span></span><br><span class="line">    <span class="keyword">else</span> salary <span class="operator">*</span> <span class="number">1.03</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="10-5-使用标量子查询更新"><a href="#10-5-使用标量子查询更新" class="headerlink" title="10.5 使用标量子查询更新"></a>10.5 使用标量子查询更新</h3><p><strong>示例：重新计算并更新所有学生的tot_creds值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line"><span class="keyword">set</span> tot_cred <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">    <span class="keyword">from</span> takes, course</span><br><span class="line">    <span class="keyword">where</span> takes.course_id <span class="operator">=</span> course.course_id</span><br><span class="line">        <span class="keyword">and</span> S.ID <span class="operator">=</span> takes.ID</span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>问题：</strong> 对于没有选修任何课程的学生，tot_creds会被设置为NULL</p><p><strong>改进方案：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> student S</span><br><span class="line"><span class="keyword">set</span> tot_cred <span class="operator">=</span> (</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">case</span></span><br><span class="line">        <span class="keyword">when</span> <span class="built_in">sum</span>(credits) <span class="keyword">is</span> <span class="keyword">not null</span> <span class="keyword">then</span> <span class="built_in">sum</span>(credits)</span><br><span class="line">        <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">from</span> takes, course</span><br><span class="line">    <span class="keyword">where</span> takes.course_id <span class="operator">=</span> course.course_id</span><br><span class="line">        <span class="keyword">and</span> S.ID <span class="operator">=</span> takes.ID</span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="operator">&lt;&gt;</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">        <span class="keyword">and</span> takes.grade <span class="keyword">is</span> <span class="keyword">not null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="10-6-多表更新"><a href="#10-6-多表更新" class="headerlink" title="10.6 多表更新"></a>10.6 多表更新</h3><p><strong>示例：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给定：</span></span><br><span class="line"><span class="comment">-- Student(S#, Sname, age, ..., C#, Grade, ...)</span></span><br><span class="line"><span class="comment">-- SGrade(S#, C#, Grade)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 利用SGrade的内容更新Student</span></span><br><span class="line"><span class="keyword">update</span> Student <span class="keyword">as</span> A</span><br><span class="line"><span class="keyword">set</span> Grade <span class="operator">=</span> B.Grade</span><br><span class="line"><span class="keyword">from</span> SGrade <span class="keyword">as</span> B</span><br><span class="line"><span class="keyword">where</span> A.S# <span class="operator">=</span> B.S# <span class="keyword">and</span> A.C# <span class="operator">=</span> B.C#</span><br></pre></td></tr></table></figure><hr><h2 id="十一、重要实践建议"><a href="#十一、重要实践建议" class="headerlink" title="十一、重要实践建议"></a>十一、重要实践建议</h2><h3 id="11-1-命名规范"><a href="#11-1-命名规范" class="headerlink" title="11.1 命名规范"></a>11.1 命名规范</h3><ul><li>在Oracle等大型商用数据库系统中，关系表的属性名只能取英文名，不支持中文属性名</li><li>SQL Server支持中英文属性名</li><li>开发大型数据库应用时，程序访问的关系表属性名（最好）取英文名，便于应用程序的可移植性</li><li>准确表示英文专业术语</li></ul><h3 id="11-2-性能优化建议"><a href="#11-2-性能优化建议" class="headerlink" title="11.2 性能优化建议"></a>11.2 性能优化建议</h3><p>**1. 避免使用SELECT ***</p><ul><li>实际应用中避免在SELECT子句中使用*</li><li>防止索引失效</li></ul><p><strong>2. 避免属性NULL值</strong></p><ul><li>实际应用中避免引入属性NULL值</li><li>防止索引失效</li><li>用默认值（default value）替代</li></ul><p><strong>3. 控制FROM子句的表数量</strong></p><ul><li>FROM子句包括多个关系表时，要在WHERE子句中加入连接条件</li><li>防止出现代价高昂的多表笛卡尔积操作</li><li>频繁执行的SQL查询，FROM子句的表个数不要过多（不超过4个表）</li><li>如需查询涉及≥4张表，考虑将数据进行合并</li></ul><p><strong>4. 避免低效的嵌套查询</strong></p><ul><li>从SQL优化角度，避免使用低效的嵌套查询</li><li>改为FROM子句中的多表连接，便于DBMS查询优化</li></ul><p><strong>5. 避免大数据排序</strong></p><ul><li>不要用数据库的ORDER BY操作对大数据文件进行排序</li></ul><p><strong>6. 优先使用WITH子句</strong></p><ul><li>使用WITH子句将复杂查询分解为多步</li><li>逻辑清晰，便于维护</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这份课件涵盖了SQL的核心知识点：</p><ol><li><strong>数据定义（DDL）</strong> - 创建、修改、删除表结构</li><li><strong>基本查询（DML）</strong> - SELECT-FROM-WHERE结构</li><li><strong>高级查询</strong> - 连接、聚合、分组、排序</li><li><strong>集合操作</strong> - UNION、INTERSECT、EXCEPT</li><li><strong>嵌套查询</strong> - IN、EXISTS、ALL、SOME等</li><li><strong>数据修改</strong> - INSERT、DELETE、UPDATE</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关系模型 简读</title>
      <link href="/2025/12/22/DB_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/22/DB_%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="第一编：关系模型（Relational-Model）【Chapter-2】"><a href="#第一编：关系模型（Relational-Model）【Chapter-2】" class="headerlink" title="第一编：关系模型（Relational Model）【Chapter 2】"></a>第一编：关系模型（Relational Model）【Chapter 2】</h1><blockquote><p>这是<strong>整个数据库理论的根基</strong><br>👉 不懂这一章，SQL 永远是“背语法”</p></blockquote><hr><h2 id="一、什么是关系数据库（Relational-Database）"><a href="#一、什么是关系数据库（Relational-Database）" class="headerlink" title="一、什么是关系数据库（Relational Database）"></a>一、什么是关系数据库（Relational Database）</h2><h3 id="1️⃣-为什么需要关系模型？"><a href="#1️⃣-为什么需要关系模型？" class="headerlink" title="1️⃣ 为什么需要关系模型？"></a>1️⃣ 为什么需要关系模型？</h3><p>在关系模型之前：</p><ul><li>层次模型（树）</li><li>网状模型（图）</li></ul><p>👉 <strong>问题</strong>：</p><ul><li>数据结构复杂</li><li>查询困难</li><li>程序和数据强耦合</li></ul><p><strong>关系模型的革命性思想</strong>：</p><blockquote><p>👉 用“数学集合 + 二维表”来抽象现实世界的数据</p></blockquote><hr><h3 id="2️⃣-关系数据库的基本组成"><a href="#2️⃣-关系数据库的基本组成" class="headerlink" title="2️⃣ 关系数据库的基本组成"></a>2️⃣ 关系数据库的基本组成</h3><blockquote><p><strong>定义（直观）</strong><br>一个关系数据库 &#x3D; <strong>若干张二维表（关系）</strong></p></blockquote><table><thead><tr><th>表元素</th><th>数学&#x2F;理论名词</th><th>数据库名词</th></tr></thead><tbody><tr><td>行</td><td>Tuple</td><td>元组</td></tr><tr><td>列</td><td>Attribute</td><td>属性</td></tr><tr><td>表</td><td>Relation</td><td>关系</td></tr><tr><td>表头</td><td>Schema</td><td>模式</td></tr><tr><td>表中数据</td><td>Instance</td><td>实例</td></tr></tbody></table><hr><h2 id="二、关系模型的严格定义（Formal-Definition）"><a href="#二、关系模型的严格定义（Formal-Definition）" class="headerlink" title="二、关系模型的严格定义（Formal Definition）"></a>二、关系模型的严格定义（Formal Definition）</h2><blockquote><p>这是<strong>考试最爱考定义的地方</strong></p></blockquote><hr><h3 id="1️⃣-属性（Attribute）"><a href="#1️⃣-属性（Attribute）" class="headerlink" title="1️⃣ 属性（Attribute）"></a>1️⃣ 属性（Attribute）</h3><ul><li><p>属性表示一个“对象的特征”</p></li><li><p>用符号表示：<br>$$<br>A_1, A_2, \dots, A_n<br>$$</p></li></ul><p>📌 例子（instructor）：</p><ul><li>ID</li><li>name</li><li>dept_name</li><li>salary</li></ul><hr><h3 id="2️⃣-域（Domain）"><a href="#2️⃣-域（Domain）" class="headerlink" title="2️⃣ 域（Domain）"></a>2️⃣ 域（Domain）</h3><blockquote><p><strong>域 &#x3D; 属性允许取值的集合</strong></p></blockquote><p>$$<br>D_i &#x3D; { 所有 A_i 可以取的合法值 }<br>$$</p><p>📌 例：</p><ul><li>ID ∈ char(5)</li><li>salary ∈ numeric(8,2)</li></ul><p>⚠ <strong>重要思想</strong>：</p><ul><li>域是<strong>类型 + 约束</strong></li><li>域 ≠ 属性名</li></ul><hr><h3 id="3️⃣-关系模式（Relation-Schema）"><a href="#3️⃣-关系模式（Relation-Schema）" class="headerlink" title="3️⃣ 关系模式（Relation Schema）"></a>3️⃣ 关系模式（Relation Schema）</h3><blockquote><p><strong>描述“表长什么样”</strong></p></blockquote><p>形式化定义：<br>$$<br>R &#x3D; (A_1, A_2, \dots, A_n)<br>$$<br>📌 instructor 模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instructor(ID, name, dept_name, salary)</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-关系实例（Relation-Instance）"><a href="#4️⃣-关系实例（Relation-Instance）" class="headerlink" title="4️⃣ 关系实例（Relation Instance）"></a>4️⃣ 关系实例（Relation Instance）</h3><blockquote><p><strong>描述“表里现在有什么数据”</strong></p></blockquote><ul><li>某一时刻关系中所有元组的集合</li><li>随时间变化</li></ul><p>📌 记忆口诀：</p><blockquote><p><strong>模式是蓝图，实例是照片</strong></p></blockquote><hr><h3 id="5️⃣-元组（Tuple）"><a href="#5️⃣-元组（Tuple）" class="headerlink" title="5️⃣ 元组（Tuple）"></a>5️⃣ 元组（Tuple）</h3><ul><li>一个元组 &#x3D; 一行数据</li><li>是属性 → 值的映射</li></ul><p>数学上可理解为函数：<br>$$<br>t(A_i) \rightarrow D_i<br>$$</p><hr><h2 id="三、属性的本质约束（非常重要）"><a href="#三、属性的本质约束（非常重要）" class="headerlink" title="三、属性的本质约束（非常重要）"></a>三、属性的本质约束（非常重要）</h2><hr><h3 id="1️⃣-原子性（Atomicity）——第一范式（1NF）"><a href="#1️⃣-原子性（Atomicity）——第一范式（1NF）" class="headerlink" title="1️⃣ 原子性（Atomicity）——第一范式（1NF）"></a>1️⃣ 原子性（Atomicity）——第一范式（1NF）</h3><blockquote><p><strong>每个属性值必须是“不可再分”的</strong></p></blockquote><p>❌ 错误示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone = &#123;138..., 139...&#125;</span><br></pre></td></tr></table></figure><p>✅ 正确做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phone1, phone2</span><br></pre></td></tr></table></figure><p>📌 原因：</p><ul><li>保证运算有明确语义</li><li>简化查询与比较</li></ul><p>📌 考试常问：</p><blockquote><p>“为什么关系模型要求 1NF？”</p></blockquote><hr><h3 id="2️⃣-Null-值（Null）"><a href="#2️⃣-Null-值（Null）" class="headerlink" title="2️⃣ Null 值（Null）"></a>2️⃣ Null 值（Null）</h3><blockquote><p>Null ≠ 0<br>Null ≠ 空字符串</p></blockquote><p>Null 表示：</p><ul><li>值未知</li><li>值不存在</li><li>尚未填写</li></ul><hr><h4 id="⚠-Null-带来的三大问题（老师重点）"><a href="#⚠-Null-带来的三大问题（老师重点）" class="headerlink" title="⚠ Null 带来的三大问题（老师重点）"></a>⚠ Null 带来的三大问题（老师重点）</h4><p>1️⃣ 比较失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salary <span class="operator">=</span> <span class="keyword">null</span>   <span class="comment">-- 永远为 unknown</span></span><br></pre></td></tr></table></figure><p>2️⃣ 三值逻辑（true &#x2F; false &#x2F; unknown）</p><p>3️⃣ 索引可能失效（工程大忌）</p><p>👉 <strong>工程建议</strong>：</p><ul><li>尽量用 default value 替代 null</li></ul><hr><h2 id="四、关系的“无序性”（常被忽略但很重要）"><a href="#四、关系的“无序性”（常被忽略但很重要）" class="headerlink" title="四、关系的“无序性”（常被忽略但很重要）"></a>四、关系的“无序性”（常被忽略但很重要）</h2><h3 id="1️⃣-元组无序"><a href="#1️⃣-元组无序" class="headerlink" title="1️⃣ 元组无序"></a>1️⃣ 元组无序</h3><ul><li>表中行没有先后顺序</li><li>存储顺序 ≠ 逻辑顺序</li></ul><hr><h3 id="2️⃣-属性无序"><a href="#2️⃣-属性无序" class="headerlink" title="2️⃣ 属性无序"></a>2️⃣ 属性无序</h3><p>$$<br>(A_1, A_2, A_3) &#x3D; (A_3, A_1, A_2)<br>$$</p><p>👉 这就是为什么 <strong>SQL 必须写列名</strong></p><hr><h2 id="五、数据库模式与实例（Schema-vs-Instance）"><a href="#五、数据库模式与实例（Schema-vs-Instance）" class="headerlink" title="五、数据库模式与实例（Schema vs Instance）"></a>五、数据库模式与实例（Schema vs Instance）</h2><h3 id="1️⃣-数据库模式（Database-Schema）"><a href="#1️⃣-数据库模式（Database-Schema）" class="headerlink" title="1️⃣ 数据库模式（Database Schema）"></a>1️⃣ 数据库模式（Database Schema）</h3><ul><li>全局逻辑结构</li><li>不随时间变化</li></ul><hr><h3 id="2️⃣-数据库实例（Database-Instance）"><a href="#2️⃣-数据库实例（Database-Instance）" class="headerlink" title="2️⃣ 数据库实例（Database Instance）"></a>2️⃣ 数据库实例（Database Instance）</h3><ul><li>某一时刻所有关系实例的集合</li><li>会随插入、删除、更新变化</li></ul><p>📌 考试爱问对比题</p><hr><h2 id="六、键（Keys）——关系模型的核心"><a href="#六、键（Keys）——关系模型的核心" class="headerlink" title="六、键（Keys）——关系模型的核心"></a>六、键（Keys）——关系模型的核心</h2><hr><h3 id="1️⃣-超键（Super-Key）"><a href="#1️⃣-超键（Super-Key）" class="headerlink" title="1️⃣ 超键（Super Key）"></a>1️⃣ 超键（Super Key）</h3><blockquote><p>能唯一标识元组的<strong>属性集合</strong></p></blockquote><p>形式化定义：</p><p>若<br>$$<br>t_1 \neq t_2 \Rightarrow t_1[K] \neq t_2[K]<br>$$<br>则 K 是超键</p><p>📌 示例：</p><ul><li>{ID}</li><li>{ID, name}</li><li>{ID, dept_name}</li></ul><p>⚠ 超键可能冗余</p><hr><h3 id="2️⃣-候选键（Candidate-Key）"><a href="#2️⃣-候选键（Candidate-Key）" class="headerlink" title="2️⃣ 候选键（Candidate Key）"></a>2️⃣ 候选键（Candidate Key）</h3><blockquote><p><strong>最小的超键</strong></p></blockquote><ul><li>去掉任何属性就不唯一</li></ul><p>📌 instructor：</p><ul><li>{ID} ✔</li><li>{ID, name} ❌（非最小）</li></ul><hr><h3 id="3️⃣-主键（Primary-Key）"><a href="#3️⃣-主键（Primary-Key）" class="headerlink" title="3️⃣ 主键（Primary Key）"></a>3️⃣ 主键（Primary Key）</h3><blockquote><p>从候选键中选一个作为“官方身份标识”</p></blockquote><p><strong>约束：</strong></p><ul><li>唯一</li><li>非空</li></ul><p>📌 工程经验（老师强调）：</p><ul><li>尽量用 int &#x2F; float</li><li>避免 varchar &#x2F; datetime</li></ul><hr><h3 id="4️⃣-主属性-非主属性"><a href="#4️⃣-主属性-非主属性" class="headerlink" title="4️⃣ 主属性 &amp; 非主属性"></a>4️⃣ 主属性 &amp; 非主属性</h3><ul><li>主属性：出现在候选键中的属性</li><li>非主属性：其余</li></ul><p>📌 后续 <strong>函数依赖、范式分解</strong> 的基础</p><hr><h2 id="七、外键（Foreign-Key）与参照完整性"><a href="#七、外键（Foreign-Key）与参照完整性" class="headerlink" title="七、外键（Foreign Key）与参照完整性"></a>七、外键（Foreign Key）与参照完整性</h2><hr><h3 id="1️⃣-外键定义（极重要）"><a href="#1️⃣-外键定义（极重要）" class="headerlink" title="1️⃣ 外键定义（极重要）"></a>1️⃣ 外键定义（极重要）</h3><p>若：</p><ul><li>r1 中属性 X</li><li>X 是 r2 的主键</li></ul><p>则：</p><blockquote><p>X 是 <strong>r1 引用 r2 的外键</strong></p></blockquote><hr><h3 id="2️⃣-参照完整性（Referential-Integrity）"><a href="#2️⃣-参照完整性（Referential-Integrity）" class="headerlink" title="2️⃣ 参照完整性（Referential Integrity）"></a>2️⃣ 参照完整性（Referential Integrity）</h3><blockquote><p><strong>外键值必须在被参照表中存在</strong></p></blockquote><p>📌 instructor.dept_name ∈ department.dept_name</p><hr><h3 id="3️⃣-数据导入顺序（实践必考）"><a href="#3️⃣-数据导入顺序（实践必考）" class="headerlink" title="3️⃣ 数据导入顺序（实践必考）"></a>3️⃣ 数据导入顺序（实践必考）</h3><ol><li>先插入被参照表（department）</li><li>再插入参照表（instructor）</li></ol><p>否则违反外键约束</p><hr><h2 id="八、关系代数（Relational-Algebra）"><a href="#八、关系代数（Relational-Algebra）" class="headerlink" title="八、关系代数（Relational Algebra）"></a>八、关系代数（Relational Algebra）</h2><blockquote><p>SQL 的<strong>数学基础</strong></p></blockquote><hr><h3 id="1️⃣-查询语言分类"><a href="#1️⃣-查询语言分类" class="headerlink" title="1️⃣ 查询语言分类"></a>1️⃣ 查询语言分类</h3><table><thead><tr><th>类型</th><th>特点</th></tr></thead><tbody><tr><td>过程式</td><td>说明“怎么做”</td></tr><tr><td>声明式</td><td>说明“要什么”</td></tr></tbody></table><p>关系代数 &#x3D; 过程式<br>SQL &#x3D; 声明式（但底层会转成代数）</p><hr><h3 id="2️⃣-六个基本运算（必须会）"><a href="#2️⃣-六个基本运算（必须会）" class="headerlink" title="2️⃣ 六个基本运算（必须会）"></a>2️⃣ 六个基本运算（必须会）</h3><table><thead><tr><th>运算</th><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>选择</td><td>σ</td><td>行筛选</td></tr><tr><td>投影</td><td>π</td><td>列筛选</td></tr><tr><td>笛卡尔积</td><td>×</td><td>表组合</td></tr><tr><td>并</td><td>∪</td><td>合并</td></tr><tr><td>差</td><td>−</td><td>排除</td></tr><tr><td>重命名</td><td>ρ</td><td>改名</td></tr></tbody></table><hr><h3 id="3️⃣-选择（σ）"><a href="#3️⃣-选择（σ）" class="headerlink" title="3️⃣ 选择（σ）"></a>3️⃣ 选择（σ）</h3><p>$$<br>\sigma_{条件}(r)<br>$$</p><ul><li>条件是布尔表达式</li><li>支持：<ul><li>比较</li><li>逻辑组合</li><li>属性间比较</li></ul></li></ul><p>📌 SQL 对应：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><hr><h3 id="4️⃣-投影（π）"><a href="#4️⃣-投影（π）" class="headerlink" title="4️⃣ 投影（π）"></a>4️⃣ 投影（π）</h3><p>$$<br>\pi_{A_1,A_2}(r)<br>$$</p><ul><li>只保留指定列</li><li>自动去重</li></ul><p>📌 SQL 对应：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> ...</span><br></pre></td></tr></table></figure><hr><h3 id="5️⃣-连接-笛卡尔积-选择"><a href="#5️⃣-连接-笛卡尔积-选择" class="headerlink" title="5️⃣ 连接 &#x3D; 笛卡尔积 + 选择"></a>5️⃣ 连接 &#x3D; 笛卡尔积 + 选择</h3><p>$$<br>\sigma_{r.A &#x3D; s.B}(r \times s)<br>$$</p><p>👉 自然连接是语法糖</p><hr><h3 id="6️⃣-查询等价与优化"><a href="#6️⃣-查询等价与优化" class="headerlink" title="6️⃣ 查询等价与优化"></a>6️⃣ 查询等价与优化</h3><ul><li>结果相同 ≠ 代价相同</li><li>数据库会重写查询</li></ul><p>📌 <strong>这是后面“查询优化”的起点</strong></p><hr><hr>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
            <tag> 关系模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自注意力机制_简读</title>
      <link href="/2025/12/16/self-attention%E7%AE%80%E8%AF%BB/"/>
      <url>/2025/12/16/self-attention%E7%AE%80%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="引言：自注意力——序列建模的新范式"><a href="#引言：自注意力——序列建模的新范式" class="headerlink" title="引言：自注意力——序列建模的新范式"></a>引言：自注意力——序列建模的新范式</h2><p>在深度学习的发展历程中，序列建模一直是极具挑战性的任务。从早期的循环神经网络（RNN）到长短期记忆网络（LSTM），研究者们不断探索如何有效捕捉序列数据中的依赖关系。然而，这些模型都存在一个根本性局限：<strong>顺序处理机制</strong>导致计算无法并行化，且难以建模长距离依赖。</p><p>自注意力（Self-Attention）机制的提出彻底改变了这一局面。它不仅解决了长距离依赖问题，还实现了高效的并行计算，成为自然语言处理、计算机视觉乃至语音处理等领域的核心技术。</p><p>本文将深入剖析自注意力机制的多个关键方面，包括其如何编码位置信息、如何应对超长序列、以及与卷积神经网络和循环神经网络的对比，为你呈现一个完整的自注意力知识图谱。</p><h2 id="位置编码：为无位置感知的自注意力注入顺序信息"><a href="#位置编码：为无位置感知的自注意力注入顺序信息" class="headerlink" title="位置编码：为无位置感知的自注意力注入顺序信息"></a>位置编码：为无位置感知的自注意力注入顺序信息</h2><h3 id="问题的本质：自注意力的“位置盲”"><a href="#问题的本质：自注意力的“位置盲”" class="headerlink" title="问题的本质：自注意力的“位置盲”"></a>问题的本质：自注意力的“位置盲”</h3><p>自注意力机制有一个根本特性：<strong>它对输入序列中元素的绝对位置或相对顺序没有内在感知</strong>。这是因为自注意力通过查询（Query）、键（Key）和值（Value）的交互计算注意力权重时，仅考虑内容相似性，而不考虑位置关系。</p><p>这就造成了一个有趣的现象：对于自注意力层来说，序列中第一个位置和最后一个位置在计算上是完全平等的——“天涯若比邻”，所有位置之间的距离在计算上没有差别。但在许多实际任务中，位置信息至关重要。例如在词性标注任务中，动词很少出现在句首；在语音识别中，声音信号的时序关系是关键线索。</p><h3 id="解决方案：将位置信息显式编码"><a href="#解决方案：将位置信息显式编码" class="headerlink" title="解决方案：将位置信息显式编码"></a>解决方案：将位置信息显式编码</h3><p>为了解决这一问题，研究者们提出了<strong>位置编码（Positional Encoding）</strong>。其核心思想是为序列中的每个位置分配一个独特的向量表示，然后将这个位置向量与对应位置的输入向量相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入 = 内容向量 + 位置向量</span><br></pre></td></tr></table></figure><p>这样，自注意力机制在计算时就能同时考虑内容信息和位置信息。</p><h3 id="位置编码的实现方式"><a href="#位置编码的实现方式" class="headerlink" title="位置编码的实现方式"></a>位置编码的实现方式</h3><p>位置编码有多种实现方法：</p><ol><li><p><strong>正弦&#x2F;余弦函数编码</strong>：这是Transformer原始论文采用的方法，使用不同频率的正弦和余弦函数生成位置向量：</p><ul><li><p>优点：可以处理任意长度的序列，且能捕捉相对位置关系</p></li><li><p>原理：不同维度使用不同频率的三角函数，使模型能够学习到相对位置关系</p></li></ul></li><li><p><strong>可学习的位置编码</strong>：将位置编码作为可训练参数，随模型一同学习</p><ul><li><p>优点：更加灵活，能够适应特定任务的需求</p></li><li><p>缺点：无法处理训练时未见过的序列长度</p></li></ul></li><li><p><strong>相对位置编码</strong>：关注元素之间的相对距离而非绝对位置</p><ul><li><p>优点：更好地泛化到不同长度的序列</p></li><li><p>应用：在诸如Transformer-XL等改进模型中使用</p></li></ul></li></ol><p>位置编码的研究仍在继续，最新研究如《Learning to Encode Position for Transformer with Continuous Dynamical Model》探索了更动态、更灵活的位置编码方法。</p><h2 id="截断自注意力：应对超长序列的计算挑战"><a href="#截断自注意力：应对超长序列的计算挑战" class="headerlink" title="截断自注意力：应对超长序列的计算挑战"></a>截断自注意力：应对超长序列的计算挑战</h2><h3 id="问题的根源：二次方复杂度"><a href="#问题的根源：二次方复杂度" class="headerlink" title="问题的根源：二次方复杂度"></a>问题的根源：二次方复杂度</h3><p>标准自注意力机制有一个显著的计算瓶颈：<strong>计算复杂度与序列长度的二次方成正比</strong>。具体来说，对于一个长度为L的序列，自注意力需要计算L×L的注意力矩阵，这在序列很长时会带来巨大的计算和内存开销。</p><p>例如在语音处理任务中，1秒的声音信号可能对应100个向量，5秒就是500个向量，普通的一句话就可能包含数千个向量。如此长的序列会使注意力矩阵变得极其庞大，难以处理和训练。</p><h3 id="截断自注意力：局部关注的智慧"><a href="#截断自注意力：局部关注的智慧" class="headerlink" title="截断自注意力：局部关注的智慧"></a>截断自注意力：局部关注的智慧</h3><p>截断自注意力（Truncated Self-Attention）是一种有效的解决方案。其核心思想是：<strong>让每个位置只关注其周围有限范围内的其他位置，而不是整个序列</strong>。</p><p>这种设计基于一个合理的假设：在许多任务中，一个元素的语义主要受其邻近元素影响。例如在语音识别中，要识别某个位置的音素，通常只需要考虑其前后一定时间范围内的声音信号即可。</p><h3 id="实现方式与优势"><a href="#实现方式与优势" class="headerlink" title="实现方式与优势"></a>实现方式与优势</h3><p>截断自注意力通过限制每个查询向量只能与一定窗口内的键向量交互来实现：</p><ul><li><p><strong>固定窗口</strong>：每个位置只关注前后k个位置</p></li><li><p><strong>动态窗口</strong>：根据内容动态决定关注范围</p></li><li><p><strong>分层注意力</strong>：结合不同粒度的注意力，先粗后细</p></li></ul><p>截断自注意力的主要优势包括：</p><ol><li><p>将计算复杂度从O(L²)降低到O(L×k)，其中k是窗口大小</p></li><li><p>大幅减少内存消耗</p></li><li><p>在某些任务上可能提高性能，因为避免了无关远程信息的干扰</p></li></ol><h2 id="自注意力与卷积神经网络：两种视觉架构的对比"><a href="#自注意力与卷积神经网络：两种视觉架构的对比" class="headerlink" title="自注意力与卷积神经网络：两种视觉架构的对比"></a>自注意力与卷积神经网络：两种视觉架构的对比</h2><h3 id="图像作为向量序列：统一的数据视角"><a href="#图像作为向量序列：统一的数据视角" class="headerlink" title="图像作为向量序列：统一的数据视角"></a>图像作为向量序列：统一的数据视角</h3><p>传统上，图像处理是卷积神经网络（CNN）的领域。但如果我们换个视角，将图像视为一个向量序列，就能用自注意力处理图像任务：</p><p>一张H×W×C的图像可以看作H×W个C维向量组成的序列，其中每个向量对应一个像素（或一个图像块）。基于这种表示，自注意力可以直接应用于图像数据，相关研究包括《Self-Attention Generative Adversarial Networks》和《End-to-End Object Detection with Transformers》。</p><h3 id="感受野：人工划定与自动学习"><a href="#感受野：人工划定与自动学习" class="headerlink" title="感受野：人工划定与自动学习"></a>感受野：人工划定与自动学习</h3><p>卷积神经网络和自注意力在如何处理图像信息上有着根本区别：</p><ul><li><p><strong>卷积神经网络</strong>：每个神经元只处理局部感受野内的信息，感受野的大小和形状是<strong>人工预设</strong>的</p></li><li><p><strong>自注意力</strong>：每个位置可以与图像中任何其他位置交互，有效感受野是<strong>自动学习</strong>的</p></li></ul><p>这种差异带来一个有趣的结论：<strong>卷积神经网络实际上是自注意力的一个特例</strong>。当自注意力被约束为只关注局部区域，并且权重共享时，它就退化成了卷积操作。这一观点在论文《On the Relationship between Self-attention and Convolutional Layers》中得到了数学上的严格证明。</p><h3 id="灵活性与数据需求的平衡"><a href="#灵活性与数据需求的平衡" class="headerlink" title="灵活性与数据需求的平衡"></a>灵活性与数据需求的平衡</h3><p>自注意力的灵活性既是优势也是挑战：</p><ul><li><p><strong>灵活性</strong>：自注意力能够自适应地学习不同位置之间的关系模式，不受固定几何结构的限制</p></li><li><p><strong>数据需求</strong>：更高的灵活性意味着更大的假设空间，需要更多数据来学习有效的模式</p></li></ul><p>谷歌的研究《An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale》清楚地展示了这一权衡：</p><ul><li><p>在小规模数据（1000万张图像）上，CNN表现更好</p></li><li><p>在大规模数据（3亿张图像）上，Vision Transformer超越CNN</p></li></ul><p>这一现象揭示了深度学习中一个普遍规律：<strong>更灵活的模型需要更多数据来发挥潜力</strong>。在实际应用中，可以根据数据量的大小选择合适的架构，或者将两者结合（如Conformer模型同时使用自注意力和卷积）。</p><h2 id="自注意力与循环神经网络：序列建模的范式转变"><a href="#自注意力与循环神经网络：序列建模的范式转变" class="headerlink" title="自注意力与循环神经网络：序列建模的范式转变"></a>自注意力与循环神经网络：序列建模的范式转变</h2><h3 id="处理序列的两种哲学"><a href="#处理序列的两种哲学" class="headerlink" title="处理序列的两种哲学"></a>处理序列的两种哲学</h3><p>循环神经网络（RNN）和自注意力代表了序列建模的两种不同哲学：</p><ul><li><p><strong>RNN的迭代哲学</strong>：逐步处理序列，将历史信息压缩到隐藏状态中，具有内在的顺序性</p></li><li><p><strong>自注意力的并行哲学</strong>：同时处理所有位置，通过注意力机制直接建立任意两个位置的联系</p></li></ul><p>即使是最先进的双向RNN，要捕捉长距离依赖也需要将信息“记忆”并传递很长距离，而自注意力可以“天涯若比邻”，直接建立远程连接。</p><h3 id="并行化：效率的革命性提升"><a href="#并行化：效率的革命性提升" class="headerlink" title="并行化：效率的革命性提升"></a>并行化：效率的革命性提升</h3><p>自注意力相对于RNN最显著的优势是<strong>完全并行化</strong>：</p><ul><li><p>RNN必须顺序处理序列，每一步都依赖前一步的输出</p></li><li><p>自注意力可以同时计算所有位置的表示，极大提高了计算效率</p></li></ul><p>这一差异在现代硬件（尤其是GPU&#x2F;TPU）上具有重大意义，使得训练大规模序列模型成为可能。</p><h3 id="信息流动的差异"><a href="#信息流动的差异" class="headerlink" title="信息流动的差异"></a>信息流动的差异</h3><p>两种架构在信息流动路径上也存在根本差异：</p><ul><li><p>RNN的信息流动是<strong>序列化的</strong>，信息从早期位置流向后期位置需要经过多个时间步</p></li><li><p>自注意力的信息流动是<strong>全连接的</strong>，任何两个位置都可以直接交互</p></li></ul><p>这使得自注意力特别适合建模复杂的长距离依赖，而这是许多序列任务（如机器翻译、文档理解）的关键。</p><h2 id="自注意力在图数据上的应用"><a href="#自注意力在图数据上的应用" class="headerlink" title="自注意力在图数据上的应用"></a>自注意力在图数据上的应用</h2><p>图数据（节点和边组成的结构）也可以使用自注意力处理，此时需要做适当调整：</p><ol><li><p><strong>节点作为向量</strong>：图中的每个节点可以表示为一个向量</p></li><li><p><strong>边作为注意力约束</strong>：已有的边信息可以作为先验，约束注意力计算只发生在相连的节点之间</p></li><li><p><strong>图神经网络作为受限自注意力</strong>：这种受限的自注意力本质上就是图神经网络（GNN）的一种形式</p></li></ol><p>这种方法的优势在于结合了数据驱动的关系学习和先验的结构信息，在社交网络分析、分子结构建模等领域有广泛应用。</p><h2 id="自注意力的变体与未来方向"><a href="#自注意力的变体与未来方向" class="headerlink" title="自注意力的变体与未来方向"></a>自注意力的变体与未来方向</h2><p>随着研究的深入，出现了多种自注意力变体，旨在解决标准自注意力的各种限制：</p><ol><li><p><strong>效率优化型</strong>：如Linformer、Performer、Reformer等，通过数学近似或架构改进降低计算复杂度</p></li><li><p><strong>长序列专用型</strong>：如Longformer、BigBird等，专门处理极长序列</p></li><li><p><strong>领域适配型</strong>：针对特定任务或数据类型的定制化注意力机制</p></li></ol><p>《Long Range Arena: A Benchmark for Efficient Transformers》系统比较了各种自注意力变体，《Efficient Transformers: A Survey》则全面综述了这一领域的发展。</p><h2 id="结语：自注意力——深度学习的通用构件"><a href="#结语：自注意力——深度学习的通用构件" class="headerlink" title="结语：自注意力——深度学习的通用构件"></a>结语：自注意力——深度学习的通用构件</h2><p>自注意力机制已经从自然语言处理领域的一个创新，发展成为深度学习的通用构件。它的核心价值在于：</p><ol><li><p><strong>灵活性</strong>：能够适应各种类型的数据和任务</p></li><li><p><strong>可并行性</strong>：充分利用现代计算硬件</p></li><li><p><strong>长距离建模能力</strong>：直接建立远程依赖关系</p></li><li><p><strong>可解释性</strong>：注意力权重提供了模型决策的透明视图</p></li></ol><p>然而，自注意力并非万能钥匙。它的高计算复杂度、对大规模数据的依赖以及在某些任务上的次优表现，都是需要继续研究的问题。未来的方向可能包括更高效的注意力机制、更好的位置编码方法，以及与其他架构（如CNN、GNN）的更深度融合。</p><p>自注意力的发展历程体现了深度学习研究的一个核心理念：<strong>寻找既强大又高效的通用归纳偏置</strong>。它不仅仅是一个技术工具，更是一种重新思考序列建模、关系建模乃至结构化数据建模的新范式。随着研究的不断深入，我们有理由相信，自注意力及其变体将继续推动人工智能技术的发展边界。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Self Attention </tag>
            
            <tag> 自注意力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSTM简读</title>
      <link href="/2025/12/16/RNN%E7%AC%94%E8%AE%B0/"/>
      <url>/2025/12/16/RNN%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="本质与起源"><a href="#本质与起源" class="headerlink" title="本质与起源"></a>本质与起源</h2><p>长短期记忆网络（Long Short-Term Memory，LSTM）是一种特殊的循环神经网络架构，其根本目的在于解决传统RNN在处理长序列数据时面临的<strong>长期依赖学习难题</strong>。这个问题的核心在于：当序列长度增加时，信息在时间维度上反向传播时会出现<strong>梯度动力学失衡</strong>——梯度要么指数级衰减至近乎消失，无法影响早期时间步的参数更新；要么指数级增长引发数值爆炸，导致训练崩溃。</p><p>LSTM的哲学智慧在于：<strong>将信息存储与信息处理分离</strong>。它通过引入一个独立且受保护的记忆通道，使得信息能够在时间轴上稳定传输，同时通过可学习的门控机制来决定信息的进出与留存，从而模拟人类记忆的“选择性记忆”与“选择性遗忘”过程。</p><h2 id="核心架构的深度剖析"><a href="#核心架构的深度剖析" class="headerlink" title="核心架构的深度剖析"></a>核心架构的深度剖析</h2><h3 id="记忆元（Memory-Cell）：信息的持久化载体"><a href="#记忆元（Memory-Cell）：信息的持久化载体" class="headerlink" title="记忆元（Memory Cell）：信息的持久化载体"></a>记忆元（Memory Cell）：信息的持久化载体</h3><p>记忆元是LSTM的灵魂所在，它是一个贯穿时间序列的连续状态流。与传统RNN中隐藏状态不断被覆写不同，记忆元的设计允许信息以<strong>累积而非替换</strong>的方式存在。这种设计带来了两个关键优势：</p><ol><li><p><strong>梯度流的持续性</strong>：由于记忆元的更新是加法操作（旧状态的部分保留加上新输入的部分添加），梯度在反向传播时可以通过记忆元路径稳定流动，避免了传统RNN中因矩阵连乘导致的梯度指数衰减或爆炸。</p></li><li><p><strong>信息生命周期管理</strong>：记忆元中的信息可以理论上无限期保存，除非被主动遗忘。这使网络能够捕捉跨越数百甚至数千时间步的依赖关系。</p></li></ol><h3 id="门控机制的三位一体"><a href="#门控机制的三位一体" class="headerlink" title="门控机制的三位一体"></a>门控机制的三位一体</h3><p>LSTM的精妙之处在于它的三个门，每个门都是一个独立的神经网络层，使用sigmoid激活函数将输入映射到[0,1]区间，实现对信息流的<strong>精细化模拟调控</strong>。</p><p><strong>遗忘门（Forget Gate）</strong> 控制历史记忆的留存比例。其设计哲学是：并非所有过去信息都值得保留。门输出值接近1表示“完全记住”，接近0表示“完全遗忘”。这里有一个重要的认知反直觉点：在LSTM的术语中，“遗忘门开启”意味着保留记忆，“关闭”意味着遗忘。这种设计源于sigmoid函数的输出特性，通常通过偏置初始化来设定默认行为（正偏置使门倾向于开启）。</p><p><strong>输入门（Input Gate）</strong> 控制新信息的准入程度。它决定当前时间步的候选信息有多少值得纳入长期记忆。候选信息本身由tanh函数生成，提供非线性变换并将值规范到[-1,1]范围。输入门与候选信息的逐元素相乘实现了对新信息的过滤和加权。</p><p><strong>输出门（Output Gate）</strong> 控制记忆对外的显露程度。记忆元内部状态经过tanh规范化后，由输出门调节最终暴露给外部网络的部分。这种设计使LSTM能够区分“内部存储”与“对外发布”，增加了信息处理的层次性。</p><h3 id="信息流动的完整动力学"><a href="#信息流动的完整动力学" class="headerlink" title="信息流动的完整动力学"></a>信息流动的完整动力学</h3><p>记忆元的更新遵循一个物理直观的方程：<strong>新记忆 &#x3D; 旧记忆 × 遗忘比例 + 新信息 × 输入比例</strong>。这种形式本质上是<strong>带门控的残差连接</strong>，它确保了：</p><ul><li><p>当遗忘门接近1且输入门接近0时，记忆几乎完全保留，新信息被阻挡</p></li><li><p>当遗忘门接近0且输入门接近1时，记忆被清空，新信息完全写入</p></li><li><p>在大多数中间状态，实现新旧信息的平滑融合</p></li></ul><p>隐藏状态的生成则是内部记忆的受限视图：记忆元状态经tanh压缩后，由输出门调制输出。这种分离使得LSTM可以存储不直接输出的中间信息，增加了网络的表征能力。</p><h2 id="训练动态与优化考量"><a href="#训练动态与优化考量" class="headerlink" title="训练动态与优化考量"></a>训练动态与优化考量</h2><h3 id="梯度行为的根本改善"><a href="#梯度行为的根本改善" class="headerlink" title="梯度行为的根本改善"></a>梯度行为的根本改善</h3><p>LSTM解决梯度消失问题的核心机制在于其<strong>加法更新路径</strong>。在反向传播时，梯度可以通过记忆元路径以近似常数的形式回溯，因为：</p><p>$∂c_t&#x2F;∂c_{t-1} &#x3D; f_t + (其他项)$</p><p>只要遗忘门f_t保持在合理范围（如接近1），这个导数就不会消失。相比之下，传统RNN的对应项是权重矩阵的连乘，极易导致梯度指数变化。</p><p>然而，LSTM并未完全消除梯度爆炸风险。门控信号本身的生成涉及权重矩阵乘法，这些路径仍可能出现大梯度。因此，<strong>梯度裁剪</strong>成为LSTM训练的标配技术，通过限制梯度范数防止参数更新步长过大。</p><h3 id="参数初始化策略"><a href="#参数初始化策略" class="headerlink" title="参数初始化策略"></a>参数初始化策略</h3><p>LSTM的初始状态设定深刻影响其学习行为：</p><ul><li><p>遗忘门偏置通常初始化为正数（如+1），确保初始阶段倾向于保留记忆</p></li><li><p>输入门偏置可初始化为零或负数，避免早期过度写入</p></li><li><p>输出门偏置可初始化为零或负数，控制信息释放节奏</p></li><li><p>权重矩阵常用正交初始化或Xavier初始化，保持激活值方差稳定</p></li></ul><h3 id="正则化与结构变体"><a href="#正则化与结构变体" class="headerlink" title="正则化与结构变体"></a>正则化与结构变体</h3><p>在LSTM中应用Dropout需要特别注意：<strong>时间步之间的Dropout会破坏序列依赖性</strong>，因此通常只在层间或垂直方向应用。循环Dropout（在隐藏状态间随机丢弃）需要精心设计以保持长期记忆能力。</p><p><strong>Peephole连接</strong>是LSTM的一个重要扩展，允许门控单元直接“窥视”记忆元状态。这使得门控决策不仅基于输入和前一隐藏状态，还能感知当前记忆内容，理论上增强了门控的精确性。其连接方式有三种变体：仅输入遗忘门查看前一时刻记忆，仅输出门查看当前记忆，或所有门都查看相应记忆。</p><h2 id="扩展生态与简化版本"><a href="#扩展生态与简化版本" class="headerlink" title="扩展生态与简化版本"></a>扩展生态与简化版本</h2><p><strong>多层LSTM</strong>通过堆叠多个LSTM层构建深度时序模型。深层结构能够学习不同时间尺度上的特征：底层捕捉局部模式，高层整合全局依赖。层间连接可以是简单的传递，也可以加入跳跃连接缓解优化难度。</p><p><strong>双向LSTM</strong>同时考虑过去和未来上下文，通过前向和后向两个LSTM的隐藏状态拼接，获得每个时间步的完整语境表征。这在序列标注等任务中效果显著。</p><p><strong>门控循环单元（GRU）</strong> 作为LSTM的简化版本，将输入门和遗忘门合并为<strong>更新门</strong>，并取消了独立的记忆元与隐藏状态的分离。GRU的参数减少约1&#x2F;3，训练速度更快，内存占用更少，在许多任务上与LSTM性能相当。其核心思想是“以新换旧”的更新策略：更新门同时控制旧状态的保留比例和新状态的写入比例。</p><h2 id="为什么LSTM有效：多重视角理解"><a href="#为什么LSTM有效：多重视角理解" class="headerlink" title="为什么LSTM有效：多重视角理解"></a>为什么LSTM有效：多重视角理解</h2><p><strong>信息论视角</strong>：LSTM实现了可变速率的信息通道。遗忘门控制信息衰减率，输入门控制信息获取率，输出门控制信息释放率。这三个速率参数通过数据学习自适应调整，使网络在信息保存与更新间达到动态平衡。</p><p><strong>动力学系统视角</strong>：记忆元构成一个缓慢变化的动态系统，门控机制引入快变子系统。这种时间尺度分离使网络能同时捕捉快速变化的模式特征和缓慢演变的语境信息。</p><p><strong>算法视角</strong>：LSTM本质上学习了一个可微分的记忆管理算法。它通过门控函数实现了类似“if-else”的条件逻辑，但完全可微分，能够通过梯度下降端到端优化。</p><p><strong>认知科学视角</strong>：LSTM的结构与工作记忆模型有内在相似性。记忆元类似于工作记忆的存储缓冲区，门控机制类似于注意力的分配过程，输出门类似于回忆提取过程。</p><h2 id="实践中的深刻洞察"><a href="#实践中的深刻洞察" class="headerlink" title="实践中的深刻洞察"></a>实践中的深刻洞察</h2><ol><li><p><strong>LSTM不是万能的</strong>：对于极长序列（如数千步），即使LSTM也可能出现梯度动力学问题。此时可能需要结合注意力机制或层次化处理。</p></li><li><p><strong>计算代价与收益</strong>：LSTM的4倍参数增长带来显著的表达能力和记忆容量提升，但也增加了过拟合风险。需要根据数据规模和任务复杂度权衡。</p></li><li><p><strong>时间方向的不可逆性</strong>：标准LSTM严格遵循时间因果律，这在许多时序预测任务中是优势，但也限制了某些场景下对双向上下文的同时利用。</p></li><li><p><strong>记忆与泛化的张力</strong>：LSTM的强大记忆能力可能使其过度拟合训练数据的特定时间模式，需要适当的正则化引导其学习通用时序动态。</p></li></ol><h2 id="总结升华"><a href="#总结升华" class="headerlink" title="总结升华"></a>总结升华</h2><p>LSTM的突破性贡献在于：<strong>它将记忆本身作为可学习的对象</strong>。传统RNN将记忆视为隐藏状态演化的副产品，而LSTM明确构建了一个受保护的记忆通道，并通过可微分的门控机制赋予网络管理自身记忆的能力。</p><p>这种架构创新背后的核心洞见是：<strong>长期依赖学习的关键不是避免梯度消失，而是提供梯度流动的稳定通路</strong>。LSTM通过加法更新路径和门控调制，创造了一条梯度可以无衰减回溯的“时间高速公路”，同时又不丧失对信息流动的精细控制。</p><p>更深层地看，LSTM的成功反映了神经网络设计的一个重要原则：<strong>好的归纳偏置应该编码在架构中，而非完全依赖数据学习</strong>。LSTM的架构本身编码了“信息应该被选择性地记忆和遗忘”这一关于时序数据本质的先验知识，这使得它在有限数据下也能学习有效的长期依赖。</p><p>从RNN到LSTM的演进，标志着循环神经网络从简单的时序函数逼近器，进化为具有内在记忆管理能力的复杂动态系统。这一进化不仅解决了长期依赖的技术难题，更开辟了神经网络模拟高阶认知功能的新可能。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活感悟</title>
      <link href="/2025/12/10/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD2/"/>
      <url>/2025/12/10/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD2/</url>
      
        <content type="html"><![CDATA[<p>！！！</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Yuejin的个人介绍</title>
      <link href="/2025/12/09/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/12/09/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>我是<em>Yuejin Wu</em>，目前是BUPT本科三年级学生 </p><p>专业是人工智能，还得 **考研 ** 🫥</p><p>我搭建这个<em>Yuejin’s Blog</em>，记录一下我的生活，监督一下我的学习，emmm要准备考研了 😵‍💫 </p><h3 id="简单介绍一下吧："><a href="#简单介绍一下吧：" class="headerlink" title="简单介绍一下吧："></a><strong><font color="red">简单介绍一下吧：</font></strong></h3><blockquote><p>我是<em>Yuejin Wu</em>, <em>BUPTer in AI</em> 🧑‍🎓</p><p>借这个博客，我将分享并同步我的学习，有太多的东西要学习：</p><ul><li>深度学习（代码好难写👨‍💻💔）</li><li>前后端开发（留条后路吧）</li><li><strong>English</strong>（我讨厌英语💩）</li><li><font color="green">考研考研考研</font> （祝我上岸吧，本校就好）🙏</li><li>再多的…下回分解吧</li></ul></blockquote><h3 id="我喜欢的："><a href="#我喜欢的：" class="headerlink" title="我喜欢的："></a><strong><font color="blue">我喜欢的：</font></strong></h3><p><strong>我喜欢打篮球 🏀</strong></p><blockquote><p>我是传奇球星<em>Kobe Bryant</em>的铁杆粉丝 </p><p><em>Kobe</em>粉丝的字典里没有”放弃“二字！</p><p><strong>“ Friends always come and go, but a champion flag will never fall ! 🏆 “</strong></p><div align=left><img src="https://n.sinaimg.cn/sinacn12/211/w2048h1363/20180823/15c8-hhzsnec6055235.jpg" alt="thegreat2010!" width="600" height="400" /></div><p><strong>“ Second place means you are the first loser ! “</strong></p><div align=left><img src="https://ts1.tc.mm.bing.net/th/id/R-C.f343e7606d3ee999bb7cca72021a3f25?rik=lnVs0YbiLAQp7A&riu=http%3a%2f%2ffile.qiumiwu.com%2fimgs%2f20200317%2f1584434559376554.jpg&ehk=4gVfPuk%2f8b4EryaVLHOjjjFlgAEaS0wuCz3XfHYua6I%3d&risl=&pid=ImgRaw&r=0" alt="thegreat2010!" width="600" height="400" /></div><p><strong>“ Somebody has to win, so why not be me? “</strong></p><div align=left><img src="https://ts1.tc.mm.bing.net/th/id/R-C.4ac3ba3869c279ad8620c3492d3e61eb?rik=45oONH9yVyeLaQ&riu=http%3a%2f%2fimg.mp.sohu.com%2fupload%2f20171219%2f8e635a7bd4cf4ed4ae4573be8b7f9a16_th.JPG&ehk=w%2bHL%2fvomMJ2jw8XXdj087b%2bix3UAgV4WenYhYnCVXEc%3d&risl=&pid=ImgRaw&r=0" alt="thegreat2010!" width="600" height="400" /></div><p><strong><font size=5><font color="purple">Mamba Out !</font><font color="orange">  Mamba Forever!</font></font></strong></p></blockquote><p><strong>我喜欢听的歌挺多的</strong></p><p>**歌剧音乐剧🎷、流行通俗🎸我都喜欢 **</p><p><strong>钟爱<em>Lana Del Ray</em></strong> </p><blockquote><p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.QkE_dEvv2a_1rfpSvc4NLwAAAA?w=166&h=180&c=7&r=0&o=7&dpr=2.2&pid=1.7&rm=3" alt="lanadelray专辑 的图像结果" style="zoom: 68.5%;" /><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.-RL4R68dMgjYkp05BCqXWQHaHa?w=185&h=187&c=7&r=0&o=7&dpr=2.2&pid=1.7&rm=3 =" alt="lanadelray专辑 的图像结果" style="zoom:50%;" /></p><p><em><strong>2023年夏至今，百听不厌，YYDS</strong></em> 🥰</p></blockquote><h3 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a><font color="broen">未来规划</font></h3><p>emmm 好好干 好好学 🧘‍♂️</p><p>争取读个研，进大厂，争取干算法岗</p><p>好吧，现在是北京时间 00：29 ， 2025.12.10   </p><p>下次再聊，晚安~🤞 </p><div align=middle><img src="https://www.bupt.edu.cn/__local/C/8E/F7/EE902059AE32E0E6325EFEE8F46_B2D41D06_CD58.png" alt="thegreat2010!" width="600" height="150" /></div>]]></content>
      
      
      <categories>
          
          <category> about </category>
          
          <category> essay </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI Platform部分技术栈</title>
      <link href="/2025/12/08/AIpiatform_%E6%8A%80%E6%9C%AF%E6%A0%88/"/>
      <url>/2025/12/08/AIpiatform_%E6%8A%80%E6%9C%AF%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>以下是为我<strong>零基础新手</strong>量身定制的<strong>容器平台技术栈学习路线</strong>。</p><h2 id="🎯-零基础学习路线图（总览）"><a href="#🎯-零基础学习路线图（总览）" class="headerlink" title="🎯 零基础学习路线图（总览）"></a>🎯 <strong>零基础学习路线图（总览）</strong></h2><p><strong>预计周期：3-4个月（按每周10小时学习时间）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一阶段：基础认知与Linux (1-2周)</span><br><span class="line">第二阶段：Docker核心技能 (3-4周)  </span><br><span class="line">第三阶段：存储与网络基础 (2-3周)</span><br><span class="line">第四阶段：平台实战与理解 (2-3周)</span><br><span class="line">第五阶段：扩展与进阶 (持续学习)</span><br></pre></td></tr></table></figure><hr><h2 id="📘-第一阶段：基础认知与Linux-1-2周"><a href="#📘-第一阶段：基础认知与Linux-1-2周" class="headerlink" title="📘 第一阶段：基础认知与Linux (1-2周)"></a>📘 <strong>第一阶段：基础认知与Linux (1-2周)</strong></h2><h3 id="目标：建立计算机基础认知，学会基本的Linux操作"><a href="#目标：建立计算机基础认知，学会基本的Linux操作" class="headerlink" title="目标：建立计算机基础认知，学会基本的Linux操作"></a><strong>目标</strong>：建立计算机基础认知，学会基本的Linux操作</h3><p><strong>学习内容</strong>：</p><ol><li><p><strong>计算机基础概念</strong></p><ul><li>什么是操作系统、进程、内存、硬盘</li><li>什么是IP地址、端口、网络协议</li><li>[B站搜索]：“计算机基础入门” 系列视频</li></ul></li><li><p><strong>Linux基础命令（最重要！）</strong></p><ul><li>如何在命令行中移动、查看文件</li><li>如何安装软件、管理权限</li><li><strong>推荐学习资源</strong>：<ul><li>[B站]：搜索“Linux基础命令10小时”</li><li>[网站]：菜鸟教程Linux教程</li><li><strong>动手练习</strong>：在Windows上安装WSL2，或Mac使用终端</li></ul></li></ul></li></ol><p><strong>每日任务示例</strong>：</p><ul><li>Day1：学习 <code>ls</code>, <code>cd</code>, <code>pwd</code> 命令</li><li>Day2：学习 <code>mkdir</code>, <code>rm</code>, <code>cp</code> 命令</li><li>Day3：学习 <code>cat</code>, <code>vim</code>, <code>nano</code> 编辑文件</li><li>Day4：学习 <code>ps</code>, <code>top</code> 查看进程</li><li>Day5：学习 <code>chmod</code>, <code>chown</code> 权限管理</li></ul><hr><h2 id="🐳-第二阶段：Docker核心技能-3-4周"><a href="#🐳-第二阶段：Docker核心技能-3-4周" class="headerlink" title="🐳 第二阶段：Docker核心技能 (3-4周)"></a>🐳 <strong>第二阶段：Docker核心技能 (3-4周)</strong></h2><h3 id="目标：掌握Docker基本使用，理解容器概念"><a href="#目标：掌握Docker基本使用，理解容器概念" class="headerlink" title="目标：掌握Docker基本使用，理解容器概念"></a><strong>目标</strong>：掌握Docker基本使用，理解容器概念</h3><p><strong>学习路径</strong>：</p><ol><li><p><strong>Docker是什么？（第1周）</strong></p><ul><li>看这个视频：[B站]“Docker通俗易懂解释”</li><li>安装Docker Desktop（Windows&#x2F;Mac一键安装）</li><li>运行第一个容器：<code>docker run hello-world</code></li></ul></li><li><p><strong>Docker基础操作（第2周）</strong></p><ul><li>学习核心命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker pull     # 下载镜像</span><br><span class="line">docker run      # 运行容器</span><br><span class="line">docker ps       # 查看运行中的容器</span><br><span class="line">docker stop     # 停止容器</span><br><span class="line">docker rm       # 删除容器</span><br><span class="line">docker images   # 查看镜像</span><br></pre></td></tr></table></figure></li><li>完成一个小练习：用Docker运行一个Nginx网站</li></ul></li><li><p><strong>Dockerfile与镜像制作（第3周）</strong></p><ul><li>理解镜像和容器的关系</li><li>学习编写简单的Dockerfile</li><li>自己制作一个包含Python环境的镜像</li></ul></li><li><p><strong>数据持久化（第4周）</strong></p><ul><li>理解Volume的概念</li><li>学习将本地文件夹挂载到容器内</li><li>练习：创建一个MySQL容器，将数据保存在本地</li></ul></li></ol><p><strong>推荐资源</strong>：</p><ul><li>[视频]：B站“Docker入门到实战”</li><li>[交互式学习]：Docker官方教程（有中文）</li><li>[书籍]：《Docker入门与实践》（电子版）</li></ul><hr><h2 id="💾-第三阶段：存储与网络基础-2-3周"><a href="#💾-第三阶段：存储与网络基础-2-3周" class="headerlink" title="💾 第三阶段：存储与网络基础 (2-3周)"></a>💾 <strong>第三阶段：存储与网络基础 (2-3周)</strong></h2><h3 id="目标：理解平台中的存储和网络设计"><a href="#目标：理解平台中的存储和网络设计" class="headerlink" title="目标：理解平台中的存储和网络设计"></a><strong>目标</strong>：理解平台中的存储和网络设计</h3><p><strong>学习内容</strong>：</p><ol><li><p><strong>NFS基础（第1周）</strong></p><ul><li>什么是NFS（网络文件系统）</li><li>为什么需要共享存储</li><li>简单搭建一个NFS服务体验</li></ul></li><li><p><strong>理解平台存储架构</strong></p><ul><li>重新阅读文档中的“容器磁盘 vs NFS云盘”</li><li>画图理解：容器内部 <code>/root</code> 目录是如何挂载NFS的</li><li>理解为什么conda环境可以共享</li></ul></li><li><p><strong>网络基础（第2-3周）</strong></p><ul><li>什么是IP、端口、网关</li><li>Docker网络基础：桥接网络、端口映射</li><li>理解 <code>-p 8080:80</code> 是什么意思</li><li>学习简单的网络故障排查</li></ul></li></ol><p><strong>动手实验</strong>：</p><ul><li>在本地搭建两个虚拟机，配置NFS共享</li><li>创建一个Docker容器，挂载NFS共享目录</li></ul><hr><h2 id="🏗️-第四阶段：平台实战与理解-2-3周"><a href="#🏗️-第四阶段：平台实战与理解-2-3周" class="headerlink" title="🏗️ 第四阶段：平台实战与理解 (2-3周)"></a>🏗️ <strong>第四阶段：平台实战与理解 (2-3周)</strong></h2><h3 id="目标：将所学应用到实际平台理解中"><a href="#目标：将所学应用到实际平台理解中" class="headerlink" title="目标：将所学应用到实际平台理解中"></a><strong>目标</strong>：将所学应用到实际平台理解中</h3><p><strong>学习步骤</strong>：</p><ol><li><p><strong>平台架构图绘制</strong></p><ul><li>根据文档，画出平台的简化架构图</li><li>标记出：用户 → Web界面 → Gateway → Host → Container → NFS</li><li>理解数据流向</li></ul></li><li><p><strong>实际操作平台</strong></p><ul><li>申请一个测试容器</li><li>在容器内安装软件（用apt）</li><li>在&#x2F;root目录下创建文件，理解NFS共享</li><li>用conda创建一个Python环境</li></ul></li><li><p><strong>资源监控初识</strong></p><ul><li>学习使用 <code>htop</code>, <code>nvidia-smi</code>, <code>df -h</code> 等命令</li><li>理解平台文档中的“CPU、内存、GPU监控”</li></ul></li><li><p><strong>问题排查基础</strong></p><ul><li>容器启动失败怎么办？</li><li>网络不通怎么办？</li><li>磁盘空间不足怎么办？</li></ul></li></ol><hr><h2 id="🚀-第五阶段：扩展与进阶-持续学习"><a href="#🚀-第五阶段：扩展与进阶-持续学习" class="headerlink" title="🚀 第五阶段：扩展与进阶 (持续学习)"></a>🚀 <strong>第五阶段：扩展与进阶 (持续学习)</strong></h2><h3 id="目标：深入理解平台高级特性"><a href="#目标：深入理解平台高级特性" class="headerlink" title="目标：深入理解平台高级特性"></a><strong>目标</strong>：深入理解平台高级特性</h3><p><strong>可选学习方向</strong>：</p><ol><li><strong>容器编排</strong>：学习Docker Compose、Kubernetes基础</li><li><strong>监控系统</strong>：学习Prometheus + Grafana</li><li><strong>CI&#x2F;CD</strong>：学习GitLab CI或GitHub Actions</li><li><strong>安全基础</strong>：学习容器安全、权限控制</li></ol><hr><h2 id="📚-学习资源推荐（零基础友好）"><a href="#📚-学习资源推荐（零基础友好）" class="headerlink" title="📚 学习资源推荐（零基础友好）"></a>📚 <strong>学习资源推荐（零基础友好）</strong></h2><h3 id="视频教程（B站）："><a href="#视频教程（B站）：" class="headerlink" title="视频教程（B站）："></a><strong>视频教程（B站）</strong>：</h3><ol><li>【Linux】“Linux基础命令全集” - 黑马程序员</li><li>【Docker】“Docker容器技术全集” - 尚硅谷</li><li>【网络】“计算机网络基础” - 湖科大教书匠</li></ol><h3 id="网站-文档："><a href="#网站-文档：" class="headerlink" title="网站&#x2F;文档："></a><strong>网站&#x2F;文档</strong>：</h3><ol><li><strong>菜鸟教程</strong>（runoob.com）- Linux&#x2F;Docker基础</li><li><strong>Docker官方文档</strong>（有中文）- 最权威</li><li><strong>MDN Web文档</strong> - 学习网络基础知识</li></ol><h3 id="实践平台："><a href="#实践平台：" class="headerlink" title="实践平台："></a><strong>实践平台</strong>：</h3><ol><li><strong>本地</strong>：Docker Desktop + WSL2</li><li><strong>在线实验</strong>：Katacoda（免费Docker实验环境）</li><li><strong>云服务器</strong>：阿里云&#x2F;腾讯云学生优惠（最低配置即可）</li></ol><hr><h2 id="🎯-具体学习计划表（前2个月）"><a href="#🎯-具体学习计划表（前2个月）" class="headerlink" title="🎯 具体学习计划表（前2个月）"></a>🎯 <strong>具体学习计划表（前2个月）</strong></h2><table><thead><tr><th>周数</th><th>学习重点</th><th>每日任务（约1-2小时）</th><th>完成标志</th></tr></thead><tbody><tr><td>第1周</td><td>Linux基础</td><td>学习5个命令+练习</td><td>能在命令行中自如移动、查看文件</td></tr><tr><td>第2周</td><td>Docker安装与运行</td><td>安装Docker，运行3种不同容器</td><td>成功运行Nginx、Redis、MySQL容器</td></tr><tr><td>第3周</td><td>Docker命令精通</td><td>掌握10个核心命令</td><td>能独立管理容器生命周期</td></tr><tr><td>第4周</td><td>Dockerfile实践</td><td>编写2个Dockerfile</td><td>成功构建自定义镜像</td></tr><tr><td>第5周</td><td>数据持久化</td><td>练习Volume挂载</td><td>实现容器数据持久化保存</td></tr><tr><td>第6周</td><td>NFS基础</td><td>搭建简单NFS服务</td><td>实现两台机器文件共享</td></tr><tr><td>第7周</td><td>平台理解</td><td>画出平台架构图</td><td>能向别人解释平台工作原理</td></tr><tr><td>第8周</td><td>平台实战</td><td>在平台上完成一个任务</td><td>成功创建容器、安装软件、保存数据</td></tr></tbody></table><hr><h2 id="❓-遇到困难怎么办？"><a href="#❓-遇到困难怎么办？" class="headerlink" title="❓ 遇到困难怎么办？"></a>❓ <strong>遇到困难怎么办？</strong></h2><ol><li><strong>谷歌&#x2F;百度是你的朋友</strong>：搜索“docker如何xxx”</li><li><strong>加入技术社区</strong>：Stack Overflow、SegmentFault、知乎</li><li><strong>问问题技巧</strong>：描述你做了什么、期望结果是什么、实际结果是什么、错误信息是什么</li><li><strong>先尝试再问</strong>：自己尝试解决30分钟，解决不了再问</li></ol><hr><h2 id="💡-最重要建议"><a href="#💡-最重要建议" class="headerlink" title="💡 最重要建议"></a>💡 <strong>最重要建议</strong></h2><ol><li><strong>动手 &gt; 看视频 &gt; 看书</strong>：技术学习必须动手</li><li><strong>不要怕犯错</strong>：容器可以随意删除重建</li><li><strong>从简单开始</strong>：先跑起来，再理解原理</li><li><strong>定期复习</strong>：每周回顾一次学过的内容</li><li><strong>找同伴</strong>：找个一起学习的伙伴互相督促</li></ol><p><strong>现在就开始</strong>：今天就在你的电脑上安装Docker，运行 <code>docker run hello-world</code>！</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI Platform </tag>
            
            <tag> plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研英语Plans</title>
      <link href="/2025/12/07/English/"/>
      <url>/2025/12/07/English/</url>
      
        <content type="html"><![CDATA[<h2 id="总目标：2027考研"><a href="#总目标：2027考研" class="headerlink" title="总目标：2027考研"></a>总目标：2027考研</h2><p>目标院校</p><blockquote><p><strong>本校就好</strong></p></blockquote><p>目标分数</p><blockquote><p>英语别拖累我就好</p></blockquote><h2 id="基本规划"><a href="#基本规划" class="headerlink" title="基本规划"></a>基本规划</h2><h3 id="跨年之前"><a href="#跨年之前" class="headerlink" title="跨年之前"></a>跨年之前</h3><ul><li>多看看外刊 </li><li>多听听外语</li><li>多背背单词</li></ul><h3 id="跨年之后"><a href="#跨年之后" class="headerlink" title="跨年之后"></a>跨年之后</h3><ul><li>该刷题了</li></ul>]]></content>
      
      
      <categories>
          
          <category> English </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plan </tag>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一句话在这！</title>
      <link href="/2025/12/06/THE%20FIRST/"/>
      <url>/2025/12/06/THE%20FIRST/</url>
      
        <content type="html"><![CDATA[<h1 id="第一句话"><a href="#第一句话" class="headerlink" title="第一句话"></a>第一句话</h1><p>能看见我吗？！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/12/06/hello-world/"/>
      <url>/2025/12/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>这个是我留的礼物！！！</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
